
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model AppointmentType
 * 
 */
export type AppointmentType = $Result.DefaultSelection<Prisma.$AppointmentTypePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model FormEncounter
 * 
 */
export type FormEncounter = $Result.DefaultSelection<Prisma.$FormEncounterPayload>
/**
 * Model FormResource
 * 
 */
export type FormResource = $Result.DefaultSelection<Prisma.$FormResourcePayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model Field
 * 
 */
export type Field = $Result.DefaultSelection<Prisma.$FieldPayload>
/**
 * Model FieldAnswer
 * 
 */
export type FieldAnswer = $Result.DefaultSelection<Prisma.$FieldAnswerPayload>
/**
 * Model FieldOption
 * 
 */
export type FieldOption = $Result.DefaultSelection<Prisma.$FieldOptionPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model EncounterType
 * 
 */
export type EncounterType = $Result.DefaultSelection<Prisma.$EncounterTypePayload>
/**
 * Model Obs
 * 
 */
export type Obs = $Result.DefaultSelection<Prisma.$ObsPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderFrequency
 * 
 */
export type OrderFrequency = $Result.DefaultSelection<Prisma.$OrderFrequencyPayload>
/**
 * Model OrderRoute
 * 
 */
export type OrderRoute = $Result.DefaultSelection<Prisma.$OrderRoutePayload>
/**
 * Model OrderType
 * 
 */
export type OrderType = $Result.DefaultSelection<Prisma.$OrderTypePayload>
/**
 * Model OrderUnit
 * 
 */
export type OrderUnit = $Result.DefaultSelection<Prisma.$OrderUnitPayload>
/**
 * Model Concept
 * 
 */
export type Concept = $Result.DefaultSelection<Prisma.$ConceptPayload>
/**
 * Model ConceptAnswer
 * 
 */
export type ConceptAnswer = $Result.DefaultSelection<Prisma.$ConceptAnswerPayload>
/**
 * Model ConceptClass
 * 
 */
export type ConceptClass = $Result.DefaultSelection<Prisma.$ConceptClassPayload>
/**
 * Model ConceptDatatype
 * 
 */
export type ConceptDatatype = $Result.DefaultSelection<Prisma.$ConceptDatatypePayload>
/**
 * Model ConceptMap
 * 
 */
export type ConceptMap = $Result.DefaultSelection<Prisma.$ConceptMapPayload>
/**
 * Model ConceptName
 * 
 */
export type ConceptName = $Result.DefaultSelection<Prisma.$ConceptNamePayload>
/**
 * Model ConceptNumeric
 * 
 */
export type ConceptNumeric = $Result.DefaultSelection<Prisma.$ConceptNumericPayload>
/**
 * Model ConceptProposal
 * 
 */
export type ConceptProposal = $Result.DefaultSelection<Prisma.$ConceptProposalPayload>
/**
 * Model ConceptSet
 * 
 */
export type ConceptSet = $Result.DefaultSelection<Prisma.$ConceptSetPayload>
/**
 * Model ConceptSource
 * 
 */
export type ConceptSource = $Result.DefaultSelection<Prisma.$ConceptSourcePayload>
/**
 * Model ConceptWord
 * 
 */
export type ConceptWord = $Result.DefaultSelection<Prisma.$ConceptWordPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model BlogPostTag
 * 
 */
export type BlogPostTag = $Result.DefaultSelection<Prisma.$BlogPostTagPayload>
/**
 * Model BlogPostTagArrow
 * 
 */
export type BlogPostTagArrow = $Result.DefaultSelection<Prisma.$BlogPostTagArrowPayload>
/**
 * Model BlogPostAuthor
 * 
 */
export type BlogPostAuthor = $Result.DefaultSelection<Prisma.$BlogPostAuthorPayload>
/**
 * Model SpaceTimeCoordinates
 * 
 */
export type SpaceTimeCoordinates = $Result.DefaultSelection<Prisma.$SpaceTimeCoordinatesPayload>
/**
 * Model BudgetEntry
 * 
 */
export type BudgetEntry = $Result.DefaultSelection<Prisma.$BudgetEntryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model BudUser
 * 
 */
export type BudUser = $Result.DefaultSelection<Prisma.$BudUserPayload>
/**
 * Model BudgetBudUser
 * 
 */
export type BudgetBudUser = $Result.DefaultSelection<Prisma.$BudgetBudUserPayload>
/**
 * Model BudEvent
 * 
 */
export type BudEvent = $Result.DefaultSelection<Prisma.$BudEventPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Appointments
 * const appointments = await prisma.appointment.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Appointments
   * const appointments = await prisma.appointment.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.appointmentType`: Exposes CRUD operations for the **AppointmentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppointmentTypes
    * const appointmentTypes = await prisma.appointmentType.findMany()
    * ```
    */
  get appointmentType(): Prisma.AppointmentTypeDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs>;

  /**
   * `prisma.formEncounter`: Exposes CRUD operations for the **FormEncounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormEncounters
    * const formEncounters = await prisma.formEncounter.findMany()
    * ```
    */
  get formEncounter(): Prisma.FormEncounterDelegate<ExtArgs>;

  /**
   * `prisma.formResource`: Exposes CRUD operations for the **FormResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormResources
    * const formResources = await prisma.formResource.findMany()
    * ```
    */
  get formResource(): Prisma.FormResourceDelegate<ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.field`: Exposes CRUD operations for the **Field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.field.findMany()
    * ```
    */
  get field(): Prisma.FieldDelegate<ExtArgs>;

  /**
   * `prisma.fieldAnswer`: Exposes CRUD operations for the **FieldAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldAnswers
    * const fieldAnswers = await prisma.fieldAnswer.findMany()
    * ```
    */
  get fieldAnswer(): Prisma.FieldAnswerDelegate<ExtArgs>;

  /**
   * `prisma.fieldOption`: Exposes CRUD operations for the **FieldOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldOptions
    * const fieldOptions = await prisma.fieldOption.findMany()
    * ```
    */
  get fieldOption(): Prisma.FieldOptionDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.encounterType`: Exposes CRUD operations for the **EncounterType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterTypes
    * const encounterTypes = await prisma.encounterType.findMany()
    * ```
    */
  get encounterType(): Prisma.EncounterTypeDelegate<ExtArgs>;

  /**
   * `prisma.obs`: Exposes CRUD operations for the **Obs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obs
    * const obs = await prisma.obs.findMany()
    * ```
    */
  get obs(): Prisma.ObsDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderFrequency`: Exposes CRUD operations for the **OrderFrequency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderFrequencies
    * const orderFrequencies = await prisma.orderFrequency.findMany()
    * ```
    */
  get orderFrequency(): Prisma.OrderFrequencyDelegate<ExtArgs>;

  /**
   * `prisma.orderRoute`: Exposes CRUD operations for the **OrderRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderRoutes
    * const orderRoutes = await prisma.orderRoute.findMany()
    * ```
    */
  get orderRoute(): Prisma.OrderRouteDelegate<ExtArgs>;

  /**
   * `prisma.orderType`: Exposes CRUD operations for the **OrderType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTypes
    * const orderTypes = await prisma.orderType.findMany()
    * ```
    */
  get orderType(): Prisma.OrderTypeDelegate<ExtArgs>;

  /**
   * `prisma.orderUnit`: Exposes CRUD operations for the **OrderUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderUnits
    * const orderUnits = await prisma.orderUnit.findMany()
    * ```
    */
  get orderUnit(): Prisma.OrderUnitDelegate<ExtArgs>;

  /**
   * `prisma.concept`: Exposes CRUD operations for the **Concept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Concepts
    * const concepts = await prisma.concept.findMany()
    * ```
    */
  get concept(): Prisma.ConceptDelegate<ExtArgs>;

  /**
   * `prisma.conceptAnswer`: Exposes CRUD operations for the **ConceptAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptAnswers
    * const conceptAnswers = await prisma.conceptAnswer.findMany()
    * ```
    */
  get conceptAnswer(): Prisma.ConceptAnswerDelegate<ExtArgs>;

  /**
   * `prisma.conceptClass`: Exposes CRUD operations for the **ConceptClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptClasses
    * const conceptClasses = await prisma.conceptClass.findMany()
    * ```
    */
  get conceptClass(): Prisma.ConceptClassDelegate<ExtArgs>;

  /**
   * `prisma.conceptDatatype`: Exposes CRUD operations for the **ConceptDatatype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptDatatypes
    * const conceptDatatypes = await prisma.conceptDatatype.findMany()
    * ```
    */
  get conceptDatatype(): Prisma.ConceptDatatypeDelegate<ExtArgs>;

  /**
   * `prisma.conceptMap`: Exposes CRUD operations for the **ConceptMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptMaps
    * const conceptMaps = await prisma.conceptMap.findMany()
    * ```
    */
  get conceptMap(): Prisma.ConceptMapDelegate<ExtArgs>;

  /**
   * `prisma.conceptName`: Exposes CRUD operations for the **ConceptName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptNames
    * const conceptNames = await prisma.conceptName.findMany()
    * ```
    */
  get conceptName(): Prisma.ConceptNameDelegate<ExtArgs>;

  /**
   * `prisma.conceptNumeric`: Exposes CRUD operations for the **ConceptNumeric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptNumerics
    * const conceptNumerics = await prisma.conceptNumeric.findMany()
    * ```
    */
  get conceptNumeric(): Prisma.ConceptNumericDelegate<ExtArgs>;

  /**
   * `prisma.conceptProposal`: Exposes CRUD operations for the **ConceptProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptProposals
    * const conceptProposals = await prisma.conceptProposal.findMany()
    * ```
    */
  get conceptProposal(): Prisma.ConceptProposalDelegate<ExtArgs>;

  /**
   * `prisma.conceptSet`: Exposes CRUD operations for the **ConceptSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptSets
    * const conceptSets = await prisma.conceptSet.findMany()
    * ```
    */
  get conceptSet(): Prisma.ConceptSetDelegate<ExtArgs>;

  /**
   * `prisma.conceptSource`: Exposes CRUD operations for the **ConceptSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptSources
    * const conceptSources = await prisma.conceptSource.findMany()
    * ```
    */
  get conceptSource(): Prisma.ConceptSourceDelegate<ExtArgs>;

  /**
   * `prisma.conceptWord`: Exposes CRUD operations for the **ConceptWord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptWords
    * const conceptWords = await prisma.conceptWord.findMany()
    * ```
    */
  get conceptWord(): Prisma.ConceptWordDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.blogPostTag`: Exposes CRUD operations for the **BlogPostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPostTags
    * const blogPostTags = await prisma.blogPostTag.findMany()
    * ```
    */
  get blogPostTag(): Prisma.BlogPostTagDelegate<ExtArgs>;

  /**
   * `prisma.blogPostTagArrow`: Exposes CRUD operations for the **BlogPostTagArrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPostTagArrows
    * const blogPostTagArrows = await prisma.blogPostTagArrow.findMany()
    * ```
    */
  get blogPostTagArrow(): Prisma.BlogPostTagArrowDelegate<ExtArgs>;

  /**
   * `prisma.blogPostAuthor`: Exposes CRUD operations for the **BlogPostAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPostAuthors
    * const blogPostAuthors = await prisma.blogPostAuthor.findMany()
    * ```
    */
  get blogPostAuthor(): Prisma.BlogPostAuthorDelegate<ExtArgs>;

  /**
   * `prisma.spaceTimeCoordinates`: Exposes CRUD operations for the **SpaceTimeCoordinates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaceTimeCoordinates
    * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findMany()
    * ```
    */
  get spaceTimeCoordinates(): Prisma.SpaceTimeCoordinatesDelegate<ExtArgs>;

  /**
   * `prisma.budgetEntry`: Exposes CRUD operations for the **BudgetEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetEntries
    * const budgetEntries = await prisma.budgetEntry.findMany()
    * ```
    */
  get budgetEntry(): Prisma.BudgetEntryDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.budUser`: Exposes CRUD operations for the **BudUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudUsers
    * const budUsers = await prisma.budUser.findMany()
    * ```
    */
  get budUser(): Prisma.BudUserDelegate<ExtArgs>;

  /**
   * `prisma.budgetBudUser`: Exposes CRUD operations for the **BudgetBudUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetBudUsers
    * const budgetBudUsers = await prisma.budgetBudUser.findMany()
    * ```
    */
  get budgetBudUser(): Prisma.BudgetBudUserDelegate<ExtArgs>;

  /**
   * `prisma.budEvent`: Exposes CRUD operations for the **BudEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudEvents
    * const budEvents = await prisma.budEvent.findMany()
    * ```
    */
  get budEvent(): Prisma.BudEventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Appointment: 'Appointment',
    AppointmentType: 'AppointmentType',
    Location: 'Location',
    Patient: 'Patient',
    Provider: 'Provider',
    Form: 'Form',
    FormEncounter: 'FormEncounter',
    FormResource: 'FormResource',
    FormSubmission: 'FormSubmission',
    Field: 'Field',
    FieldAnswer: 'FieldAnswer',
    FieldOption: 'FieldOption',
    Encounter: 'Encounter',
    EncounterType: 'EncounterType',
    Obs: 'Obs',
    Order: 'Order',
    OrderFrequency: 'OrderFrequency',
    OrderRoute: 'OrderRoute',
    OrderType: 'OrderType',
    OrderUnit: 'OrderUnit',
    Concept: 'Concept',
    ConceptAnswer: 'ConceptAnswer',
    ConceptClass: 'ConceptClass',
    ConceptDatatype: 'ConceptDatatype',
    ConceptMap: 'ConceptMap',
    ConceptName: 'ConceptName',
    ConceptNumeric: 'ConceptNumeric',
    ConceptProposal: 'ConceptProposal',
    ConceptSet: 'ConceptSet',
    ConceptSource: 'ConceptSource',
    ConceptWord: 'ConceptWord',
    Resource: 'Resource',
    BlogPost: 'BlogPost',
    BlogPostTag: 'BlogPostTag',
    BlogPostTagArrow: 'BlogPostTagArrow',
    BlogPostAuthor: 'BlogPostAuthor',
    SpaceTimeCoordinates: 'SpaceTimeCoordinates',
    BudgetEntry: 'BudgetEntry',
    Service: 'Service',
    Budget: 'Budget',
    Report: 'Report',
    BudUser: 'BudUser',
    BudgetBudUser: 'BudgetBudUser',
    BudEvent: 'BudEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'appointment' | 'appointmentType' | 'location' | 'patient' | 'provider' | 'form' | 'formEncounter' | 'formResource' | 'formSubmission' | 'field' | 'fieldAnswer' | 'fieldOption' | 'encounter' | 'encounterType' | 'obs' | 'order' | 'orderFrequency' | 'orderRoute' | 'orderType' | 'orderUnit' | 'concept' | 'conceptAnswer' | 'conceptClass' | 'conceptDatatype' | 'conceptMap' | 'conceptName' | 'conceptNumeric' | 'conceptProposal' | 'conceptSet' | 'conceptSource' | 'conceptWord' | 'resource' | 'blogPost' | 'blogPostTag' | 'blogPostTagArrow' | 'blogPostAuthor' | 'spaceTimeCoordinates' | 'budgetEntry' | 'service' | 'budget' | 'report' | 'budUser' | 'budgetBudUser' | 'budEvent'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      AppointmentType: {
        payload: Prisma.$AppointmentTypePayload<ExtArgs>
        fields: Prisma.AppointmentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          findFirst: {
            args: Prisma.AppointmentTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          findMany: {
            args: Prisma.AppointmentTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>[]
          }
          create: {
            args: Prisma.AppointmentTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          createMany: {
            args: Prisma.AppointmentTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppointmentTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          update: {
            args: Prisma.AppointmentTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          deleteMany: {
            args: Prisma.AppointmentTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AppointmentTypePayload>
          }
          aggregate: {
            args: Prisma.AppointmentTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointmentType>
          }
          groupBy: {
            args: Prisma.AppointmentTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentTypeCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>,
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      FormEncounter: {
        payload: Prisma.$FormEncounterPayload<ExtArgs>
        fields: Prisma.FormEncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormEncounterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormEncounterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          findFirst: {
            args: Prisma.FormEncounterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormEncounterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          findMany: {
            args: Prisma.FormEncounterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>[]
          }
          create: {
            args: Prisma.FormEncounterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          createMany: {
            args: Prisma.FormEncounterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormEncounterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          update: {
            args: Prisma.FormEncounterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          deleteMany: {
            args: Prisma.FormEncounterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormEncounterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormEncounterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormEncounterPayload>
          }
          aggregate: {
            args: Prisma.FormEncounterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormEncounter>
          }
          groupBy: {
            args: Prisma.FormEncounterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormEncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormEncounterCountArgs<ExtArgs>,
            result: $Utils.Optional<FormEncounterCountAggregateOutputType> | number
          }
        }
      }
      FormResource: {
        payload: Prisma.$FormResourcePayload<ExtArgs>
        fields: Prisma.FormResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormResourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormResourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          findFirst: {
            args: Prisma.FormResourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormResourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          findMany: {
            args: Prisma.FormResourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>[]
          }
          create: {
            args: Prisma.FormResourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          createMany: {
            args: Prisma.FormResourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormResourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          update: {
            args: Prisma.FormResourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          deleteMany: {
            args: Prisma.FormResourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormResourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormResourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResourcePayload>
          }
          aggregate: {
            args: Prisma.FormResourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormResource>
          }
          groupBy: {
            args: Prisma.FormResourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormResourceCountArgs<ExtArgs>,
            result: $Utils.Optional<FormResourceCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Field: {
        payload: Prisma.$FieldPayload<ExtArgs>
        fields: Prisma.FieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findFirst: {
            args: Prisma.FieldFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findMany: {
            args: Prisma.FieldFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          create: {
            args: Prisma.FieldCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          createMany: {
            args: Prisma.FieldCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FieldDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          update: {
            args: Prisma.FieldUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          deleteMany: {
            args: Prisma.FieldDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FieldUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FieldUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          aggregate: {
            args: Prisma.FieldAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateField>
          }
          groupBy: {
            args: Prisma.FieldGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldCountArgs<ExtArgs>,
            result: $Utils.Optional<FieldCountAggregateOutputType> | number
          }
        }
      }
      FieldAnswer: {
        payload: Prisma.$FieldAnswerPayload<ExtArgs>
        fields: Prisma.FieldAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldAnswerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldAnswerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          findFirst: {
            args: Prisma.FieldAnswerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldAnswerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          findMany: {
            args: Prisma.FieldAnswerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>[]
          }
          create: {
            args: Prisma.FieldAnswerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          createMany: {
            args: Prisma.FieldAnswerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FieldAnswerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          update: {
            args: Prisma.FieldAnswerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          deleteMany: {
            args: Prisma.FieldAnswerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FieldAnswerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FieldAnswerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldAnswerPayload>
          }
          aggregate: {
            args: Prisma.FieldAnswerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFieldAnswer>
          }
          groupBy: {
            args: Prisma.FieldAnswerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FieldAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldAnswerCountArgs<ExtArgs>,
            result: $Utils.Optional<FieldAnswerCountAggregateOutputType> | number
          }
        }
      }
      FieldOption: {
        payload: Prisma.$FieldOptionPayload<ExtArgs>
        fields: Prisma.FieldOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldOptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldOptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          findFirst: {
            args: Prisma.FieldOptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldOptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          findMany: {
            args: Prisma.FieldOptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>[]
          }
          create: {
            args: Prisma.FieldOptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          createMany: {
            args: Prisma.FieldOptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FieldOptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          update: {
            args: Prisma.FieldOptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          deleteMany: {
            args: Prisma.FieldOptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FieldOptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FieldOptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FieldOptionPayload>
          }
          aggregate: {
            args: Prisma.FieldOptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFieldOption>
          }
          groupBy: {
            args: Prisma.FieldOptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FieldOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldOptionCountArgs<ExtArgs>,
            result: $Utils.Optional<FieldOptionCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>,
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      EncounterType: {
        payload: Prisma.$EncounterTypePayload<ExtArgs>
        fields: Prisma.EncounterTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          findFirst: {
            args: Prisma.EncounterTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          findMany: {
            args: Prisma.EncounterTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>[]
          }
          create: {
            args: Prisma.EncounterTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          createMany: {
            args: Prisma.EncounterTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EncounterTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          update: {
            args: Prisma.EncounterTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          deleteMany: {
            args: Prisma.EncounterTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EncounterTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EncounterTypePayload>
          }
          aggregate: {
            args: Prisma.EncounterTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEncounterType>
          }
          groupBy: {
            args: Prisma.EncounterTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EncounterTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<EncounterTypeCountAggregateOutputType> | number
          }
        }
      }
      Obs: {
        payload: Prisma.$ObsPayload<ExtArgs>
        fields: Prisma.ObsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          findFirst: {
            args: Prisma.ObsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          findMany: {
            args: Prisma.ObsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>[]
          }
          create: {
            args: Prisma.ObsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          createMany: {
            args: Prisma.ObsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          update: {
            args: Prisma.ObsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          deleteMany: {
            args: Prisma.ObsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObsPayload>
          }
          aggregate: {
            args: Prisma.ObsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObs>
          }
          groupBy: {
            args: Prisma.ObsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObsCountArgs<ExtArgs>,
            result: $Utils.Optional<ObsCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderFrequency: {
        payload: Prisma.$OrderFrequencyPayload<ExtArgs>
        fields: Prisma.OrderFrequencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFrequencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFrequencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          findFirst: {
            args: Prisma.OrderFrequencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFrequencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          findMany: {
            args: Prisma.OrderFrequencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>[]
          }
          create: {
            args: Prisma.OrderFrequencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          createMany: {
            args: Prisma.OrderFrequencyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderFrequencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          update: {
            args: Prisma.OrderFrequencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          deleteMany: {
            args: Prisma.OrderFrequencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderFrequencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderFrequencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderFrequencyPayload>
          }
          aggregate: {
            args: Prisma.OrderFrequencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderFrequency>
          }
          groupBy: {
            args: Prisma.OrderFrequencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderFrequencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderFrequencyCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderFrequencyCountAggregateOutputType> | number
          }
        }
      }
      OrderRoute: {
        payload: Prisma.$OrderRoutePayload<ExtArgs>
        fields: Prisma.OrderRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderRouteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderRouteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          findFirst: {
            args: Prisma.OrderRouteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderRouteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          findMany: {
            args: Prisma.OrderRouteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>[]
          }
          create: {
            args: Prisma.OrderRouteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          createMany: {
            args: Prisma.OrderRouteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderRouteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          update: {
            args: Prisma.OrderRouteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          deleteMany: {
            args: Prisma.OrderRouteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderRouteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderRouteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderRoutePayload>
          }
          aggregate: {
            args: Prisma.OrderRouteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderRoute>
          }
          groupBy: {
            args: Prisma.OrderRouteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderRouteCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderRouteCountAggregateOutputType> | number
          }
        }
      }
      OrderType: {
        payload: Prisma.$OrderTypePayload<ExtArgs>
        fields: Prisma.OrderTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          findFirst: {
            args: Prisma.OrderTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          findMany: {
            args: Prisma.OrderTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>[]
          }
          create: {
            args: Prisma.OrderTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          createMany: {
            args: Prisma.OrderTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          update: {
            args: Prisma.OrderTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          deleteMany: {
            args: Prisma.OrderTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderTypePayload>
          }
          aggregate: {
            args: Prisma.OrderTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderType>
          }
          groupBy: {
            args: Prisma.OrderTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderTypeCountAggregateOutputType> | number
          }
        }
      }
      OrderUnit: {
        payload: Prisma.$OrderUnitPayload<ExtArgs>
        fields: Prisma.OrderUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderUnitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderUnitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          findFirst: {
            args: Prisma.OrderUnitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderUnitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          findMany: {
            args: Prisma.OrderUnitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>[]
          }
          create: {
            args: Prisma.OrderUnitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          createMany: {
            args: Prisma.OrderUnitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderUnitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          update: {
            args: Prisma.OrderUnitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          deleteMany: {
            args: Prisma.OrderUnitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUnitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUnitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderUnitPayload>
          }
          aggregate: {
            args: Prisma.OrderUnitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderUnit>
          }
          groupBy: {
            args: Prisma.OrderUnitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderUnitCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderUnitCountAggregateOutputType> | number
          }
        }
      }
      Concept: {
        payload: Prisma.$ConceptPayload<ExtArgs>
        fields: Prisma.ConceptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          findFirst: {
            args: Prisma.ConceptFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          findMany: {
            args: Prisma.ConceptFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>[]
          }
          create: {
            args: Prisma.ConceptCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          createMany: {
            args: Prisma.ConceptCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          update: {
            args: Prisma.ConceptUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          deleteMany: {
            args: Prisma.ConceptDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          aggregate: {
            args: Prisma.ConceptAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConcept>
          }
          groupBy: {
            args: Prisma.ConceptGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptCountAggregateOutputType> | number
          }
        }
      }
      ConceptAnswer: {
        payload: Prisma.$ConceptAnswerPayload<ExtArgs>
        fields: Prisma.ConceptAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptAnswerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptAnswerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          findFirst: {
            args: Prisma.ConceptAnswerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptAnswerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          findMany: {
            args: Prisma.ConceptAnswerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>[]
          }
          create: {
            args: Prisma.ConceptAnswerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          createMany: {
            args: Prisma.ConceptAnswerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptAnswerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          update: {
            args: Prisma.ConceptAnswerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          deleteMany: {
            args: Prisma.ConceptAnswerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptAnswerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptAnswerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptAnswerPayload>
          }
          aggregate: {
            args: Prisma.ConceptAnswerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptAnswer>
          }
          groupBy: {
            args: Prisma.ConceptAnswerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptAnswerCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptAnswerCountAggregateOutputType> | number
          }
        }
      }
      ConceptClass: {
        payload: Prisma.$ConceptClassPayload<ExtArgs>
        fields: Prisma.ConceptClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptClassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptClassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          findFirst: {
            args: Prisma.ConceptClassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptClassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          findMany: {
            args: Prisma.ConceptClassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>[]
          }
          create: {
            args: Prisma.ConceptClassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          createMany: {
            args: Prisma.ConceptClassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptClassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          update: {
            args: Prisma.ConceptClassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          deleteMany: {
            args: Prisma.ConceptClassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptClassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptClassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptClassPayload>
          }
          aggregate: {
            args: Prisma.ConceptClassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptClass>
          }
          groupBy: {
            args: Prisma.ConceptClassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptClassCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptClassCountAggregateOutputType> | number
          }
        }
      }
      ConceptDatatype: {
        payload: Prisma.$ConceptDatatypePayload<ExtArgs>
        fields: Prisma.ConceptDatatypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptDatatypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptDatatypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          findFirst: {
            args: Prisma.ConceptDatatypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptDatatypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          findMany: {
            args: Prisma.ConceptDatatypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>[]
          }
          create: {
            args: Prisma.ConceptDatatypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          createMany: {
            args: Prisma.ConceptDatatypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptDatatypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          update: {
            args: Prisma.ConceptDatatypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          deleteMany: {
            args: Prisma.ConceptDatatypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptDatatypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptDatatypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptDatatypePayload>
          }
          aggregate: {
            args: Prisma.ConceptDatatypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptDatatype>
          }
          groupBy: {
            args: Prisma.ConceptDatatypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptDatatypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptDatatypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptDatatypeCountAggregateOutputType> | number
          }
        }
      }
      ConceptMap: {
        payload: Prisma.$ConceptMapPayload<ExtArgs>
        fields: Prisma.ConceptMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptMapFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptMapFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          findFirst: {
            args: Prisma.ConceptMapFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptMapFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          findMany: {
            args: Prisma.ConceptMapFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>[]
          }
          create: {
            args: Prisma.ConceptMapCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          createMany: {
            args: Prisma.ConceptMapCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptMapDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          update: {
            args: Prisma.ConceptMapUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          deleteMany: {
            args: Prisma.ConceptMapDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptMapUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptMapUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptMapPayload>
          }
          aggregate: {
            args: Prisma.ConceptMapAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptMap>
          }
          groupBy: {
            args: Prisma.ConceptMapGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptMapCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptMapCountAggregateOutputType> | number
          }
        }
      }
      ConceptName: {
        payload: Prisma.$ConceptNamePayload<ExtArgs>
        fields: Prisma.ConceptNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptNameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptNameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          findFirst: {
            args: Prisma.ConceptNameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptNameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          findMany: {
            args: Prisma.ConceptNameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>[]
          }
          create: {
            args: Prisma.ConceptNameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          createMany: {
            args: Prisma.ConceptNameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptNameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          update: {
            args: Prisma.ConceptNameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          deleteMany: {
            args: Prisma.ConceptNameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptNameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptNameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNamePayload>
          }
          aggregate: {
            args: Prisma.ConceptNameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptName>
          }
          groupBy: {
            args: Prisma.ConceptNameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptNameCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptNameCountAggregateOutputType> | number
          }
        }
      }
      ConceptNumeric: {
        payload: Prisma.$ConceptNumericPayload<ExtArgs>
        fields: Prisma.ConceptNumericFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptNumericFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptNumericFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          findFirst: {
            args: Prisma.ConceptNumericFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptNumericFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          findMany: {
            args: Prisma.ConceptNumericFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>[]
          }
          create: {
            args: Prisma.ConceptNumericCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          createMany: {
            args: Prisma.ConceptNumericCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptNumericDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          update: {
            args: Prisma.ConceptNumericUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          deleteMany: {
            args: Prisma.ConceptNumericDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptNumericUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptNumericUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptNumericPayload>
          }
          aggregate: {
            args: Prisma.ConceptNumericAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptNumeric>
          }
          groupBy: {
            args: Prisma.ConceptNumericGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptNumericGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptNumericCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptNumericCountAggregateOutputType> | number
          }
        }
      }
      ConceptProposal: {
        payload: Prisma.$ConceptProposalPayload<ExtArgs>
        fields: Prisma.ConceptProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptProposalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptProposalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          findFirst: {
            args: Prisma.ConceptProposalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptProposalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          findMany: {
            args: Prisma.ConceptProposalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>[]
          }
          create: {
            args: Prisma.ConceptProposalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          createMany: {
            args: Prisma.ConceptProposalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptProposalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          update: {
            args: Prisma.ConceptProposalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          deleteMany: {
            args: Prisma.ConceptProposalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptProposalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptProposalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptProposalPayload>
          }
          aggregate: {
            args: Prisma.ConceptProposalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptProposal>
          }
          groupBy: {
            args: Prisma.ConceptProposalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptProposalCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptProposalCountAggregateOutputType> | number
          }
        }
      }
      ConceptSet: {
        payload: Prisma.$ConceptSetPayload<ExtArgs>
        fields: Prisma.ConceptSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptSetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptSetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          findFirst: {
            args: Prisma.ConceptSetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptSetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          findMany: {
            args: Prisma.ConceptSetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>[]
          }
          create: {
            args: Prisma.ConceptSetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          createMany: {
            args: Prisma.ConceptSetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptSetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          update: {
            args: Prisma.ConceptSetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          deleteMany: {
            args: Prisma.ConceptSetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptSetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptSetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSetPayload>
          }
          aggregate: {
            args: Prisma.ConceptSetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptSet>
          }
          groupBy: {
            args: Prisma.ConceptSetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptSetCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptSetCountAggregateOutputType> | number
          }
        }
      }
      ConceptSource: {
        payload: Prisma.$ConceptSourcePayload<ExtArgs>
        fields: Prisma.ConceptSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptSourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptSourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          findFirst: {
            args: Prisma.ConceptSourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptSourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          findMany: {
            args: Prisma.ConceptSourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>[]
          }
          create: {
            args: Prisma.ConceptSourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          createMany: {
            args: Prisma.ConceptSourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptSourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          update: {
            args: Prisma.ConceptSourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          deleteMany: {
            args: Prisma.ConceptSourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptSourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptSourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptSourcePayload>
          }
          aggregate: {
            args: Prisma.ConceptSourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptSource>
          }
          groupBy: {
            args: Prisma.ConceptSourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptSourceCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptSourceCountAggregateOutputType> | number
          }
        }
      }
      ConceptWord: {
        payload: Prisma.$ConceptWordPayload<ExtArgs>
        fields: Prisma.ConceptWordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptWordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptWordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          findFirst: {
            args: Prisma.ConceptWordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptWordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          findMany: {
            args: Prisma.ConceptWordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>[]
          }
          create: {
            args: Prisma.ConceptWordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          createMany: {
            args: Prisma.ConceptWordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConceptWordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          update: {
            args: Prisma.ConceptWordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          deleteMany: {
            args: Prisma.ConceptWordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptWordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConceptWordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConceptWordPayload>
          }
          aggregate: {
            args: Prisma.ConceptWordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptWord>
          }
          groupBy: {
            args: Prisma.ConceptWordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptWordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptWordCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptWordCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>,
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      BlogPostTag: {
        payload: Prisma.$BlogPostTagPayload<ExtArgs>
        fields: Prisma.BlogPostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostTagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostTagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          findFirst: {
            args: Prisma.BlogPostTagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostTagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          findMany: {
            args: Prisma.BlogPostTagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>[]
          }
          create: {
            args: Prisma.BlogPostTagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          createMany: {
            args: Prisma.BlogPostTagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogPostTagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          update: {
            args: Prisma.BlogPostTagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostTagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostTagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostTagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          aggregate: {
            args: Prisma.BlogPostTagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogPostTag>
          }
          groupBy: {
            args: Prisma.BlogPostTagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostTagCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostTagCountAggregateOutputType> | number
          }
        }
      }
      BlogPostTagArrow: {
        payload: Prisma.$BlogPostTagArrowPayload<ExtArgs>
        fields: Prisma.BlogPostTagArrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostTagArrowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostTagArrowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          findFirst: {
            args: Prisma.BlogPostTagArrowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostTagArrowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          findMany: {
            args: Prisma.BlogPostTagArrowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>[]
          }
          create: {
            args: Prisma.BlogPostTagArrowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          createMany: {
            args: Prisma.BlogPostTagArrowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogPostTagArrowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          update: {
            args: Prisma.BlogPostTagArrowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostTagArrowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostTagArrowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostTagArrowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagArrowPayload>
          }
          aggregate: {
            args: Prisma.BlogPostTagArrowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogPostTagArrow>
          }
          groupBy: {
            args: Prisma.BlogPostTagArrowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostTagArrowGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostTagArrowCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostTagArrowCountAggregateOutputType> | number
          }
        }
      }
      BlogPostAuthor: {
        payload: Prisma.$BlogPostAuthorPayload<ExtArgs>
        fields: Prisma.BlogPostAuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostAuthorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostAuthorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          findFirst: {
            args: Prisma.BlogPostAuthorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostAuthorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          findMany: {
            args: Prisma.BlogPostAuthorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>[]
          }
          create: {
            args: Prisma.BlogPostAuthorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          createMany: {
            args: Prisma.BlogPostAuthorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogPostAuthorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          update: {
            args: Prisma.BlogPostAuthorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostAuthorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostAuthorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostAuthorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPostAuthorPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAuthorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlogPostAuthor>
          }
          groupBy: {
            args: Prisma.BlogPostAuthorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostAuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostAuthorCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogPostAuthorCountAggregateOutputType> | number
          }
        }
      }
      SpaceTimeCoordinates: {
        payload: Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>
        fields: Prisma.SpaceTimeCoordinatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceTimeCoordinatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceTimeCoordinatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          findFirst: {
            args: Prisma.SpaceTimeCoordinatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceTimeCoordinatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          findMany: {
            args: Prisma.SpaceTimeCoordinatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>[]
          }
          create: {
            args: Prisma.SpaceTimeCoordinatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          createMany: {
            args: Prisma.SpaceTimeCoordinatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpaceTimeCoordinatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          update: {
            args: Prisma.SpaceTimeCoordinatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          deleteMany: {
            args: Prisma.SpaceTimeCoordinatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceTimeCoordinatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpaceTimeCoordinatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpaceTimeCoordinatesPayload>
          }
          aggregate: {
            args: Prisma.SpaceTimeCoordinatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpaceTimeCoordinates>
          }
          groupBy: {
            args: Prisma.SpaceTimeCoordinatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpaceTimeCoordinatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceTimeCoordinatesCountArgs<ExtArgs>,
            result: $Utils.Optional<SpaceTimeCoordinatesCountAggregateOutputType> | number
          }
        }
      }
      BudgetEntry: {
        payload: Prisma.$BudgetEntryPayload<ExtArgs>
        fields: Prisma.BudgetEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetEntryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetEntryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          findFirst: {
            args: Prisma.BudgetEntryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetEntryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          findMany: {
            args: Prisma.BudgetEntryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>[]
          }
          create: {
            args: Prisma.BudgetEntryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          createMany: {
            args: Prisma.BudgetEntryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BudgetEntryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          update: {
            args: Prisma.BudgetEntryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          deleteMany: {
            args: Prisma.BudgetEntryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetEntryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BudgetEntryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetEntryPayload>
          }
          aggregate: {
            args: Prisma.BudgetEntryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBudgetEntry>
          }
          groupBy: {
            args: Prisma.BudgetEntryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BudgetEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetEntryCountArgs<ExtArgs>,
            result: $Utils.Optional<BudgetEntryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>,
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      BudUser: {
        payload: Prisma.$BudUserPayload<ExtArgs>
        fields: Prisma.BudUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          findFirst: {
            args: Prisma.BudUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          findMany: {
            args: Prisma.BudUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>[]
          }
          create: {
            args: Prisma.BudUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          createMany: {
            args: Prisma.BudUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BudUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          update: {
            args: Prisma.BudUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          deleteMany: {
            args: Prisma.BudUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BudUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BudUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudUserPayload>
          }
          aggregate: {
            args: Prisma.BudUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBudUser>
          }
          groupBy: {
            args: Prisma.BudUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BudUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudUserCountArgs<ExtArgs>,
            result: $Utils.Optional<BudUserCountAggregateOutputType> | number
          }
        }
      }
      BudgetBudUser: {
        payload: Prisma.$BudgetBudUserPayload<ExtArgs>
        fields: Prisma.BudgetBudUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetBudUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetBudUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          findFirst: {
            args: Prisma.BudgetBudUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetBudUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          findMany: {
            args: Prisma.BudgetBudUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>[]
          }
          create: {
            args: Prisma.BudgetBudUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          createMany: {
            args: Prisma.BudgetBudUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BudgetBudUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          update: {
            args: Prisma.BudgetBudUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          deleteMany: {
            args: Prisma.BudgetBudUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetBudUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BudgetBudUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudgetBudUserPayload>
          }
          aggregate: {
            args: Prisma.BudgetBudUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBudgetBudUser>
          }
          groupBy: {
            args: Prisma.BudgetBudUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BudgetBudUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetBudUserCountArgs<ExtArgs>,
            result: $Utils.Optional<BudgetBudUserCountAggregateOutputType> | number
          }
        }
      }
      BudEvent: {
        payload: Prisma.$BudEventPayload<ExtArgs>
        fields: Prisma.BudEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          findFirst: {
            args: Prisma.BudEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          findMany: {
            args: Prisma.BudEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>[]
          }
          create: {
            args: Prisma.BudEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          createMany: {
            args: Prisma.BudEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BudEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          update: {
            args: Prisma.BudEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          deleteMany: {
            args: Prisma.BudEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BudEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BudEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BudEventPayload>
          }
          aggregate: {
            args: Prisma.BudEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBudEvent>
          }
          groupBy: {
            args: Prisma.BudEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BudEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudEventCountArgs<ExtArgs>,
            result: $Utils.Optional<BudEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AppointmentTypeCountOutputType
   */

  export type AppointmentTypeCountOutputType = {
    appointmentList: number
  }

  export type AppointmentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | AppointmentTypeCountOutputTypeCountAppointmentListArgs
  }

  // Custom InputTypes
  /**
   * AppointmentTypeCountOutputType without action
   */
  export type AppointmentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentTypeCountOutputType
     */
    select?: AppointmentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentTypeCountOutputType without action
   */
  export type AppointmentTypeCountOutputTypeCountAppointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    appointmentList: number
    encounterList: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | LocationCountOutputTypeCountAppointmentListArgs
    encounterList?: boolean | LocationCountOutputTypeCountEncounterListArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAppointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointmentList: number
    encounterList: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | PatientCountOutputTypeCountAppointmentListArgs
    encounterList?: boolean | PatientCountOutputTypeCountEncounterListArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    appointmentList: number
    encounterList: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | ProviderCountOutputTypeCountAppointmentListArgs
    encounterList?: boolean | ProviderCountOutputTypeCountEncounterListArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountAppointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    formEncounterList: number
    formResourceList: number
    formSubmissionList: number
    encounterList: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formEncounterList?: boolean | FormCountOutputTypeCountFormEncounterListArgs
    formResourceList?: boolean | FormCountOutputTypeCountFormResourceListArgs
    formSubmissionList?: boolean | FormCountOutputTypeCountFormSubmissionListArgs
    encounterList?: boolean | FormCountOutputTypeCountEncounterListArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountFormEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormEncounterWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountFormResourceListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResourceWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountFormSubmissionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type FormSubmissionCountOutputType
   */

  export type FormSubmissionCountOutputType = {
    fieldAnswerList: number
  }

  export type FormSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fieldAnswerList?: boolean | FormSubmissionCountOutputTypeCountFieldAnswerListArgs
  }

  // Custom InputTypes
  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmissionCountOutputType
     */
    select?: FormSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeCountFieldAnswerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldAnswerWhereInput
  }


  /**
   * Count Type FieldCountOutputType
   */

  export type FieldCountOutputType = {
    formList: number
    fieldAnswerList: number
    fieldOptionList: number
  }

  export type FieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formList?: boolean | FieldCountOutputTypeCountFormListArgs
    fieldAnswerList?: boolean | FieldCountOutputTypeCountFieldAnswerListArgs
    fieldOptionList?: boolean | FieldCountOutputTypeCountFieldOptionListArgs
  }

  // Custom InputTypes
  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldCountOutputType
     */
    select?: FieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFormListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFieldAnswerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldAnswerWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFieldOptionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOptionWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    formEncounterList: number
    formSubmissionList: number
    obsList: number
    orderList: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formEncounterList?: boolean | EncounterCountOutputTypeCountFormEncounterListArgs
    formSubmissionList?: boolean | EncounterCountOutputTypeCountFormSubmissionListArgs
    obsList?: boolean | EncounterCountOutputTypeCountObsListArgs
    orderList?: boolean | EncounterCountOutputTypeCountOrderListArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountFormEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormEncounterWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountFormSubmissionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountObsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObsWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type EncounterTypeCountOutputType
   */

  export type EncounterTypeCountOutputType = {
    encounterList: number
  }

  export type EncounterTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterList?: boolean | EncounterTypeCountOutputTypeCountEncounterListArgs
  }

  // Custom InputTypes
  /**
   * EncounterTypeCountOutputType without action
   */
  export type EncounterTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterTypeCountOutputType
     */
    select?: EncounterTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterTypeCountOutputType without action
   */
  export type EncounterTypeCountOutputTypeCountEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type OrderFrequencyCountOutputType
   */

  export type OrderFrequencyCountOutputType = {
    orderList: number
  }

  export type OrderFrequencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderFrequencyCountOutputTypeCountOrderListArgs
  }

  // Custom InputTypes
  /**
   * OrderFrequencyCountOutputType without action
   */
  export type OrderFrequencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequencyCountOutputType
     */
    select?: OrderFrequencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderFrequencyCountOutputType without action
   */
  export type OrderFrequencyCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OrderRouteCountOutputType
   */

  export type OrderRouteCountOutputType = {
    orderList: number
  }

  export type OrderRouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderRouteCountOutputTypeCountOrderListArgs
  }

  // Custom InputTypes
  /**
   * OrderRouteCountOutputType without action
   */
  export type OrderRouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRouteCountOutputType
     */
    select?: OrderRouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderRouteCountOutputType without action
   */
  export type OrderRouteCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OrderTypeCountOutputType
   */

  export type OrderTypeCountOutputType = {
    orderList: number
  }

  export type OrderTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderTypeCountOutputTypeCountOrderListArgs
  }

  // Custom InputTypes
  /**
   * OrderTypeCountOutputType without action
   */
  export type OrderTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTypeCountOutputType
     */
    select?: OrderTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderTypeCountOutputType without action
   */
  export type OrderTypeCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OrderUnitCountOutputType
   */

  export type OrderUnitCountOutputType = {
    orderList: number
  }

  export type OrderUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderUnitCountOutputTypeCountOrderListArgs
  }

  // Custom InputTypes
  /**
   * OrderUnitCountOutputType without action
   */
  export type OrderUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnitCountOutputType
     */
    select?: OrderUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderUnitCountOutputType without action
   */
  export type OrderUnitCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type ConceptCountOutputType
   */

  export type ConceptCountOutputType = {
    metaList: number
    answerList: number
    fieldList: number
    obsList: number
    orderList: number
    conceptNameList: number
    conceptNumericList: number
    conceptProposalList: number
    conceptWordList: number
  }

  export type ConceptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaList?: boolean | ConceptCountOutputTypeCountMetaListArgs
    answerList?: boolean | ConceptCountOutputTypeCountAnswerListArgs
    fieldList?: boolean | ConceptCountOutputTypeCountFieldListArgs
    obsList?: boolean | ConceptCountOutputTypeCountObsListArgs
    orderList?: boolean | ConceptCountOutputTypeCountOrderListArgs
    conceptNameList?: boolean | ConceptCountOutputTypeCountConceptNameListArgs
    conceptNumericList?: boolean | ConceptCountOutputTypeCountConceptNumericListArgs
    conceptProposalList?: boolean | ConceptCountOutputTypeCountConceptProposalListArgs
    conceptWordList?: boolean | ConceptCountOutputTypeCountConceptWordListArgs
  }

  // Custom InputTypes
  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptCountOutputType
     */
    select?: ConceptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountMetaListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptAnswerWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountAnswerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptAnswerWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountFieldListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountObsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObsWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountConceptNameListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptNameWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountConceptNumericListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptNumericWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountConceptProposalListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptProposalWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountConceptWordListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWordWhereInput
  }


  /**
   * Count Type ConceptClassCountOutputType
   */

  export type ConceptClassCountOutputType = {
    conceptList: number
  }

  export type ConceptClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptClassCountOutputTypeCountConceptListArgs
  }

  // Custom InputTypes
  /**
   * ConceptClassCountOutputType without action
   */
  export type ConceptClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClassCountOutputType
     */
    select?: ConceptClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptClassCountOutputType without action
   */
  export type ConceptClassCountOutputTypeCountConceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
  }


  /**
   * Count Type ConceptDatatypeCountOutputType
   */

  export type ConceptDatatypeCountOutputType = {
    conceptList: number
  }

  export type ConceptDatatypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptDatatypeCountOutputTypeCountConceptListArgs
  }

  // Custom InputTypes
  /**
   * ConceptDatatypeCountOutputType without action
   */
  export type ConceptDatatypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatypeCountOutputType
     */
    select?: ConceptDatatypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptDatatypeCountOutputType without action
   */
  export type ConceptDatatypeCountOutputTypeCountConceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
  }


  /**
   * Count Type ConceptMapCountOutputType
   */

  export type ConceptMapCountOutputType = {
    conceptList: number
  }

  export type ConceptMapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptMapCountOutputTypeCountConceptListArgs
  }

  // Custom InputTypes
  /**
   * ConceptMapCountOutputType without action
   */
  export type ConceptMapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMapCountOutputType
     */
    select?: ConceptMapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptMapCountOutputType without action
   */
  export type ConceptMapCountOutputTypeCountConceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
  }


  /**
   * Count Type ConceptSetCountOutputType
   */

  export type ConceptSetCountOutputType = {
    conceptList: number
  }

  export type ConceptSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptSetCountOutputTypeCountConceptListArgs
  }

  // Custom InputTypes
  /**
   * ConceptSetCountOutputType without action
   */
  export type ConceptSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSetCountOutputType
     */
    select?: ConceptSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptSetCountOutputType without action
   */
  export type ConceptSetCountOutputTypeCountConceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
  }


  /**
   * Count Type ConceptSourceCountOutputType
   */

  export type ConceptSourceCountOutputType = {
    conceptList: number
  }

  export type ConceptSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptSourceCountOutputTypeCountConceptListArgs
  }

  // Custom InputTypes
  /**
   * ConceptSourceCountOutputType without action
   */
  export type ConceptSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSourceCountOutputType
     */
    select?: ConceptSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptSourceCountOutputType without action
   */
  export type ConceptSourceCountOutputTypeCountConceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    formResourceList: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formResourceList?: boolean | ResourceCountOutputTypeCountFormResourceListArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountFormResourceListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResourceWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    tagArrowList: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagArrowList?: boolean | BlogPostCountOutputTypeCountTagArrowListArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountTagArrowListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagArrowWhereInput
  }


  /**
   * Count Type BlogPostTagCountOutputType
   */

  export type BlogPostTagCountOutputType = {
    postArrowList: number
  }

  export type BlogPostTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postArrowList?: boolean | BlogPostTagCountOutputTypeCountPostArrowListArgs
  }

  // Custom InputTypes
  /**
   * BlogPostTagCountOutputType without action
   */
  export type BlogPostTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagCountOutputType
     */
    select?: BlogPostTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostTagCountOutputType without action
   */
  export type BlogPostTagCountOutputTypeCountPostArrowListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagArrowWhereInput
  }


  /**
   * Count Type BlogPostAuthorCountOutputType
   */

  export type BlogPostAuthorCountOutputType = {
    blogPostList: number
  }

  export type BlogPostAuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPostList?: boolean | BlogPostAuthorCountOutputTypeCountBlogPostListArgs
  }

  // Custom InputTypes
  /**
   * BlogPostAuthorCountOutputType without action
   */
  export type BlogPostAuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthorCountOutputType
     */
    select?: BlogPostAuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostAuthorCountOutputType without action
   */
  export type BlogPostAuthorCountOutputTypeCountBlogPostListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    entryList: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entryList?: boolean | ServiceCountOutputTypeCountEntryListArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEntryListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetEntryWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    entryList: number
    userList: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entryList?: boolean | BudgetCountOutputTypeCountEntryListArgs
    userList?: boolean | BudgetCountOutputTypeCountUserListArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountEntryListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetEntryWhereInput
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountUserListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetBudUserWhereInput
  }


  /**
   * Count Type BudUserCountOutputType
   */

  export type BudUserCountOutputType = {
    budgetList: number
    eventList: number
  }

  export type BudUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetList?: boolean | BudUserCountOutputTypeCountBudgetListArgs
    eventList?: boolean | BudUserCountOutputTypeCountEventListArgs
  }

  // Custom InputTypes
  /**
   * BudUserCountOutputType without action
   */
  export type BudUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUserCountOutputType
     */
    select?: BudUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudUserCountOutputType without action
   */
  export type BudUserCountOutputTypeCountBudgetListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetBudUserWhereInput
  }

  /**
   * BudUserCountOutputType without action
   */
  export type BudUserCountOutputTypeCountEventListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    appointmentTypeId: string | null
    patientId: string | null
    locationId: string | null
    providerId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    appointmentTypeId: string | null
    patientId: string | null
    locationId: string | null
    providerId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    uuid: number
    appointmentTypeId: number
    patientId: number
    locationId: number
    providerId: number
    startDatetime: number
    endDatetime: number
    voided: number
    voidedBy: number
    dateVoided: number
    voidReason: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    uuid?: true
    appointmentTypeId?: true
    patientId?: true
    locationId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    uuid?: true
    appointmentTypeId?: true
    patientId?: true
    locationId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    uuid?: true
    appointmentTypeId?: true
    patientId?: true
    locationId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date
    endDatetime: Date
    voided: boolean
    voidedBy: string
    dateVoided: Date
    voidReason: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    appointmentTypeId?: boolean
    patientId?: boolean
    locationId?: boolean
    providerId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    appointmentType?: boolean | AppointmentTypeDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    uuid?: boolean
    appointmentTypeId?: boolean
    patientId?: boolean
    locationId?: boolean
    providerId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentType?: boolean | AppointmentTypeDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }


  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      appointmentType: Prisma.$AppointmentTypePayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      appointmentTypeId: string
      patientId: string
      locationId: string
      providerId: string
      startDatetime: Date
      endDatetime: Date
      voided: boolean
      voidedBy: string
      dateVoided: Date
      voidReason: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }


  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppointmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
    **/
    create<T extends AppointmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Appointments.
     *     @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     *     @example
     *     // Create many Appointments
     *     const appointment = await prisma.appointment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointmentType<T extends AppointmentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentTypeDefaultArgs<ExtArgs>>): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly uuid: FieldRef<"Appointment", 'String'>
    readonly appointmentTypeId: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly locationId: FieldRef<"Appointment", 'String'>
    readonly providerId: FieldRef<"Appointment", 'String'>
    readonly startDatetime: FieldRef<"Appointment", 'DateTime'>
    readonly endDatetime: FieldRef<"Appointment", 'DateTime'>
    readonly voided: FieldRef<"Appointment", 'Boolean'>
    readonly voidedBy: FieldRef<"Appointment", 'String'>
    readonly dateVoided: FieldRef<"Appointment", 'DateTime'>
    readonly voidReason: FieldRef<"Appointment", 'String'>
    readonly creator: FieldRef<"Appointment", 'String'>
    readonly dateCreated: FieldRef<"Appointment", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Appointment", 'String'>
    readonly lastChangedDate: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model AppointmentType
   */

  export type AggregateAppointmentType = {
    _count: AppointmentTypeCountAggregateOutputType | null
    _avg: AppointmentTypeAvgAggregateOutputType | null
    _sum: AppointmentTypeSumAggregateOutputType | null
    _min: AppointmentTypeMinAggregateOutputType | null
    _max: AppointmentTypeMaxAggregateOutputType | null
  }

  export type AppointmentTypeAvgAggregateOutputType = {
    duration: number | null
  }

  export type AppointmentTypeSumAggregateOutputType = {
    duration: number | null
  }

  export type AppointmentTypeMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    duration: number | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type AppointmentTypeMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    duration: number | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type AppointmentTypeCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    duration: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type AppointmentTypeAvgAggregateInputType = {
    duration?: true
  }

  export type AppointmentTypeSumAggregateInputType = {
    duration?: true
  }

  export type AppointmentTypeMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    duration?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type AppointmentTypeMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    duration?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type AppointmentTypeCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    duration?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type AppointmentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentType to aggregate.
     */
    where?: AppointmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentTypes to fetch.
     */
    orderBy?: AppointmentTypeOrderByWithRelationInput | AppointmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppointmentTypes
    **/
    _count?: true | AppointmentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentTypeMaxAggregateInputType
  }

  export type GetAppointmentTypeAggregateType<T extends AppointmentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointmentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointmentType[P]>
      : GetScalarType<T[P], AggregateAppointmentType[P]>
  }




  export type AppointmentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentTypeWhereInput
    orderBy?: AppointmentTypeOrderByWithAggregationInput | AppointmentTypeOrderByWithAggregationInput[]
    by: AppointmentTypeScalarFieldEnum[] | AppointmentTypeScalarFieldEnum
    having?: AppointmentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentTypeCountAggregateInputType | true
    _avg?: AppointmentTypeAvgAggregateInputType
    _sum?: AppointmentTypeSumAggregateInputType
    _min?: AppointmentTypeMinAggregateInputType
    _max?: AppointmentTypeMaxAggregateInputType
  }

  export type AppointmentTypeGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: AppointmentTypeCountAggregateOutputType | null
    _avg: AppointmentTypeAvgAggregateOutputType | null
    _sum: AppointmentTypeSumAggregateOutputType | null
    _min: AppointmentTypeMinAggregateOutputType | null
    _max: AppointmentTypeMaxAggregateOutputType | null
  }

  type GetAppointmentTypeGroupByPayload<T extends AppointmentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentTypeGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    appointmentList?: boolean | AppointmentType$appointmentListArgs<ExtArgs>
    _count?: boolean | AppointmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentType"]>

  export type AppointmentTypeSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type AppointmentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | AppointmentType$appointmentListArgs<ExtArgs>
    _count?: boolean | AppointmentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AppointmentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppointmentType"
    objects: {
      appointmentList: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      duration: number
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["appointmentType"]>
    composites: {}
  }


  type AppointmentTypeGetPayload<S extends boolean | null | undefined | AppointmentTypeDefaultArgs> = $Result.GetResult<Prisma.$AppointmentTypePayload, S>

  type AppointmentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentTypeCountAggregateInputType | true
    }

  export interface AppointmentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppointmentType'], meta: { name: 'AppointmentType' } }
    /**
     * Find zero or one AppointmentType that matches the filter.
     * @param {AppointmentTypeFindUniqueArgs} args - Arguments to find a AppointmentType
     * @example
     * // Get one AppointmentType
     * const appointmentType = await prisma.appointmentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AppointmentType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppointmentTypeFindUniqueOrThrowArgs} args - Arguments to find a AppointmentType
     * @example
     * // Get one AppointmentType
     * const appointmentType = await prisma.appointmentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppointmentTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AppointmentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeFindFirstArgs} args - Arguments to find a AppointmentType
     * @example
     * // Get one AppointmentType
     * const appointmentType = await prisma.appointmentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeFindFirstArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AppointmentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeFindFirstOrThrowArgs} args - Arguments to find a AppointmentType
     * @example
     * // Get one AppointmentType
     * const appointmentType = await prisma.appointmentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppointmentTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AppointmentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppointmentTypes
     * const appointmentTypes = await prisma.appointmentType.findMany()
     * 
     * // Get first 10 AppointmentTypes
     * const appointmentTypes = await prisma.appointmentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentTypeWithIdOnly = await prisma.appointmentType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppointmentTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AppointmentType.
     * @param {AppointmentTypeCreateArgs} args - Arguments to create a AppointmentType.
     * @example
     * // Create one AppointmentType
     * const AppointmentType = await prisma.appointmentType.create({
     *   data: {
     *     // ... data to create a AppointmentType
     *   }
     * })
     * 
    **/
    create<T extends AppointmentTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeCreateArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AppointmentTypes.
     *     @param {AppointmentTypeCreateManyArgs} args - Arguments to create many AppointmentTypes.
     *     @example
     *     // Create many AppointmentTypes
     *     const appointmentType = await prisma.appointmentType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppointmentType.
     * @param {AppointmentTypeDeleteArgs} args - Arguments to delete one AppointmentType.
     * @example
     * // Delete one AppointmentType
     * const AppointmentType = await prisma.appointmentType.delete({
     *   where: {
     *     // ... filter to delete one AppointmentType
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeDeleteArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AppointmentType.
     * @param {AppointmentTypeUpdateArgs} args - Arguments to update one AppointmentType.
     * @example
     * // Update one AppointmentType
     * const appointmentType = await prisma.appointmentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeUpdateArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AppointmentTypes.
     * @param {AppointmentTypeDeleteManyArgs} args - Arguments to filter AppointmentTypes to delete.
     * @example
     * // Delete a few AppointmentTypes
     * const { count } = await prisma.appointmentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppointmentTypes
     * const appointmentType = await prisma.appointmentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppointmentType.
     * @param {AppointmentTypeUpsertArgs} args - Arguments to update or create a AppointmentType.
     * @example
     * // Update or create a AppointmentType
     * const appointmentType = await prisma.appointmentType.upsert({
     *   create: {
     *     // ... data to create a AppointmentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppointmentType we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentTypeUpsertArgs<ExtArgs>>
    ): Prisma__AppointmentTypeClient<$Result.GetResult<Prisma.$AppointmentTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AppointmentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeCountArgs} args - Arguments to filter AppointmentTypes to count.
     * @example
     * // Count the number of AppointmentTypes
     * const count = await prisma.appointmentType.count({
     *   where: {
     *     // ... the filter for the AppointmentTypes we want to count
     *   }
     * })
    **/
    count<T extends AppointmentTypeCountArgs>(
      args?: Subset<T, AppointmentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppointmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentTypeAggregateArgs>(args: Subset<T, AppointmentTypeAggregateArgs>): Prisma.PrismaPromise<GetAppointmentTypeAggregateType<T>>

    /**
     * Group by AppointmentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentTypeGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppointmentType model
   */
  readonly fields: AppointmentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppointmentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointmentList<T extends AppointmentType$appointmentListArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentType$appointmentListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AppointmentType model
   */ 
  interface AppointmentTypeFieldRefs {
    readonly id: FieldRef<"AppointmentType", 'String'>
    readonly uuid: FieldRef<"AppointmentType", 'String'>
    readonly name: FieldRef<"AppointmentType", 'String'>
    readonly description: FieldRef<"AppointmentType", 'String'>
    readonly duration: FieldRef<"AppointmentType", 'Int'>
    readonly creator: FieldRef<"AppointmentType", 'String'>
    readonly dateCreated: FieldRef<"AppointmentType", 'DateTime'>
    readonly lastChangedBy: FieldRef<"AppointmentType", 'String'>
    readonly lastChangedDate: FieldRef<"AppointmentType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppointmentType findUnique
   */
  export type AppointmentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentType to fetch.
     */
    where: AppointmentTypeWhereUniqueInput
  }

  /**
   * AppointmentType findUniqueOrThrow
   */
  export type AppointmentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentType to fetch.
     */
    where: AppointmentTypeWhereUniqueInput
  }

  /**
   * AppointmentType findFirst
   */
  export type AppointmentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentType to fetch.
     */
    where?: AppointmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentTypes to fetch.
     */
    orderBy?: AppointmentTypeOrderByWithRelationInput | AppointmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentTypes.
     */
    cursor?: AppointmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentTypes.
     */
    distinct?: AppointmentTypeScalarFieldEnum | AppointmentTypeScalarFieldEnum[]
  }

  /**
   * AppointmentType findFirstOrThrow
   */
  export type AppointmentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentType to fetch.
     */
    where?: AppointmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentTypes to fetch.
     */
    orderBy?: AppointmentTypeOrderByWithRelationInput | AppointmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentTypes.
     */
    cursor?: AppointmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentTypes.
     */
    distinct?: AppointmentTypeScalarFieldEnum | AppointmentTypeScalarFieldEnum[]
  }

  /**
   * AppointmentType findMany
   */
  export type AppointmentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentTypes to fetch.
     */
    where?: AppointmentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentTypes to fetch.
     */
    orderBy?: AppointmentTypeOrderByWithRelationInput | AppointmentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppointmentTypes.
     */
    cursor?: AppointmentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentTypes.
     */
    skip?: number
    distinct?: AppointmentTypeScalarFieldEnum | AppointmentTypeScalarFieldEnum[]
  }

  /**
   * AppointmentType create
   */
  export type AppointmentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AppointmentType.
     */
    data: XOR<AppointmentTypeCreateInput, AppointmentTypeUncheckedCreateInput>
  }

  /**
   * AppointmentType createMany
   */
  export type AppointmentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppointmentTypes.
     */
    data: AppointmentTypeCreateManyInput | AppointmentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppointmentType update
   */
  export type AppointmentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AppointmentType.
     */
    data: XOR<AppointmentTypeUpdateInput, AppointmentTypeUncheckedUpdateInput>
    /**
     * Choose, which AppointmentType to update.
     */
    where: AppointmentTypeWhereUniqueInput
  }

  /**
   * AppointmentType updateMany
   */
  export type AppointmentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppointmentTypes.
     */
    data: XOR<AppointmentTypeUpdateManyMutationInput, AppointmentTypeUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentTypes to update
     */
    where?: AppointmentTypeWhereInput
  }

  /**
   * AppointmentType upsert
   */
  export type AppointmentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AppointmentType to update in case it exists.
     */
    where: AppointmentTypeWhereUniqueInput
    /**
     * In case the AppointmentType found by the `where` argument doesn't exist, create a new AppointmentType with this data.
     */
    create: XOR<AppointmentTypeCreateInput, AppointmentTypeUncheckedCreateInput>
    /**
     * In case the AppointmentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentTypeUpdateInput, AppointmentTypeUncheckedUpdateInput>
  }

  /**
   * AppointmentType delete
   */
  export type AppointmentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
    /**
     * Filter which AppointmentType to delete.
     */
    where: AppointmentTypeWhereUniqueInput
  }

  /**
   * AppointmentType deleteMany
   */
  export type AppointmentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentTypes to delete
     */
    where?: AppointmentTypeWhereInput
  }

  /**
   * AppointmentType.appointmentList
   */
  export type AppointmentType$appointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * AppointmentType without action
   */
  export type AppointmentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentType
     */
    select?: AppointmentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentTypeInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    address1: string | null
    address2: string | null
    city: string | null
    stateProvince: string | null
    country: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    address1: string | null
    address2: string | null
    city: string | null
    stateProvince: string | null
    country: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    address1: number
    address2: number
    city: number
    stateProvince: number
    country: number
    postalCode: number
    latitude: number
    longitude: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    address1?: true
    address2?: true
    city?: true
    stateProvince?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    address1?: true
    address2?: true
    city?: true
    stateProvince?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    address1?: true
    address2?: true
    city?: true
    stateProvince?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    stateProvince?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    appointmentList?: boolean | Location$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Location$encounterListArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    stateProvince?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | Location$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Location$encounterListArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      appointmentList: Prisma.$AppointmentPayload<ExtArgs>[]
      encounterList: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      address1: string
      address2: string
      city: string
      stateProvince: string
      country: string
      postalCode: string
      latitude: number
      longitude: number
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }


  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends LocationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationCreateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Locations.
     *     @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends LocationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends LocationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointmentList<T extends Location$appointmentListArgs<ExtArgs> = {}>(args?: Subset<T, Location$appointmentListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    encounterList<T extends Location$encounterListArgs<ExtArgs> = {}>(args?: Subset<T, Location$encounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly uuid: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly address1: FieldRef<"Location", 'String'>
    readonly address2: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly stateProvince: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly postalCode: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly creator: FieldRef<"Location", 'String'>
    readonly dateCreated: FieldRef<"Location", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Location", 'String'>
    readonly lastChangedDate: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.appointmentList
   */
  export type Location$appointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Location.encounterList
   */
  export type Location$encounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    givenName: string | null
    middleName: string | null
    familyName: string | null
    gender: string | null
    birthdate: Date | null
    dead: boolean | null
    deathDate: Date | null
    causeOfDeath: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    givenName: string | null
    middleName: string | null
    familyName: string | null
    gender: string | null
    birthdate: Date | null
    dead: boolean | null
    deathDate: Date | null
    causeOfDeath: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    uuid: number
    givenName: number
    middleName: number
    familyName: number
    gender: number
    birthdate: number
    dead: number
    deathDate: number
    causeOfDeath: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    uuid?: true
    givenName?: true
    middleName?: true
    familyName?: true
    gender?: true
    birthdate?: true
    dead?: true
    deathDate?: true
    causeOfDeath?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    uuid?: true
    givenName?: true
    middleName?: true
    familyName?: true
    gender?: true
    birthdate?: true
    dead?: true
    deathDate?: true
    causeOfDeath?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    uuid?: true
    givenName?: true
    middleName?: true
    familyName?: true
    gender?: true
    birthdate?: true
    dead?: true
    deathDate?: true
    causeOfDeath?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date
    dead: boolean
    deathDate: Date
    causeOfDeath: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    givenName?: boolean
    middleName?: boolean
    familyName?: boolean
    gender?: boolean
    birthdate?: boolean
    dead?: boolean
    deathDate?: boolean
    causeOfDeath?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    appointmentList?: boolean | Patient$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Patient$encounterListArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    uuid?: boolean
    givenName?: boolean
    middleName?: boolean
    familyName?: boolean
    gender?: boolean
    birthdate?: boolean
    dead?: boolean
    deathDate?: boolean
    causeOfDeath?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | Patient$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Patient$encounterListArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      appointmentList: Prisma.$AppointmentPayload<ExtArgs>[]
      encounterList: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      givenName: string
      middleName: string
      familyName: string
      gender: string
      birthdate: Date
      dead: boolean
      deathDate: Date
      causeOfDeath: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Patients.
     *     @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     *     @example
     *     // Create many Patients
     *     const patient = await prisma.patient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointmentList<T extends Patient$appointmentListArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    encounterList<T extends Patient$encounterListArgs<ExtArgs> = {}>(args?: Subset<T, Patient$encounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly uuid: FieldRef<"Patient", 'String'>
    readonly givenName: FieldRef<"Patient", 'String'>
    readonly middleName: FieldRef<"Patient", 'String'>
    readonly familyName: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly birthdate: FieldRef<"Patient", 'DateTime'>
    readonly dead: FieldRef<"Patient", 'Boolean'>
    readonly deathDate: FieldRef<"Patient", 'DateTime'>
    readonly causeOfDeath: FieldRef<"Patient", 'String'>
    readonly creator: FieldRef<"Patient", 'String'>
    readonly dateCreated: FieldRef<"Patient", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Patient", 'String'>
    readonly lastChangedDate: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.appointmentList
   */
  export type Patient$appointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.encounterList
   */
  export type Patient$encounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    identifier: string | null
    description: string | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    identifier: string | null
    description: string | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    identifier: number
    description: number
    voided: number
    voidedBy: number
    dateVoided: number
    voidReason: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    identifier?: true
    description?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    identifier?: true
    description?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    identifier?: true
    description?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided: boolean
    voidedBy: string
    dateVoided: Date
    voidReason: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    appointmentList?: boolean | Provider$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Provider$encounterListArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointmentList?: boolean | Provider$appointmentListArgs<ExtArgs>
    encounterList?: boolean | Provider$encounterListArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      appointmentList: Prisma.$AppointmentPayload<ExtArgs>[]
      encounterList: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      identifier: string
      description: string
      voided: boolean
      voidedBy: string
      dateVoided: Date
      voidReason: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }


  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Provider that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProviderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
    **/
    create<T extends ProviderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Providers.
     *     @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const provider = await prisma.provider.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
    **/
    delete<T extends ProviderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    appointmentList<T extends Provider$appointmentListArgs<ExtArgs> = {}>(args?: Subset<T, Provider$appointmentListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    encounterList<T extends Provider$encounterListArgs<ExtArgs> = {}>(args?: Subset<T, Provider$encounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Provider model
   */ 
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly uuid: FieldRef<"Provider", 'String'>
    readonly name: FieldRef<"Provider", 'String'>
    readonly identifier: FieldRef<"Provider", 'String'>
    readonly description: FieldRef<"Provider", 'String'>
    readonly voided: FieldRef<"Provider", 'Boolean'>
    readonly voidedBy: FieldRef<"Provider", 'String'>
    readonly dateVoided: FieldRef<"Provider", 'DateTime'>
    readonly voidReason: FieldRef<"Provider", 'String'>
    readonly creator: FieldRef<"Provider", 'String'>
    readonly dateCreated: FieldRef<"Provider", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Provider", 'String'>
    readonly lastChangedDate: FieldRef<"Provider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
  }

  /**
   * Provider.appointmentList
   */
  export type Provider$appointmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Provider.encounterList
   */
  export type Provider$encounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    version: string | null
    retired: boolean | null
    retiredBy: string | null
    dateRetired: Date | null
    retiredReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    fieldId: string | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    version: string | null
    retired: boolean | null
    retiredBy: string | null
    dateRetired: Date | null
    retiredReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    fieldId: string | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    version: number
    retired: number
    retiredBy: number
    dateRetired: number
    retiredReason: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    fieldId: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    version?: true
    retired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    fieldId?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    version?: true
    retired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    fieldId?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    version?: true
    retired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    fieldId?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    version: string
    retired: boolean
    retiredBy: string
    dateRetired: Date
    retiredReason: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    fieldId: string | null
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    retired?: boolean
    retiredBy?: boolean
    dateRetired?: boolean
    retiredReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    fieldId?: boolean
    formEncounterList?: boolean | Form$formEncounterListArgs<ExtArgs>
    formResourceList?: boolean | Form$formResourceListArgs<ExtArgs>
    formSubmissionList?: boolean | Form$formSubmissionListArgs<ExtArgs>
    dield?: boolean | Form$dieldArgs<ExtArgs>
    encounterList?: boolean | Form$encounterListArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    retired?: boolean
    retiredBy?: boolean
    dateRetired?: boolean
    retiredReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    fieldId?: boolean
  }


  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formEncounterList?: boolean | Form$formEncounterListArgs<ExtArgs>
    formResourceList?: boolean | Form$formResourceListArgs<ExtArgs>
    formSubmissionList?: boolean | Form$formSubmissionListArgs<ExtArgs>
    dield?: boolean | Form$dieldArgs<ExtArgs>
    encounterList?: boolean | Form$encounterListArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      formEncounterList: Prisma.$FormEncounterPayload<ExtArgs>[]
      formResourceList: Prisma.$FormResourcePayload<ExtArgs>[]
      formSubmissionList: Prisma.$FormSubmissionPayload<ExtArgs>[]
      dield: Prisma.$FieldPayload<ExtArgs> | null
      encounterList: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      version: string
      retired: boolean
      retiredBy: string
      dateRetired: Date
      retiredReason: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
      fieldId: string | null
    }, ExtArgs["result"]["form"]>
    composites: {}
  }


  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Form that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
    **/
    create<T extends FormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormCreateArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Forms.
     *     @param {FormCreateManyArgs} args - Arguments to create many Forms.
     *     @example
     *     // Create many Forms
     *     const form = await prisma.form.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
    **/
    delete<T extends FormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormDeleteArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpdateArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
    **/
    upsert<T extends FormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpsertArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    formEncounterList<T extends Form$formEncounterListArgs<ExtArgs> = {}>(args?: Subset<T, Form$formEncounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    formResourceList<T extends Form$formResourceListArgs<ExtArgs> = {}>(args?: Subset<T, Form$formResourceListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findMany'> | Null>;

    formSubmissionList<T extends Form$formSubmissionListArgs<ExtArgs> = {}>(args?: Subset<T, Form$formSubmissionListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    dield<T extends Form$dieldArgs<ExtArgs> = {}>(args?: Subset<T, Form$dieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    encounterList<T extends Form$encounterListArgs<ExtArgs> = {}>(args?: Subset<T, Form$encounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Form model
   */ 
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly uuid: FieldRef<"Form", 'String'>
    readonly name: FieldRef<"Form", 'String'>
    readonly description: FieldRef<"Form", 'String'>
    readonly version: FieldRef<"Form", 'String'>
    readonly retired: FieldRef<"Form", 'Boolean'>
    readonly retiredBy: FieldRef<"Form", 'String'>
    readonly dateRetired: FieldRef<"Form", 'DateTime'>
    readonly retiredReason: FieldRef<"Form", 'String'>
    readonly creator: FieldRef<"Form", 'String'>
    readonly dateCreated: FieldRef<"Form", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Form", 'String'>
    readonly lastChangedDate: FieldRef<"Form", 'DateTime'>
    readonly fieldId: FieldRef<"Form", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
  }

  /**
   * Form.formEncounterList
   */
  export type Form$formEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    where?: FormEncounterWhereInput
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    cursor?: FormEncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormEncounterScalarFieldEnum | FormEncounterScalarFieldEnum[]
  }

  /**
   * Form.formResourceList
   */
  export type Form$formResourceListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    where?: FormResourceWhereInput
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    cursor?: FormResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResourceScalarFieldEnum | FormResourceScalarFieldEnum[]
  }

  /**
   * Form.formSubmissionList
   */
  export type Form$formSubmissionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Form.dield
   */
  export type Form$dieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Form.encounterList
   */
  export type Form$encounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model FormEncounter
   */

  export type AggregateFormEncounter = {
    _count: FormEncounterCountAggregateOutputType | null
    _min: FormEncounterMinAggregateOutputType | null
    _max: FormEncounterMaxAggregateOutputType | null
  }

  export type FormEncounterMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    encounterId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormEncounterMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    encounterId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormEncounterCountAggregateOutputType = {
    id: number
    uuid: number
    formId: number
    encounterId: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FormEncounterMinAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormEncounterMaxAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormEncounterCountAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FormEncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormEncounter to aggregate.
     */
    where?: FormEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormEncounters to fetch.
     */
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormEncounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormEncounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormEncounters
    **/
    _count?: true | FormEncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormEncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormEncounterMaxAggregateInputType
  }

  export type GetFormEncounterAggregateType<T extends FormEncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateFormEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormEncounter[P]>
      : GetScalarType<T[P], AggregateFormEncounter[P]>
  }




  export type FormEncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormEncounterWhereInput
    orderBy?: FormEncounterOrderByWithAggregationInput | FormEncounterOrderByWithAggregationInput[]
    by: FormEncounterScalarFieldEnum[] | FormEncounterScalarFieldEnum
    having?: FormEncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormEncounterCountAggregateInputType | true
    _min?: FormEncounterMinAggregateInputType
    _max?: FormEncounterMaxAggregateInputType
  }

  export type FormEncounterGroupByOutputType = {
    id: string
    uuid: string
    formId: string
    encounterId: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FormEncounterCountAggregateOutputType | null
    _min: FormEncounterMinAggregateOutputType | null
    _max: FormEncounterMaxAggregateOutputType | null
  }

  type GetFormEncounterGroupByPayload<T extends FormEncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormEncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormEncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormEncounterGroupByOutputType[P]>
            : GetScalarType<T[P], FormEncounterGroupByOutputType[P]>
        }
      >
    >


  export type FormEncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    formId?: boolean
    encounterId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formEncounter"]>

  export type FormEncounterSelectScalar = {
    id?: boolean
    uuid?: boolean
    formId?: boolean
    encounterId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FormEncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }


  export type $FormEncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormEncounter"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      formId: string
      encounterId: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["formEncounter"]>
    composites: {}
  }


  type FormEncounterGetPayload<S extends boolean | null | undefined | FormEncounterDefaultArgs> = $Result.GetResult<Prisma.$FormEncounterPayload, S>

  type FormEncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormEncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormEncounterCountAggregateInputType | true
    }

  export interface FormEncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormEncounter'], meta: { name: 'FormEncounter' } }
    /**
     * Find zero or one FormEncounter that matches the filter.
     * @param {FormEncounterFindUniqueArgs} args - Arguments to find a FormEncounter
     * @example
     * // Get one FormEncounter
     * const formEncounter = await prisma.formEncounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormEncounterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterFindUniqueArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormEncounter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormEncounterFindUniqueOrThrowArgs} args - Arguments to find a FormEncounter
     * @example
     * // Get one FormEncounter
     * const formEncounter = await prisma.formEncounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormEncounterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormEncounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterFindFirstArgs} args - Arguments to find a FormEncounter
     * @example
     * // Get one FormEncounter
     * const formEncounter = await prisma.formEncounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormEncounterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterFindFirstArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormEncounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterFindFirstOrThrowArgs} args - Arguments to find a FormEncounter
     * @example
     * // Get one FormEncounter
     * const formEncounter = await prisma.formEncounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormEncounterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormEncounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormEncounters
     * const formEncounters = await prisma.formEncounter.findMany()
     * 
     * // Get first 10 FormEncounters
     * const formEncounters = await prisma.formEncounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formEncounterWithIdOnly = await prisma.formEncounter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormEncounterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormEncounter.
     * @param {FormEncounterCreateArgs} args - Arguments to create a FormEncounter.
     * @example
     * // Create one FormEncounter
     * const FormEncounter = await prisma.formEncounter.create({
     *   data: {
     *     // ... data to create a FormEncounter
     *   }
     * })
     * 
    **/
    create<T extends FormEncounterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterCreateArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormEncounters.
     *     @param {FormEncounterCreateManyArgs} args - Arguments to create many FormEncounters.
     *     @example
     *     // Create many FormEncounters
     *     const formEncounter = await prisma.formEncounter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormEncounterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormEncounter.
     * @param {FormEncounterDeleteArgs} args - Arguments to delete one FormEncounter.
     * @example
     * // Delete one FormEncounter
     * const FormEncounter = await prisma.formEncounter.delete({
     *   where: {
     *     // ... filter to delete one FormEncounter
     *   }
     * })
     * 
    **/
    delete<T extends FormEncounterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterDeleteArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormEncounter.
     * @param {FormEncounterUpdateArgs} args - Arguments to update one FormEncounter.
     * @example
     * // Update one FormEncounter
     * const formEncounter = await prisma.formEncounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormEncounterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterUpdateArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormEncounters.
     * @param {FormEncounterDeleteManyArgs} args - Arguments to filter FormEncounters to delete.
     * @example
     * // Delete a few FormEncounters
     * const { count } = await prisma.formEncounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormEncounterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormEncounterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormEncounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormEncounters
     * const formEncounter = await prisma.formEncounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormEncounterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormEncounter.
     * @param {FormEncounterUpsertArgs} args - Arguments to update or create a FormEncounter.
     * @example
     * // Update or create a FormEncounter
     * const formEncounter = await prisma.formEncounter.upsert({
     *   create: {
     *     // ... data to create a FormEncounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormEncounter we want to update
     *   }
     * })
    **/
    upsert<T extends FormEncounterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormEncounterUpsertArgs<ExtArgs>>
    ): Prisma__FormEncounterClient<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormEncounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterCountArgs} args - Arguments to filter FormEncounters to count.
     * @example
     * // Count the number of FormEncounters
     * const count = await prisma.formEncounter.count({
     *   where: {
     *     // ... the filter for the FormEncounters we want to count
     *   }
     * })
    **/
    count<T extends FormEncounterCountArgs>(
      args?: Subset<T, FormEncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormEncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormEncounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormEncounterAggregateArgs>(args: Subset<T, FormEncounterAggregateArgs>): Prisma.PrismaPromise<GetFormEncounterAggregateType<T>>

    /**
     * Group by FormEncounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormEncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormEncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormEncounterGroupByArgs['orderBy'] }
        : { orderBy?: FormEncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormEncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormEncounter model
   */
  readonly fields: FormEncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormEncounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormEncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormEncounter model
   */ 
  interface FormEncounterFieldRefs {
    readonly id: FieldRef<"FormEncounter", 'String'>
    readonly uuid: FieldRef<"FormEncounter", 'String'>
    readonly formId: FieldRef<"FormEncounter", 'String'>
    readonly encounterId: FieldRef<"FormEncounter", 'String'>
    readonly creator: FieldRef<"FormEncounter", 'String'>
    readonly dateCreated: FieldRef<"FormEncounter", 'DateTime'>
    readonly lastChangedBy: FieldRef<"FormEncounter", 'String'>
    readonly lastChangedDate: FieldRef<"FormEncounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormEncounter findUnique
   */
  export type FormEncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter, which FormEncounter to fetch.
     */
    where: FormEncounterWhereUniqueInput
  }

  /**
   * FormEncounter findUniqueOrThrow
   */
  export type FormEncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter, which FormEncounter to fetch.
     */
    where: FormEncounterWhereUniqueInput
  }

  /**
   * FormEncounter findFirst
   */
  export type FormEncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter, which FormEncounter to fetch.
     */
    where?: FormEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormEncounters to fetch.
     */
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormEncounters.
     */
    cursor?: FormEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormEncounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormEncounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormEncounters.
     */
    distinct?: FormEncounterScalarFieldEnum | FormEncounterScalarFieldEnum[]
  }

  /**
   * FormEncounter findFirstOrThrow
   */
  export type FormEncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter, which FormEncounter to fetch.
     */
    where?: FormEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormEncounters to fetch.
     */
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormEncounters.
     */
    cursor?: FormEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormEncounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormEncounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormEncounters.
     */
    distinct?: FormEncounterScalarFieldEnum | FormEncounterScalarFieldEnum[]
  }

  /**
   * FormEncounter findMany
   */
  export type FormEncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter, which FormEncounters to fetch.
     */
    where?: FormEncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormEncounters to fetch.
     */
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormEncounters.
     */
    cursor?: FormEncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormEncounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormEncounters.
     */
    skip?: number
    distinct?: FormEncounterScalarFieldEnum | FormEncounterScalarFieldEnum[]
  }

  /**
   * FormEncounter create
   */
  export type FormEncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a FormEncounter.
     */
    data: XOR<FormEncounterCreateInput, FormEncounterUncheckedCreateInput>
  }

  /**
   * FormEncounter createMany
   */
  export type FormEncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormEncounters.
     */
    data: FormEncounterCreateManyInput | FormEncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormEncounter update
   */
  export type FormEncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a FormEncounter.
     */
    data: XOR<FormEncounterUpdateInput, FormEncounterUncheckedUpdateInput>
    /**
     * Choose, which FormEncounter to update.
     */
    where: FormEncounterWhereUniqueInput
  }

  /**
   * FormEncounter updateMany
   */
  export type FormEncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormEncounters.
     */
    data: XOR<FormEncounterUpdateManyMutationInput, FormEncounterUncheckedUpdateManyInput>
    /**
     * Filter which FormEncounters to update
     */
    where?: FormEncounterWhereInput
  }

  /**
   * FormEncounter upsert
   */
  export type FormEncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the FormEncounter to update in case it exists.
     */
    where: FormEncounterWhereUniqueInput
    /**
     * In case the FormEncounter found by the `where` argument doesn't exist, create a new FormEncounter with this data.
     */
    create: XOR<FormEncounterCreateInput, FormEncounterUncheckedCreateInput>
    /**
     * In case the FormEncounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormEncounterUpdateInput, FormEncounterUncheckedUpdateInput>
  }

  /**
   * FormEncounter delete
   */
  export type FormEncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    /**
     * Filter which FormEncounter to delete.
     */
    where: FormEncounterWhereUniqueInput
  }

  /**
   * FormEncounter deleteMany
   */
  export type FormEncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormEncounters to delete
     */
    where?: FormEncounterWhereInput
  }

  /**
   * FormEncounter without action
   */
  export type FormEncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
  }


  /**
   * Model FormResource
   */

  export type AggregateFormResource = {
    _count: FormResourceCountAggregateOutputType | null
    _min: FormResourceMinAggregateOutputType | null
    _max: FormResourceMaxAggregateOutputType | null
  }

  export type FormResourceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    resourceId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormResourceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    resourceId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormResourceCountAggregateOutputType = {
    id: number
    uuid: number
    formId: number
    resourceId: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FormResourceMinAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    resourceId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormResourceMaxAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    resourceId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormResourceCountAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    resourceId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FormResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResource to aggregate.
     */
    where?: FormResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResources to fetch.
     */
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormResources
    **/
    _count?: true | FormResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormResourceMaxAggregateInputType
  }

  export type GetFormResourceAggregateType<T extends FormResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateFormResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormResource[P]>
      : GetScalarType<T[P], AggregateFormResource[P]>
  }




  export type FormResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResourceWhereInput
    orderBy?: FormResourceOrderByWithAggregationInput | FormResourceOrderByWithAggregationInput[]
    by: FormResourceScalarFieldEnum[] | FormResourceScalarFieldEnum
    having?: FormResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormResourceCountAggregateInputType | true
    _min?: FormResourceMinAggregateInputType
    _max?: FormResourceMaxAggregateInputType
  }

  export type FormResourceGroupByOutputType = {
    id: string
    uuid: string
    formId: string
    resourceId: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FormResourceCountAggregateOutputType | null
    _min: FormResourceMinAggregateOutputType | null
    _max: FormResourceMaxAggregateOutputType | null
  }

  type GetFormResourceGroupByPayload<T extends FormResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormResourceGroupByOutputType[P]>
            : GetScalarType<T[P], FormResourceGroupByOutputType[P]>
        }
      >
    >


  export type FormResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    formId?: boolean
    resourceId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResource"]>

  export type FormResourceSelectScalar = {
    id?: boolean
    uuid?: boolean
    formId?: boolean
    resourceId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FormResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }


  export type $FormResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormResource"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      formId: string
      resourceId: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["formResource"]>
    composites: {}
  }


  type FormResourceGetPayload<S extends boolean | null | undefined | FormResourceDefaultArgs> = $Result.GetResult<Prisma.$FormResourcePayload, S>

  type FormResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormResourceCountAggregateInputType | true
    }

  export interface FormResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormResource'], meta: { name: 'FormResource' } }
    /**
     * Find zero or one FormResource that matches the filter.
     * @param {FormResourceFindUniqueArgs} args - Arguments to find a FormResource
     * @example
     * // Get one FormResource
     * const formResource = await prisma.formResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormResourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceFindUniqueArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormResource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormResourceFindUniqueOrThrowArgs} args - Arguments to find a FormResource
     * @example
     * // Get one FormResource
     * const formResource = await prisma.formResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormResourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceFindFirstArgs} args - Arguments to find a FormResource
     * @example
     * // Get one FormResource
     * const formResource = await prisma.formResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormResourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceFindFirstArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceFindFirstOrThrowArgs} args - Arguments to find a FormResource
     * @example
     * // Get one FormResource
     * const formResource = await prisma.formResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormResourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormResources
     * const formResources = await prisma.formResource.findMany()
     * 
     * // Get first 10 FormResources
     * const formResources = await prisma.formResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formResourceWithIdOnly = await prisma.formResource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormResourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormResource.
     * @param {FormResourceCreateArgs} args - Arguments to create a FormResource.
     * @example
     * // Create one FormResource
     * const FormResource = await prisma.formResource.create({
     *   data: {
     *     // ... data to create a FormResource
     *   }
     * })
     * 
    **/
    create<T extends FormResourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceCreateArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormResources.
     *     @param {FormResourceCreateManyArgs} args - Arguments to create many FormResources.
     *     @example
     *     // Create many FormResources
     *     const formResource = await prisma.formResource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormResourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormResource.
     * @param {FormResourceDeleteArgs} args - Arguments to delete one FormResource.
     * @example
     * // Delete one FormResource
     * const FormResource = await prisma.formResource.delete({
     *   where: {
     *     // ... filter to delete one FormResource
     *   }
     * })
     * 
    **/
    delete<T extends FormResourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceDeleteArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormResource.
     * @param {FormResourceUpdateArgs} args - Arguments to update one FormResource.
     * @example
     * // Update one FormResource
     * const formResource = await prisma.formResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormResourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceUpdateArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormResources.
     * @param {FormResourceDeleteManyArgs} args - Arguments to filter FormResources to delete.
     * @example
     * // Delete a few FormResources
     * const { count } = await prisma.formResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormResourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormResources
     * const formResource = await prisma.formResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormResourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormResource.
     * @param {FormResourceUpsertArgs} args - Arguments to update or create a FormResource.
     * @example
     * // Update or create a FormResource
     * const formResource = await prisma.formResource.upsert({
     *   create: {
     *     // ... data to create a FormResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormResource we want to update
     *   }
     * })
    **/
    upsert<T extends FormResourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormResourceUpsertArgs<ExtArgs>>
    ): Prisma__FormResourceClient<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceCountArgs} args - Arguments to filter FormResources to count.
     * @example
     * // Count the number of FormResources
     * const count = await prisma.formResource.count({
     *   where: {
     *     // ... the filter for the FormResources we want to count
     *   }
     * })
    **/
    count<T extends FormResourceCountArgs>(
      args?: Subset<T, FormResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormResourceAggregateArgs>(args: Subset<T, FormResourceAggregateArgs>): Prisma.PrismaPromise<GetFormResourceAggregateType<T>>

    /**
     * Group by FormResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormResourceGroupByArgs['orderBy'] }
        : { orderBy?: FormResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormResource model
   */
  readonly fields: FormResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormResource model
   */ 
  interface FormResourceFieldRefs {
    readonly id: FieldRef<"FormResource", 'String'>
    readonly uuid: FieldRef<"FormResource", 'String'>
    readonly formId: FieldRef<"FormResource", 'String'>
    readonly resourceId: FieldRef<"FormResource", 'String'>
    readonly creator: FieldRef<"FormResource", 'String'>
    readonly dateCreated: FieldRef<"FormResource", 'DateTime'>
    readonly lastChangedBy: FieldRef<"FormResource", 'String'>
    readonly lastChangedDate: FieldRef<"FormResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormResource findUnique
   */
  export type FormResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter, which FormResource to fetch.
     */
    where: FormResourceWhereUniqueInput
  }

  /**
   * FormResource findUniqueOrThrow
   */
  export type FormResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter, which FormResource to fetch.
     */
    where: FormResourceWhereUniqueInput
  }

  /**
   * FormResource findFirst
   */
  export type FormResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter, which FormResource to fetch.
     */
    where?: FormResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResources to fetch.
     */
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResources.
     */
    cursor?: FormResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResources.
     */
    distinct?: FormResourceScalarFieldEnum | FormResourceScalarFieldEnum[]
  }

  /**
   * FormResource findFirstOrThrow
   */
  export type FormResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter, which FormResource to fetch.
     */
    where?: FormResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResources to fetch.
     */
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResources.
     */
    cursor?: FormResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResources.
     */
    distinct?: FormResourceScalarFieldEnum | FormResourceScalarFieldEnum[]
  }

  /**
   * FormResource findMany
   */
  export type FormResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter, which FormResources to fetch.
     */
    where?: FormResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResources to fetch.
     */
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormResources.
     */
    cursor?: FormResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResources.
     */
    skip?: number
    distinct?: FormResourceScalarFieldEnum | FormResourceScalarFieldEnum[]
  }

  /**
   * FormResource create
   */
  export type FormResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a FormResource.
     */
    data: XOR<FormResourceCreateInput, FormResourceUncheckedCreateInput>
  }

  /**
   * FormResource createMany
   */
  export type FormResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormResources.
     */
    data: FormResourceCreateManyInput | FormResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormResource update
   */
  export type FormResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a FormResource.
     */
    data: XOR<FormResourceUpdateInput, FormResourceUncheckedUpdateInput>
    /**
     * Choose, which FormResource to update.
     */
    where: FormResourceWhereUniqueInput
  }

  /**
   * FormResource updateMany
   */
  export type FormResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormResources.
     */
    data: XOR<FormResourceUpdateManyMutationInput, FormResourceUncheckedUpdateManyInput>
    /**
     * Filter which FormResources to update
     */
    where?: FormResourceWhereInput
  }

  /**
   * FormResource upsert
   */
  export type FormResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the FormResource to update in case it exists.
     */
    where: FormResourceWhereUniqueInput
    /**
     * In case the FormResource found by the `where` argument doesn't exist, create a new FormResource with this data.
     */
    create: XOR<FormResourceCreateInput, FormResourceUncheckedCreateInput>
    /**
     * In case the FormResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormResourceUpdateInput, FormResourceUncheckedUpdateInput>
  }

  /**
   * FormResource delete
   */
  export type FormResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    /**
     * Filter which FormResource to delete.
     */
    where: FormResourceWhereUniqueInput
  }

  /**
   * FormResource deleteMany
   */
  export type FormResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResources to delete
     */
    where?: FormResourceWhereInput
  }

  /**
   * FormResource without action
   */
  export type FormResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    encounterId: string | null
    submissionDate: Date | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    formId: string | null
    encounterId: string | null
    submissionDate: Date | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    uuid: number
    formId: number
    encounterId: number
    submissionDate: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    submissionDate?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    submissionDate?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    uuid?: true
    formId?: true
    encounterId?: true
    submissionDate?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    id: string
    uuid: string
    formId: string
    encounterId: string
    submissionDate: Date
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    formId?: boolean
    encounterId?: boolean
    submissionDate?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    fieldAnswerList?: boolean | FormSubmission$fieldAnswerListArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    uuid?: boolean
    formId?: boolean
    encounterId?: boolean
    submissionDate?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    fieldAnswerList?: boolean | FormSubmission$fieldAnswerListArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
      fieldAnswerList: Prisma.$FieldAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      formId: string
      encounterId: string
      submissionDate: Date
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }


  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSubmissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSubmissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSubmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
    **/
    create<T extends FormSubmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     *     @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     *     @example
     *     // Create many FormSubmissions
     *     const formSubmission = await prisma.formSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormSubmissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
    **/
    delete<T extends FormSubmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSubmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSubmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSubmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends FormSubmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    fieldAnswerList<T extends FormSubmission$fieldAnswerListArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmission$fieldAnswerListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormSubmission model
   */ 
  interface FormSubmissionFieldRefs {
    readonly id: FieldRef<"FormSubmission", 'String'>
    readonly uuid: FieldRef<"FormSubmission", 'String'>
    readonly formId: FieldRef<"FormSubmission", 'String'>
    readonly encounterId: FieldRef<"FormSubmission", 'String'>
    readonly submissionDate: FieldRef<"FormSubmission", 'DateTime'>
    readonly creator: FieldRef<"FormSubmission", 'String'>
    readonly dateCreated: FieldRef<"FormSubmission", 'DateTime'>
    readonly lastChangedBy: FieldRef<"FormSubmission", 'String'>
    readonly lastChangedDate: FieldRef<"FormSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }

  /**
   * FormSubmission.fieldAnswerList
   */
  export type FormSubmission$fieldAnswerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    where?: FieldAnswerWhereInput
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    cursor?: FieldAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldAnswerScalarFieldEnum | FieldAnswerScalarFieldEnum[]
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Field
   */

  export type AggregateField = {
    _count: FieldCountAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  export type FieldMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    fieldType: string | null
    conceptId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    fieldType: string | null
    conceptId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    fieldType: number
    conceptId: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FieldMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    fieldType?: true
    conceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    fieldType?: true
    conceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    fieldType?: true
    conceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Field to aggregate.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fields
    **/
    _count?: true | FieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends FieldAggregateArgs> = {
        [P in keyof T & keyof AggregateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateField[P]>
      : GetScalarType<T[P], AggregateField[P]>
  }




  export type FieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithAggregationInput | FieldOrderByWithAggregationInput[]
    by: FieldScalarFieldEnum[] | FieldScalarFieldEnum
    having?: FieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldCountAggregateInputType | true
    _min?: FieldMinAggregateInputType
    _max?: FieldMaxAggregateInputType
  }

  export type FieldGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FieldCountAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  type GetFieldGroupByPayload<T extends FieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldGroupByOutputType[P]>
            : GetScalarType<T[P], FieldGroupByOutputType[P]>
        }
      >
    >


  export type FieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    fieldType?: boolean
    conceptId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    formList?: boolean | Field$formListArgs<ExtArgs>
    fieldAnswerList?: boolean | Field$fieldAnswerListArgs<ExtArgs>
    fieldOptionList?: boolean | Field$fieldOptionListArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    fieldType?: boolean
    conceptId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    formList?: boolean | Field$formListArgs<ExtArgs>
    fieldAnswerList?: boolean | Field$fieldAnswerListArgs<ExtArgs>
    fieldOptionList?: boolean | Field$fieldOptionListArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Field"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
      formList: Prisma.$FormPayload<ExtArgs>[]
      fieldAnswerList: Prisma.$FieldAnswerPayload<ExtArgs>[]
      fieldOptionList: Prisma.$FieldOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      fieldType: string
      conceptId: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["field"]>
    composites: {}
  }


  type FieldGetPayload<S extends boolean | null | undefined | FieldDefaultArgs> = $Result.GetResult<Prisma.$FieldPayload, S>

  type FieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FieldCountAggregateInputType | true
    }

  export interface FieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Field'], meta: { name: 'Field' } }
    /**
     * Find zero or one Field that matches the filter.
     * @param {FieldFindUniqueArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FieldFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FieldFindUniqueArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Field that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FieldFindUniqueOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FieldFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FieldFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldFindFirstArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FieldFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FieldFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Field.
     * @param {FieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
    **/
    create<T extends FieldCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldCreateArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fields.
     *     @param {FieldCreateManyArgs} args - Arguments to create many Fields.
     *     @example
     *     // Create many Fields
     *     const field = await prisma.field.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FieldCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Field.
     * @param {FieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
    **/
    delete<T extends FieldDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FieldDeleteArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Field.
     * @param {FieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FieldUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldUpdateArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fields.
     * @param {FieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FieldDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FieldUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FieldUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Field.
     * @param {FieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
    **/
    upsert<T extends FieldUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FieldUpsertArgs<ExtArgs>>
    ): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.field.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends FieldCountArgs>(
      args?: Subset<T, FieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAggregateArgs>(args: Subset<T, FieldAggregateArgs>): Prisma.PrismaPromise<GetFieldAggregateType<T>>

    /**
     * Group by Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldGroupByArgs['orderBy'] }
        : { orderBy?: FieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Field model
   */
  readonly fields: FieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    formList<T extends Field$formListArgs<ExtArgs> = {}>(args?: Subset<T, Field$formListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findMany'> | Null>;

    fieldAnswerList<T extends Field$fieldAnswerListArgs<ExtArgs> = {}>(args?: Subset<T, Field$fieldAnswerListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findMany'> | Null>;

    fieldOptionList<T extends Field$fieldOptionListArgs<ExtArgs> = {}>(args?: Subset<T, Field$fieldOptionListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Field model
   */ 
  interface FieldFieldRefs {
    readonly id: FieldRef<"Field", 'String'>
    readonly uuid: FieldRef<"Field", 'String'>
    readonly name: FieldRef<"Field", 'String'>
    readonly description: FieldRef<"Field", 'String'>
    readonly fieldType: FieldRef<"Field", 'String'>
    readonly conceptId: FieldRef<"Field", 'String'>
    readonly creator: FieldRef<"Field", 'String'>
    readonly dateCreated: FieldRef<"Field", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Field", 'String'>
    readonly lastChangedDate: FieldRef<"Field", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Field findUnique
   */
  export type FieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findUniqueOrThrow
   */
  export type FieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findFirst
   */
  export type FieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findFirstOrThrow
   */
  export type FieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findMany
   */
  export type FieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Fields to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field create
   */
  export type FieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to create a Field.
     */
    data: XOR<FieldCreateInput, FieldUncheckedCreateInput>
  }

  /**
   * Field createMany
   */
  export type FieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Field update
   */
  export type FieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to update a Field.
     */
    data: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
    /**
     * Choose, which Field to update.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field updateMany
   */
  export type FieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
  }

  /**
   * Field upsert
   */
  export type FieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The filter to search for the Field to update in case it exists.
     */
    where: FieldWhereUniqueInput
    /**
     * In case the Field found by the `where` argument doesn't exist, create a new Field with this data.
     */
    create: XOR<FieldCreateInput, FieldUncheckedCreateInput>
    /**
     * In case the Field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
  }

  /**
   * Field delete
   */
  export type FieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter which Field to delete.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field deleteMany
   */
  export type FieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fields to delete
     */
    where?: FieldWhereInput
  }

  /**
   * Field.formList
   */
  export type Field$formListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Field.fieldAnswerList
   */
  export type Field$fieldAnswerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    where?: FieldAnswerWhereInput
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    cursor?: FieldAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldAnswerScalarFieldEnum | FieldAnswerScalarFieldEnum[]
  }

  /**
   * Field.fieldOptionList
   */
  export type Field$fieldOptionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    where?: FieldOptionWhereInput
    orderBy?: FieldOptionOrderByWithRelationInput | FieldOptionOrderByWithRelationInput[]
    cursor?: FieldOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOptionScalarFieldEnum | FieldOptionScalarFieldEnum[]
  }

  /**
   * Field without action
   */
  export type FieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
  }


  /**
   * Model FieldAnswer
   */

  export type AggregateFieldAnswer = {
    _count: FieldAnswerCountAggregateOutputType | null
    _min: FieldAnswerMinAggregateOutputType | null
    _max: FieldAnswerMaxAggregateOutputType | null
  }

  export type FieldAnswerMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    formSubmissionId: string | null
    fieldId: string | null
    value: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldAnswerMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    formSubmissionId: string | null
    fieldId: string | null
    value: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldAnswerCountAggregateOutputType = {
    id: number
    uuid: number
    formSubmissionId: number
    fieldId: number
    value: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FieldAnswerMinAggregateInputType = {
    id?: true
    uuid?: true
    formSubmissionId?: true
    fieldId?: true
    value?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldAnswerMaxAggregateInputType = {
    id?: true
    uuid?: true
    formSubmissionId?: true
    fieldId?: true
    value?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldAnswerCountAggregateInputType = {
    id?: true
    uuid?: true
    formSubmissionId?: true
    fieldId?: true
    value?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FieldAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldAnswer to aggregate.
     */
    where?: FieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldAnswers to fetch.
     */
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldAnswers
    **/
    _count?: true | FieldAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldAnswerMaxAggregateInputType
  }

  export type GetFieldAnswerAggregateType<T extends FieldAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldAnswer[P]>
      : GetScalarType<T[P], AggregateFieldAnswer[P]>
  }




  export type FieldAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldAnswerWhereInput
    orderBy?: FieldAnswerOrderByWithAggregationInput | FieldAnswerOrderByWithAggregationInput[]
    by: FieldAnswerScalarFieldEnum[] | FieldAnswerScalarFieldEnum
    having?: FieldAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldAnswerCountAggregateInputType | true
    _min?: FieldAnswerMinAggregateInputType
    _max?: FieldAnswerMaxAggregateInputType
  }

  export type FieldAnswerGroupByOutputType = {
    id: string
    uuid: string
    formSubmissionId: string
    fieldId: string
    value: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FieldAnswerCountAggregateOutputType | null
    _min: FieldAnswerMinAggregateOutputType | null
    _max: FieldAnswerMaxAggregateOutputType | null
  }

  type GetFieldAnswerGroupByPayload<T extends FieldAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], FieldAnswerGroupByOutputType[P]>
        }
      >
    >


  export type FieldAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    formSubmissionId?: boolean
    fieldId?: boolean
    value?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    formSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldAnswer"]>

  export type FieldAnswerSelectScalar = {
    id?: boolean
    uuid?: boolean
    formSubmissionId?: boolean
    fieldId?: boolean
    value?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FieldAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }


  export type $FieldAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldAnswer"
    objects: {
      formSubmission: Prisma.$FormSubmissionPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      formSubmissionId: string
      fieldId: string
      value: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["fieldAnswer"]>
    composites: {}
  }


  type FieldAnswerGetPayload<S extends boolean | null | undefined | FieldAnswerDefaultArgs> = $Result.GetResult<Prisma.$FieldAnswerPayload, S>

  type FieldAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FieldAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FieldAnswerCountAggregateInputType | true
    }

  export interface FieldAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldAnswer'], meta: { name: 'FieldAnswer' } }
    /**
     * Find zero or one FieldAnswer that matches the filter.
     * @param {FieldAnswerFindUniqueArgs} args - Arguments to find a FieldAnswer
     * @example
     * // Get one FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FieldAnswerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerFindUniqueArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FieldAnswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FieldAnswerFindUniqueOrThrowArgs} args - Arguments to find a FieldAnswer
     * @example
     * // Get one FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FieldAnswerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FieldAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerFindFirstArgs} args - Arguments to find a FieldAnswer
     * @example
     * // Get one FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FieldAnswerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerFindFirstArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FieldAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerFindFirstOrThrowArgs} args - Arguments to find a FieldAnswer
     * @example
     * // Get one FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FieldAnswerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FieldAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldAnswers
     * const fieldAnswers = await prisma.fieldAnswer.findMany()
     * 
     * // Get first 10 FieldAnswers
     * const fieldAnswers = await prisma.fieldAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldAnswerWithIdOnly = await prisma.fieldAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FieldAnswerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FieldAnswer.
     * @param {FieldAnswerCreateArgs} args - Arguments to create a FieldAnswer.
     * @example
     * // Create one FieldAnswer
     * const FieldAnswer = await prisma.fieldAnswer.create({
     *   data: {
     *     // ... data to create a FieldAnswer
     *   }
     * })
     * 
    **/
    create<T extends FieldAnswerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerCreateArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FieldAnswers.
     *     @param {FieldAnswerCreateManyArgs} args - Arguments to create many FieldAnswers.
     *     @example
     *     // Create many FieldAnswers
     *     const fieldAnswer = await prisma.fieldAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FieldAnswerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldAnswer.
     * @param {FieldAnswerDeleteArgs} args - Arguments to delete one FieldAnswer.
     * @example
     * // Delete one FieldAnswer
     * const FieldAnswer = await prisma.fieldAnswer.delete({
     *   where: {
     *     // ... filter to delete one FieldAnswer
     *   }
     * })
     * 
    **/
    delete<T extends FieldAnswerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerDeleteArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FieldAnswer.
     * @param {FieldAnswerUpdateArgs} args - Arguments to update one FieldAnswer.
     * @example
     * // Update one FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FieldAnswerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerUpdateArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FieldAnswers.
     * @param {FieldAnswerDeleteManyArgs} args - Arguments to filter FieldAnswers to delete.
     * @example
     * // Delete a few FieldAnswers
     * const { count } = await prisma.fieldAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FieldAnswerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldAnswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldAnswers
     * const fieldAnswer = await prisma.fieldAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FieldAnswerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldAnswer.
     * @param {FieldAnswerUpsertArgs} args - Arguments to update or create a FieldAnswer.
     * @example
     * // Update or create a FieldAnswer
     * const fieldAnswer = await prisma.fieldAnswer.upsert({
     *   create: {
     *     // ... data to create a FieldAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends FieldAnswerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FieldAnswerUpsertArgs<ExtArgs>>
    ): Prisma__FieldAnswerClient<$Result.GetResult<Prisma.$FieldAnswerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FieldAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerCountArgs} args - Arguments to filter FieldAnswers to count.
     * @example
     * // Count the number of FieldAnswers
     * const count = await prisma.fieldAnswer.count({
     *   where: {
     *     // ... the filter for the FieldAnswers we want to count
     *   }
     * })
    **/
    count<T extends FieldAnswerCountArgs>(
      args?: Subset<T, FieldAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAnswerAggregateArgs>(args: Subset<T, FieldAnswerAggregateArgs>): Prisma.PrismaPromise<GetFieldAnswerAggregateType<T>>

    /**
     * Group by FieldAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldAnswerGroupByArgs['orderBy'] }
        : { orderBy?: FieldAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldAnswer model
   */
  readonly fields: FieldAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    formSubmission<T extends FormSubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmissionDefaultArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FieldAnswer model
   */ 
  interface FieldAnswerFieldRefs {
    readonly id: FieldRef<"FieldAnswer", 'String'>
    readonly uuid: FieldRef<"FieldAnswer", 'String'>
    readonly formSubmissionId: FieldRef<"FieldAnswer", 'String'>
    readonly fieldId: FieldRef<"FieldAnswer", 'String'>
    readonly value: FieldRef<"FieldAnswer", 'String'>
    readonly creator: FieldRef<"FieldAnswer", 'String'>
    readonly dateCreated: FieldRef<"FieldAnswer", 'DateTime'>
    readonly lastChangedBy: FieldRef<"FieldAnswer", 'String'>
    readonly lastChangedDate: FieldRef<"FieldAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FieldAnswer findUnique
   */
  export type FieldAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter, which FieldAnswer to fetch.
     */
    where: FieldAnswerWhereUniqueInput
  }

  /**
   * FieldAnswer findUniqueOrThrow
   */
  export type FieldAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter, which FieldAnswer to fetch.
     */
    where: FieldAnswerWhereUniqueInput
  }

  /**
   * FieldAnswer findFirst
   */
  export type FieldAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter, which FieldAnswer to fetch.
     */
    where?: FieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldAnswers to fetch.
     */
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldAnswers.
     */
    cursor?: FieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldAnswers.
     */
    distinct?: FieldAnswerScalarFieldEnum | FieldAnswerScalarFieldEnum[]
  }

  /**
   * FieldAnswer findFirstOrThrow
   */
  export type FieldAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter, which FieldAnswer to fetch.
     */
    where?: FieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldAnswers to fetch.
     */
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldAnswers.
     */
    cursor?: FieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldAnswers.
     */
    distinct?: FieldAnswerScalarFieldEnum | FieldAnswerScalarFieldEnum[]
  }

  /**
   * FieldAnswer findMany
   */
  export type FieldAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter, which FieldAnswers to fetch.
     */
    where?: FieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldAnswers to fetch.
     */
    orderBy?: FieldAnswerOrderByWithRelationInput | FieldAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldAnswers.
     */
    cursor?: FieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldAnswers.
     */
    skip?: number
    distinct?: FieldAnswerScalarFieldEnum | FieldAnswerScalarFieldEnum[]
  }

  /**
   * FieldAnswer create
   */
  export type FieldAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldAnswer.
     */
    data: XOR<FieldAnswerCreateInput, FieldAnswerUncheckedCreateInput>
  }

  /**
   * FieldAnswer createMany
   */
  export type FieldAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldAnswers.
     */
    data: FieldAnswerCreateManyInput | FieldAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldAnswer update
   */
  export type FieldAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldAnswer.
     */
    data: XOR<FieldAnswerUpdateInput, FieldAnswerUncheckedUpdateInput>
    /**
     * Choose, which FieldAnswer to update.
     */
    where: FieldAnswerWhereUniqueInput
  }

  /**
   * FieldAnswer updateMany
   */
  export type FieldAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldAnswers.
     */
    data: XOR<FieldAnswerUpdateManyMutationInput, FieldAnswerUncheckedUpdateManyInput>
    /**
     * Filter which FieldAnswers to update
     */
    where?: FieldAnswerWhereInput
  }

  /**
   * FieldAnswer upsert
   */
  export type FieldAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldAnswer to update in case it exists.
     */
    where: FieldAnswerWhereUniqueInput
    /**
     * In case the FieldAnswer found by the `where` argument doesn't exist, create a new FieldAnswer with this data.
     */
    create: XOR<FieldAnswerCreateInput, FieldAnswerUncheckedCreateInput>
    /**
     * In case the FieldAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldAnswerUpdateInput, FieldAnswerUncheckedUpdateInput>
  }

  /**
   * FieldAnswer delete
   */
  export type FieldAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
    /**
     * Filter which FieldAnswer to delete.
     */
    where: FieldAnswerWhereUniqueInput
  }

  /**
   * FieldAnswer deleteMany
   */
  export type FieldAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldAnswers to delete
     */
    where?: FieldAnswerWhereInput
  }

  /**
   * FieldAnswer without action
   */
  export type FieldAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldAnswer
     */
    select?: FieldAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldAnswerInclude<ExtArgs> | null
  }


  /**
   * Model FieldOption
   */

  export type AggregateFieldOption = {
    _count: FieldOptionCountAggregateOutputType | null
    _min: FieldOptionMinAggregateOutputType | null
    _max: FieldOptionMaxAggregateOutputType | null
  }

  export type FieldOptionMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    fieldId: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldOptionMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    fieldId: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type FieldOptionCountAggregateOutputType = {
    id: number
    uuid: number
    fieldId: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type FieldOptionMinAggregateInputType = {
    id?: true
    uuid?: true
    fieldId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldOptionMaxAggregateInputType = {
    id?: true
    uuid?: true
    fieldId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type FieldOptionCountAggregateInputType = {
    id?: true
    uuid?: true
    fieldId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type FieldOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOption to aggregate.
     */
    where?: FieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOptions to fetch.
     */
    orderBy?: FieldOptionOrderByWithRelationInput | FieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldOptions
    **/
    _count?: true | FieldOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldOptionMaxAggregateInputType
  }

  export type GetFieldOptionAggregateType<T extends FieldOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldOption[P]>
      : GetScalarType<T[P], AggregateFieldOption[P]>
  }




  export type FieldOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOptionWhereInput
    orderBy?: FieldOptionOrderByWithAggregationInput | FieldOptionOrderByWithAggregationInput[]
    by: FieldOptionScalarFieldEnum[] | FieldOptionScalarFieldEnum
    having?: FieldOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldOptionCountAggregateInputType | true
    _min?: FieldOptionMinAggregateInputType
    _max?: FieldOptionMaxAggregateInputType
  }

  export type FieldOptionGroupByOutputType = {
    id: string
    uuid: string
    fieldId: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: FieldOptionCountAggregateOutputType | null
    _min: FieldOptionMinAggregateOutputType | null
    _max: FieldOptionMaxAggregateOutputType | null
  }

  type GetFieldOptionGroupByPayload<T extends FieldOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldOptionGroupByOutputType[P]>
            : GetScalarType<T[P], FieldOptionGroupByOutputType[P]>
        }
      >
    >


  export type FieldOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    fieldId?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldOption"]>

  export type FieldOptionSelectScalar = {
    id?: boolean
    uuid?: boolean
    fieldId?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type FieldOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }


  export type $FieldOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldOption"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      fieldId: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["fieldOption"]>
    composites: {}
  }


  type FieldOptionGetPayload<S extends boolean | null | undefined | FieldOptionDefaultArgs> = $Result.GetResult<Prisma.$FieldOptionPayload, S>

  type FieldOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FieldOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FieldOptionCountAggregateInputType | true
    }

  export interface FieldOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldOption'], meta: { name: 'FieldOption' } }
    /**
     * Find zero or one FieldOption that matches the filter.
     * @param {FieldOptionFindUniqueArgs} args - Arguments to find a FieldOption
     * @example
     * // Get one FieldOption
     * const fieldOption = await prisma.fieldOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FieldOptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionFindUniqueArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FieldOption that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FieldOptionFindUniqueOrThrowArgs} args - Arguments to find a FieldOption
     * @example
     * // Get one FieldOption
     * const fieldOption = await prisma.fieldOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FieldOptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FieldOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionFindFirstArgs} args - Arguments to find a FieldOption
     * @example
     * // Get one FieldOption
     * const fieldOption = await prisma.fieldOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FieldOptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionFindFirstArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FieldOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionFindFirstOrThrowArgs} args - Arguments to find a FieldOption
     * @example
     * // Get one FieldOption
     * const fieldOption = await prisma.fieldOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FieldOptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FieldOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldOptions
     * const fieldOptions = await prisma.fieldOption.findMany()
     * 
     * // Get first 10 FieldOptions
     * const fieldOptions = await prisma.fieldOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldOptionWithIdOnly = await prisma.fieldOption.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FieldOptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FieldOption.
     * @param {FieldOptionCreateArgs} args - Arguments to create a FieldOption.
     * @example
     * // Create one FieldOption
     * const FieldOption = await prisma.fieldOption.create({
     *   data: {
     *     // ... data to create a FieldOption
     *   }
     * })
     * 
    **/
    create<T extends FieldOptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionCreateArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FieldOptions.
     *     @param {FieldOptionCreateManyArgs} args - Arguments to create many FieldOptions.
     *     @example
     *     // Create many FieldOptions
     *     const fieldOption = await prisma.fieldOption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FieldOptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldOption.
     * @param {FieldOptionDeleteArgs} args - Arguments to delete one FieldOption.
     * @example
     * // Delete one FieldOption
     * const FieldOption = await prisma.fieldOption.delete({
     *   where: {
     *     // ... filter to delete one FieldOption
     *   }
     * })
     * 
    **/
    delete<T extends FieldOptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionDeleteArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FieldOption.
     * @param {FieldOptionUpdateArgs} args - Arguments to update one FieldOption.
     * @example
     * // Update one FieldOption
     * const fieldOption = await prisma.fieldOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FieldOptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionUpdateArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FieldOptions.
     * @param {FieldOptionDeleteManyArgs} args - Arguments to filter FieldOptions to delete.
     * @example
     * // Delete a few FieldOptions
     * const { count } = await prisma.fieldOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FieldOptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FieldOptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldOptions
     * const fieldOption = await prisma.fieldOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FieldOptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldOption.
     * @param {FieldOptionUpsertArgs} args - Arguments to update or create a FieldOption.
     * @example
     * // Update or create a FieldOption
     * const fieldOption = await prisma.fieldOption.upsert({
     *   create: {
     *     // ... data to create a FieldOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldOption we want to update
     *   }
     * })
    **/
    upsert<T extends FieldOptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FieldOptionUpsertArgs<ExtArgs>>
    ): Prisma__FieldOptionClient<$Result.GetResult<Prisma.$FieldOptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionCountArgs} args - Arguments to filter FieldOptions to count.
     * @example
     * // Count the number of FieldOptions
     * const count = await prisma.fieldOption.count({
     *   where: {
     *     // ... the filter for the FieldOptions we want to count
     *   }
     * })
    **/
    count<T extends FieldOptionCountArgs>(
      args?: Subset<T, FieldOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldOptionAggregateArgs>(args: Subset<T, FieldOptionAggregateArgs>): Prisma.PrismaPromise<GetFieldOptionAggregateType<T>>

    /**
     * Group by FieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldOptionGroupByArgs['orderBy'] }
        : { orderBy?: FieldOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldOption model
   */
  readonly fields: FieldOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FieldOption model
   */ 
  interface FieldOptionFieldRefs {
    readonly id: FieldRef<"FieldOption", 'String'>
    readonly uuid: FieldRef<"FieldOption", 'String'>
    readonly fieldId: FieldRef<"FieldOption", 'String'>
    readonly name: FieldRef<"FieldOption", 'String'>
    readonly description: FieldRef<"FieldOption", 'String'>
    readonly creator: FieldRef<"FieldOption", 'String'>
    readonly dateCreated: FieldRef<"FieldOption", 'DateTime'>
    readonly lastChangedBy: FieldRef<"FieldOption", 'String'>
    readonly lastChangedDate: FieldRef<"FieldOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FieldOption findUnique
   */
  export type FieldOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FieldOption to fetch.
     */
    where: FieldOptionWhereUniqueInput
  }

  /**
   * FieldOption findUniqueOrThrow
   */
  export type FieldOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FieldOption to fetch.
     */
    where: FieldOptionWhereUniqueInput
  }

  /**
   * FieldOption findFirst
   */
  export type FieldOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FieldOption to fetch.
     */
    where?: FieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOptions to fetch.
     */
    orderBy?: FieldOptionOrderByWithRelationInput | FieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOptions.
     */
    cursor?: FieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOptions.
     */
    distinct?: FieldOptionScalarFieldEnum | FieldOptionScalarFieldEnum[]
  }

  /**
   * FieldOption findFirstOrThrow
   */
  export type FieldOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FieldOption to fetch.
     */
    where?: FieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOptions to fetch.
     */
    orderBy?: FieldOptionOrderByWithRelationInput | FieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOptions.
     */
    cursor?: FieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOptions.
     */
    distinct?: FieldOptionScalarFieldEnum | FieldOptionScalarFieldEnum[]
  }

  /**
   * FieldOption findMany
   */
  export type FieldOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FieldOptions to fetch.
     */
    where?: FieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOptions to fetch.
     */
    orderBy?: FieldOptionOrderByWithRelationInput | FieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldOptions.
     */
    cursor?: FieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOptions.
     */
    skip?: number
    distinct?: FieldOptionScalarFieldEnum | FieldOptionScalarFieldEnum[]
  }

  /**
   * FieldOption create
   */
  export type FieldOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldOption.
     */
    data: XOR<FieldOptionCreateInput, FieldOptionUncheckedCreateInput>
  }

  /**
   * FieldOption createMany
   */
  export type FieldOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldOptions.
     */
    data: FieldOptionCreateManyInput | FieldOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldOption update
   */
  export type FieldOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldOption.
     */
    data: XOR<FieldOptionUpdateInput, FieldOptionUncheckedUpdateInput>
    /**
     * Choose, which FieldOption to update.
     */
    where: FieldOptionWhereUniqueInput
  }

  /**
   * FieldOption updateMany
   */
  export type FieldOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldOptions.
     */
    data: XOR<FieldOptionUpdateManyMutationInput, FieldOptionUncheckedUpdateManyInput>
    /**
     * Filter which FieldOptions to update
     */
    where?: FieldOptionWhereInput
  }

  /**
   * FieldOption upsert
   */
  export type FieldOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldOption to update in case it exists.
     */
    where: FieldOptionWhereUniqueInput
    /**
     * In case the FieldOption found by the `where` argument doesn't exist, create a new FieldOption with this data.
     */
    create: XOR<FieldOptionCreateInput, FieldOptionUncheckedCreateInput>
    /**
     * In case the FieldOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldOptionUpdateInput, FieldOptionUncheckedUpdateInput>
  }

  /**
   * FieldOption delete
   */
  export type FieldOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
    /**
     * Filter which FieldOption to delete.
     */
    where: FieldOptionWhereUniqueInput
  }

  /**
   * FieldOption deleteMany
   */
  export type FieldOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOptions to delete
     */
    where?: FieldOptionWhereInput
  }

  /**
   * FieldOption without action
   */
  export type FieldOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOption
     */
    select?: FieldOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOptionInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    encounterTypeId: string | null
    patientId: string | null
    locationId: string | null
    formId: string | null
    providerId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    encounterTypeId: string | null
    patientId: string | null
    locationId: string | null
    formId: string | null
    providerId: string | null
    startDatetime: Date | null
    endDatetime: Date | null
    voided: boolean | null
    voidedBy: string | null
    dateVoided: Date | null
    voidReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    uuid: number
    encounterTypeId: number
    patientId: number
    locationId: number
    formId: number
    providerId: number
    startDatetime: number
    endDatetime: number
    voided: number
    voidedBy: number
    dateVoided: number
    voidReason: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type EncounterMinAggregateInputType = {
    id?: true
    uuid?: true
    encounterTypeId?: true
    patientId?: true
    locationId?: true
    formId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    uuid?: true
    encounterTypeId?: true
    patientId?: true
    locationId?: true
    formId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    uuid?: true
    encounterTypeId?: true
    patientId?: true
    locationId?: true
    formId?: true
    providerId?: true
    startDatetime?: true
    endDatetime?: true
    voided?: true
    voidedBy?: true
    dateVoided?: true
    voidReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date
    endDatetime: Date
    voided: boolean
    voidedBy: string
    dateVoided: Date
    voidReason: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    encounterTypeId?: boolean
    patientId?: boolean
    locationId?: boolean
    formId?: boolean
    providerId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    encounterType?: boolean | EncounterTypeDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    formEncounterList?: boolean | Encounter$formEncounterListArgs<ExtArgs>
    formSubmissionList?: boolean | Encounter$formSubmissionListArgs<ExtArgs>
    obsList?: boolean | Encounter$obsListArgs<ExtArgs>
    orderList?: boolean | Encounter$orderListArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    uuid?: boolean
    encounterTypeId?: boolean
    patientId?: boolean
    locationId?: boolean
    formId?: boolean
    providerId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    voided?: boolean
    voidedBy?: boolean
    dateVoided?: boolean
    voidReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterType?: boolean | EncounterTypeDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    formEncounterList?: boolean | Encounter$formEncounterListArgs<ExtArgs>
    formSubmissionList?: boolean | Encounter$formSubmissionListArgs<ExtArgs>
    obsList?: boolean | Encounter$obsListArgs<ExtArgs>
    orderList?: boolean | Encounter$orderListArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      encounterType: Prisma.$EncounterTypePayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      form: Prisma.$FormPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
      formEncounterList: Prisma.$FormEncounterPayload<ExtArgs>[]
      formSubmissionList: Prisma.$FormSubmissionPayload<ExtArgs>[]
      obsList: Prisma.$ObsPayload<ExtArgs>[]
      orderList: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      encounterTypeId: string
      patientId: string
      locationId: string
      formId: string
      providerId: string
      startDatetime: Date
      endDatetime: Date
      voided: boolean
      voidedBy: string
      dateVoided: Date
      voidReason: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }


  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EncounterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EncounterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EncounterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
    **/
    create<T extends EncounterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Encounters.
     *     @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     *     @example
     *     // Create many Encounters
     *     const encounter = await prisma.encounter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EncounterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
    **/
    delete<T extends EncounterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EncounterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EncounterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EncounterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
    **/
    upsert<T extends EncounterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>
    ): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    encounterType<T extends EncounterTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterTypeDefaultArgs<ExtArgs>>): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    formEncounterList<T extends Encounter$formEncounterListArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$formEncounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormEncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    formSubmissionList<T extends Encounter$formSubmissionListArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$formSubmissionListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    obsList<T extends Encounter$obsListArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$obsListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findMany'> | Null>;

    orderList<T extends Encounter$orderListArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly uuid: FieldRef<"Encounter", 'String'>
    readonly encounterTypeId: FieldRef<"Encounter", 'String'>
    readonly patientId: FieldRef<"Encounter", 'String'>
    readonly locationId: FieldRef<"Encounter", 'String'>
    readonly formId: FieldRef<"Encounter", 'String'>
    readonly providerId: FieldRef<"Encounter", 'String'>
    readonly startDatetime: FieldRef<"Encounter", 'DateTime'>
    readonly endDatetime: FieldRef<"Encounter", 'DateTime'>
    readonly voided: FieldRef<"Encounter", 'Boolean'>
    readonly voidedBy: FieldRef<"Encounter", 'String'>
    readonly dateVoided: FieldRef<"Encounter", 'DateTime'>
    readonly voidReason: FieldRef<"Encounter", 'String'>
    readonly creator: FieldRef<"Encounter", 'String'>
    readonly dateCreated: FieldRef<"Encounter", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Encounter", 'String'>
    readonly lastChangedDate: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.formEncounterList
   */
  export type Encounter$formEncounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormEncounter
     */
    select?: FormEncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormEncounterInclude<ExtArgs> | null
    where?: FormEncounterWhereInput
    orderBy?: FormEncounterOrderByWithRelationInput | FormEncounterOrderByWithRelationInput[]
    cursor?: FormEncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormEncounterScalarFieldEnum | FormEncounterScalarFieldEnum[]
  }

  /**
   * Encounter.formSubmissionList
   */
  export type Encounter$formSubmissionListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * Encounter.obsList
   */
  export type Encounter$obsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    where?: ObsWhereInput
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    cursor?: ObsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObsScalarFieldEnum | ObsScalarFieldEnum[]
  }

  /**
   * Encounter.orderList
   */
  export type Encounter$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model EncounterType
   */

  export type AggregateEncounterType = {
    _count: EncounterTypeCountAggregateOutputType | null
    _min: EncounterTypeMinAggregateOutputType | null
    _max: EncounterTypeMaxAggregateOutputType | null
  }

  export type EncounterTypeMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type EncounterTypeMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type EncounterTypeCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type EncounterTypeMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type EncounterTypeMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type EncounterTypeCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type EncounterTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterType to aggregate.
     */
    where?: EncounterTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterTypes to fetch.
     */
    orderBy?: EncounterTypeOrderByWithRelationInput | EncounterTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterTypes
    **/
    _count?: true | EncounterTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterTypeMaxAggregateInputType
  }

  export type GetEncounterTypeAggregateType<T extends EncounterTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterType[P]>
      : GetScalarType<T[P], AggregateEncounterType[P]>
  }




  export type EncounterTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterTypeWhereInput
    orderBy?: EncounterTypeOrderByWithAggregationInput | EncounterTypeOrderByWithAggregationInput[]
    by: EncounterTypeScalarFieldEnum[] | EncounterTypeScalarFieldEnum
    having?: EncounterTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterTypeCountAggregateInputType | true
    _min?: EncounterTypeMinAggregateInputType
    _max?: EncounterTypeMaxAggregateInputType
  }

  export type EncounterTypeGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: EncounterTypeCountAggregateOutputType | null
    _min: EncounterTypeMinAggregateOutputType | null
    _max: EncounterTypeMaxAggregateOutputType | null
  }

  type GetEncounterTypeGroupByPayload<T extends EncounterTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterTypeGroupByOutputType[P]>
        }
      >
    >


  export type EncounterTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    encounterList?: boolean | EncounterType$encounterListArgs<ExtArgs>
    _count?: boolean | EncounterTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterType"]>

  export type EncounterTypeSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type EncounterTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterList?: boolean | EncounterType$encounterListArgs<ExtArgs>
    _count?: boolean | EncounterTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EncounterTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterType"
    objects: {
      encounterList: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["encounterType"]>
    composites: {}
  }


  type EncounterTypeGetPayload<S extends boolean | null | undefined | EncounterTypeDefaultArgs> = $Result.GetResult<Prisma.$EncounterTypePayload, S>

  type EncounterTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterTypeCountAggregateInputType | true
    }

  export interface EncounterTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterType'], meta: { name: 'EncounterType' } }
    /**
     * Find zero or one EncounterType that matches the filter.
     * @param {EncounterTypeFindUniqueArgs} args - Arguments to find a EncounterType
     * @example
     * // Get one EncounterType
     * const encounterType = await prisma.encounterType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EncounterTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EncounterType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EncounterTypeFindUniqueOrThrowArgs} args - Arguments to find a EncounterType
     * @example
     * // Get one EncounterType
     * const encounterType = await prisma.encounterType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EncounterTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EncounterType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeFindFirstArgs} args - Arguments to find a EncounterType
     * @example
     * // Get one EncounterType
     * const encounterType = await prisma.encounterType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EncounterTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeFindFirstArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EncounterType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeFindFirstOrThrowArgs} args - Arguments to find a EncounterType
     * @example
     * // Get one EncounterType
     * const encounterType = await prisma.encounterType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EncounterTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EncounterTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterTypes
     * const encounterTypes = await prisma.encounterType.findMany()
     * 
     * // Get first 10 EncounterTypes
     * const encounterTypes = await prisma.encounterType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterTypeWithIdOnly = await prisma.encounterType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EncounterTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EncounterType.
     * @param {EncounterTypeCreateArgs} args - Arguments to create a EncounterType.
     * @example
     * // Create one EncounterType
     * const EncounterType = await prisma.encounterType.create({
     *   data: {
     *     // ... data to create a EncounterType
     *   }
     * })
     * 
    **/
    create<T extends EncounterTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeCreateArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EncounterTypes.
     *     @param {EncounterTypeCreateManyArgs} args - Arguments to create many EncounterTypes.
     *     @example
     *     // Create many EncounterTypes
     *     const encounterType = await prisma.encounterType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EncounterTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncounterType.
     * @param {EncounterTypeDeleteArgs} args - Arguments to delete one EncounterType.
     * @example
     * // Delete one EncounterType
     * const EncounterType = await prisma.encounterType.delete({
     *   where: {
     *     // ... filter to delete one EncounterType
     *   }
     * })
     * 
    **/
    delete<T extends EncounterTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeDeleteArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EncounterType.
     * @param {EncounterTypeUpdateArgs} args - Arguments to update one EncounterType.
     * @example
     * // Update one EncounterType
     * const encounterType = await prisma.encounterType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EncounterTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeUpdateArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EncounterTypes.
     * @param {EncounterTypeDeleteManyArgs} args - Arguments to filter EncounterTypes to delete.
     * @example
     * // Delete a few EncounterTypes
     * const { count } = await prisma.encounterType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EncounterTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EncounterTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterTypes
     * const encounterType = await prisma.encounterType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EncounterTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterType.
     * @param {EncounterTypeUpsertArgs} args - Arguments to update or create a EncounterType.
     * @example
     * // Update or create a EncounterType
     * const encounterType = await prisma.encounterType.upsert({
     *   create: {
     *     // ... data to create a EncounterType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterType we want to update
     *   }
     * })
    **/
    upsert<T extends EncounterTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EncounterTypeUpsertArgs<ExtArgs>>
    ): Prisma__EncounterTypeClient<$Result.GetResult<Prisma.$EncounterTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EncounterTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeCountArgs} args - Arguments to filter EncounterTypes to count.
     * @example
     * // Count the number of EncounterTypes
     * const count = await prisma.encounterType.count({
     *   where: {
     *     // ... the filter for the EncounterTypes we want to count
     *   }
     * })
    **/
    count<T extends EncounterTypeCountArgs>(
      args?: Subset<T, EncounterTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterTypeAggregateArgs>(args: Subset<T, EncounterTypeAggregateArgs>): Prisma.PrismaPromise<GetEncounterTypeAggregateType<T>>

    /**
     * Group by EncounterType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterTypeGroupByArgs['orderBy'] }
        : { orderBy?: EncounterTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterType model
   */
  readonly fields: EncounterTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    encounterList<T extends EncounterType$encounterListArgs<ExtArgs> = {}>(args?: Subset<T, EncounterType$encounterListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EncounterType model
   */ 
  interface EncounterTypeFieldRefs {
    readonly id: FieldRef<"EncounterType", 'String'>
    readonly uuid: FieldRef<"EncounterType", 'String'>
    readonly name: FieldRef<"EncounterType", 'String'>
    readonly description: FieldRef<"EncounterType", 'String'>
    readonly creator: FieldRef<"EncounterType", 'String'>
    readonly dateCreated: FieldRef<"EncounterType", 'DateTime'>
    readonly lastChangedBy: FieldRef<"EncounterType", 'String'>
    readonly lastChangedDate: FieldRef<"EncounterType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterType findUnique
   */
  export type EncounterTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter, which EncounterType to fetch.
     */
    where: EncounterTypeWhereUniqueInput
  }

  /**
   * EncounterType findUniqueOrThrow
   */
  export type EncounterTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter, which EncounterType to fetch.
     */
    where: EncounterTypeWhereUniqueInput
  }

  /**
   * EncounterType findFirst
   */
  export type EncounterTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter, which EncounterType to fetch.
     */
    where?: EncounterTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterTypes to fetch.
     */
    orderBy?: EncounterTypeOrderByWithRelationInput | EncounterTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterTypes.
     */
    cursor?: EncounterTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterTypes.
     */
    distinct?: EncounterTypeScalarFieldEnum | EncounterTypeScalarFieldEnum[]
  }

  /**
   * EncounterType findFirstOrThrow
   */
  export type EncounterTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter, which EncounterType to fetch.
     */
    where?: EncounterTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterTypes to fetch.
     */
    orderBy?: EncounterTypeOrderByWithRelationInput | EncounterTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterTypes.
     */
    cursor?: EncounterTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterTypes.
     */
    distinct?: EncounterTypeScalarFieldEnum | EncounterTypeScalarFieldEnum[]
  }

  /**
   * EncounterType findMany
   */
  export type EncounterTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter, which EncounterTypes to fetch.
     */
    where?: EncounterTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterTypes to fetch.
     */
    orderBy?: EncounterTypeOrderByWithRelationInput | EncounterTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterTypes.
     */
    cursor?: EncounterTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterTypes.
     */
    skip?: number
    distinct?: EncounterTypeScalarFieldEnum | EncounterTypeScalarFieldEnum[]
  }

  /**
   * EncounterType create
   */
  export type EncounterTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterType.
     */
    data: XOR<EncounterTypeCreateInput, EncounterTypeUncheckedCreateInput>
  }

  /**
   * EncounterType createMany
   */
  export type EncounterTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterTypes.
     */
    data: EncounterTypeCreateManyInput | EncounterTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterType update
   */
  export type EncounterTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterType.
     */
    data: XOR<EncounterTypeUpdateInput, EncounterTypeUncheckedUpdateInput>
    /**
     * Choose, which EncounterType to update.
     */
    where: EncounterTypeWhereUniqueInput
  }

  /**
   * EncounterType updateMany
   */
  export type EncounterTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterTypes.
     */
    data: XOR<EncounterTypeUpdateManyMutationInput, EncounterTypeUncheckedUpdateManyInput>
    /**
     * Filter which EncounterTypes to update
     */
    where?: EncounterTypeWhereInput
  }

  /**
   * EncounterType upsert
   */
  export type EncounterTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterType to update in case it exists.
     */
    where: EncounterTypeWhereUniqueInput
    /**
     * In case the EncounterType found by the `where` argument doesn't exist, create a new EncounterType with this data.
     */
    create: XOR<EncounterTypeCreateInput, EncounterTypeUncheckedCreateInput>
    /**
     * In case the EncounterType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterTypeUpdateInput, EncounterTypeUncheckedUpdateInput>
  }

  /**
   * EncounterType delete
   */
  export type EncounterTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
    /**
     * Filter which EncounterType to delete.
     */
    where: EncounterTypeWhereUniqueInput
  }

  /**
   * EncounterType deleteMany
   */
  export type EncounterTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterTypes to delete
     */
    where?: EncounterTypeWhereInput
  }

  /**
   * EncounterType.encounterList
   */
  export type EncounterType$encounterListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * EncounterType without action
   */
  export type EncounterTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterType
     */
    select?: EncounterTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterTypeInclude<ExtArgs> | null
  }


  /**
   * Model Obs
   */

  export type AggregateObs = {
    _count: ObsCountAggregateOutputType | null
    _avg: ObsAvgAggregateOutputType | null
    _sum: ObsSumAggregateOutputType | null
    _min: ObsMinAggregateOutputType | null
    _max: ObsMaxAggregateOutputType | null
  }

  export type ObsAvgAggregateOutputType = {
    valueNumeric: number | null
  }

  export type ObsSumAggregateOutputType = {
    valueNumeric: number | null
  }

  export type ObsMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    encounterId: string | null
    obsDatetime: Date | null
    valueDatetime: Date | null
    valueNumeric: number | null
    valueText: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ObsMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    encounterId: string | null
    obsDatetime: Date | null
    valueDatetime: Date | null
    valueNumeric: number | null
    valueText: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ObsCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    encounterId: number
    obsDatetime: number
    valueDatetime: number
    valueNumeric: number
    valueText: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ObsAvgAggregateInputType = {
    valueNumeric?: true
  }

  export type ObsSumAggregateInputType = {
    valueNumeric?: true
  }

  export type ObsMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    obsDatetime?: true
    valueDatetime?: true
    valueNumeric?: true
    valueText?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ObsMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    obsDatetime?: true
    valueDatetime?: true
    valueNumeric?: true
    valueText?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ObsCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    obsDatetime?: true
    valueDatetime?: true
    valueNumeric?: true
    valueText?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ObsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obs to aggregate.
     */
    where?: ObsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obs to fetch.
     */
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Obs
    **/
    _count?: true | ObsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObsMaxAggregateInputType
  }

  export type GetObsAggregateType<T extends ObsAggregateArgs> = {
        [P in keyof T & keyof AggregateObs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObs[P]>
      : GetScalarType<T[P], AggregateObs[P]>
  }




  export type ObsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObsWhereInput
    orderBy?: ObsOrderByWithAggregationInput | ObsOrderByWithAggregationInput[]
    by: ObsScalarFieldEnum[] | ObsScalarFieldEnum
    having?: ObsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObsCountAggregateInputType | true
    _avg?: ObsAvgAggregateInputType
    _sum?: ObsSumAggregateInputType
    _min?: ObsMinAggregateInputType
    _max?: ObsMaxAggregateInputType
  }

  export type ObsGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    encounterId: string
    obsDatetime: Date
    valueDatetime: Date
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ObsCountAggregateOutputType | null
    _avg: ObsAvgAggregateOutputType | null
    _sum: ObsSumAggregateOutputType | null
    _min: ObsMinAggregateOutputType | null
    _max: ObsMaxAggregateOutputType | null
  }

  type GetObsGroupByPayload<T extends ObsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObsGroupByOutputType[P]>
            : GetScalarType<T[P], ObsGroupByOutputType[P]>
        }
      >
    >


  export type ObsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    encounterId?: boolean
    obsDatetime?: boolean
    valueDatetime?: boolean
    valueNumeric?: boolean
    valueText?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obs"]>

  export type ObsSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    encounterId?: boolean
    obsDatetime?: boolean
    valueDatetime?: boolean
    valueNumeric?: boolean
    valueText?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ObsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }


  export type $ObsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Obs"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      encounterId: string
      obsDatetime: Date
      valueDatetime: Date
      valueNumeric: number
      valueText: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["obs"]>
    composites: {}
  }


  type ObsGetPayload<S extends boolean | null | undefined | ObsDefaultArgs> = $Result.GetResult<Prisma.$ObsPayload, S>

  type ObsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObsCountAggregateInputType | true
    }

  export interface ObsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Obs'], meta: { name: 'Obs' } }
    /**
     * Find zero or one Obs that matches the filter.
     * @param {ObsFindUniqueArgs} args - Arguments to find a Obs
     * @example
     * // Get one Obs
     * const obs = await prisma.obs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObsFindUniqueArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Obs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObsFindUniqueOrThrowArgs} args - Arguments to find a Obs
     * @example
     * // Get one Obs
     * const obs = await prisma.obs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Obs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsFindFirstArgs} args - Arguments to find a Obs
     * @example
     * // Get one Obs
     * const obs = await prisma.obs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsFindFirstArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Obs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsFindFirstOrThrowArgs} args - Arguments to find a Obs
     * @example
     * // Get one Obs
     * const obs = await prisma.obs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Obs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obs
     * const obs = await prisma.obs.findMany()
     * 
     * // Get first 10 Obs
     * const obs = await prisma.obs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obsWithIdOnly = await prisma.obs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Obs.
     * @param {ObsCreateArgs} args - Arguments to create a Obs.
     * @example
     * // Create one Obs
     * const Obs = await prisma.obs.create({
     *   data: {
     *     // ... data to create a Obs
     *   }
     * })
     * 
    **/
    create<T extends ObsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObsCreateArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Obs.
     *     @param {ObsCreateManyArgs} args - Arguments to create many Obs.
     *     @example
     *     // Create many Obs
     *     const obs = await prisma.obs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Obs.
     * @param {ObsDeleteArgs} args - Arguments to delete one Obs.
     * @example
     * // Delete one Obs
     * const Obs = await prisma.obs.delete({
     *   where: {
     *     // ... filter to delete one Obs
     *   }
     * })
     * 
    **/
    delete<T extends ObsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObsDeleteArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Obs.
     * @param {ObsUpdateArgs} args - Arguments to update one Obs.
     * @example
     * // Update one Obs
     * const obs = await prisma.obs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObsUpdateArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Obs.
     * @param {ObsDeleteManyArgs} args - Arguments to filter Obs to delete.
     * @example
     * // Delete a few Obs
     * const { count } = await prisma.obs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obs
     * const obs = await prisma.obs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Obs.
     * @param {ObsUpsertArgs} args - Arguments to update or create a Obs.
     * @example
     * // Update or create a Obs
     * const obs = await prisma.obs.upsert({
     *   create: {
     *     // ... data to create a Obs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obs we want to update
     *   }
     * })
    **/
    upsert<T extends ObsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObsUpsertArgs<ExtArgs>>
    ): Prisma__ObsClient<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Obs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsCountArgs} args - Arguments to filter Obs to count.
     * @example
     * // Count the number of Obs
     * const count = await prisma.obs.count({
     *   where: {
     *     // ... the filter for the Obs we want to count
     *   }
     * })
    **/
    count<T extends ObsCountArgs>(
      args?: Subset<T, ObsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObsAggregateArgs>(args: Subset<T, ObsAggregateArgs>): Prisma.PrismaPromise<GetObsAggregateType<T>>

    /**
     * Group by Obs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObsGroupByArgs['orderBy'] }
        : { orderBy?: ObsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Obs model
   */
  readonly fields: ObsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Obs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Obs model
   */ 
  interface ObsFieldRefs {
    readonly id: FieldRef<"Obs", 'String'>
    readonly uuid: FieldRef<"Obs", 'String'>
    readonly conceptId: FieldRef<"Obs", 'String'>
    readonly encounterId: FieldRef<"Obs", 'String'>
    readonly obsDatetime: FieldRef<"Obs", 'DateTime'>
    readonly valueDatetime: FieldRef<"Obs", 'DateTime'>
    readonly valueNumeric: FieldRef<"Obs", 'Float'>
    readonly valueText: FieldRef<"Obs", 'String'>
    readonly creator: FieldRef<"Obs", 'String'>
    readonly dateCreated: FieldRef<"Obs", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Obs", 'String'>
    readonly lastChangedDate: FieldRef<"Obs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Obs findUnique
   */
  export type ObsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter, which Obs to fetch.
     */
    where: ObsWhereUniqueInput
  }

  /**
   * Obs findUniqueOrThrow
   */
  export type ObsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter, which Obs to fetch.
     */
    where: ObsWhereUniqueInput
  }

  /**
   * Obs findFirst
   */
  export type ObsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter, which Obs to fetch.
     */
    where?: ObsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obs to fetch.
     */
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obs.
     */
    cursor?: ObsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obs.
     */
    distinct?: ObsScalarFieldEnum | ObsScalarFieldEnum[]
  }

  /**
   * Obs findFirstOrThrow
   */
  export type ObsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter, which Obs to fetch.
     */
    where?: ObsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obs to fetch.
     */
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obs.
     */
    cursor?: ObsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obs.
     */
    distinct?: ObsScalarFieldEnum | ObsScalarFieldEnum[]
  }

  /**
   * Obs findMany
   */
  export type ObsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter, which Obs to fetch.
     */
    where?: ObsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obs to fetch.
     */
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Obs.
     */
    cursor?: ObsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obs.
     */
    skip?: number
    distinct?: ObsScalarFieldEnum | ObsScalarFieldEnum[]
  }

  /**
   * Obs create
   */
  export type ObsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * The data needed to create a Obs.
     */
    data: XOR<ObsCreateInput, ObsUncheckedCreateInput>
  }

  /**
   * Obs createMany
   */
  export type ObsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Obs.
     */
    data: ObsCreateManyInput | ObsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Obs update
   */
  export type ObsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * The data needed to update a Obs.
     */
    data: XOR<ObsUpdateInput, ObsUncheckedUpdateInput>
    /**
     * Choose, which Obs to update.
     */
    where: ObsWhereUniqueInput
  }

  /**
   * Obs updateMany
   */
  export type ObsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Obs.
     */
    data: XOR<ObsUpdateManyMutationInput, ObsUncheckedUpdateManyInput>
    /**
     * Filter which Obs to update
     */
    where?: ObsWhereInput
  }

  /**
   * Obs upsert
   */
  export type ObsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * The filter to search for the Obs to update in case it exists.
     */
    where: ObsWhereUniqueInput
    /**
     * In case the Obs found by the `where` argument doesn't exist, create a new Obs with this data.
     */
    create: XOR<ObsCreateInput, ObsUncheckedCreateInput>
    /**
     * In case the Obs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObsUpdateInput, ObsUncheckedUpdateInput>
  }

  /**
   * Obs delete
   */
  export type ObsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    /**
     * Filter which Obs to delete.
     */
    where: ObsWhereUniqueInput
  }

  /**
   * Obs deleteMany
   */
  export type ObsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obs to delete
     */
    where?: ObsWhereInput
  }

  /**
   * Obs without action
   */
  export type ObsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    encounterId: string | null
    orderDatetime: Date | null
    instructions: string | null
    dosage: string | null
    route: string | null
    frequency: string | null
    asNeeded: boolean | null
    prn: boolean | null
    quantity: number | null
    units: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    orderFrequencyId: string | null
    orderRouteId: string | null
    orderTypeId: string | null
    orderUnitId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    encounterId: string | null
    orderDatetime: Date | null
    instructions: string | null
    dosage: string | null
    route: string | null
    frequency: string | null
    asNeeded: boolean | null
    prn: boolean | null
    quantity: number | null
    units: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    orderFrequencyId: string | null
    orderRouteId: string | null
    orderTypeId: string | null
    orderUnitId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    encounterId: number
    orderDatetime: number
    instructions: number
    dosage: number
    route: number
    frequency: number
    asNeeded: number
    prn: number
    quantity: number
    units: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    orderFrequencyId: number
    orderRouteId: number
    orderTypeId: number
    orderUnitId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderSumAggregateInputType = {
    quantity?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    orderDatetime?: true
    instructions?: true
    dosage?: true
    route?: true
    frequency?: true
    asNeeded?: true
    prn?: true
    quantity?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    orderFrequencyId?: true
    orderRouteId?: true
    orderTypeId?: true
    orderUnitId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    orderDatetime?: true
    instructions?: true
    dosage?: true
    route?: true
    frequency?: true
    asNeeded?: true
    prn?: true
    quantity?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    orderFrequencyId?: true
    orderRouteId?: true
    orderTypeId?: true
    orderUnitId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    encounterId?: true
    orderDatetime?: true
    instructions?: true
    dosage?: true
    route?: true
    frequency?: true
    asNeeded?: true
    prn?: true
    quantity?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    orderFrequencyId?: true
    orderRouteId?: true
    orderTypeId?: true
    orderUnitId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded: boolean
    prn: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    orderFrequencyId: string | null
    orderRouteId: string | null
    orderTypeId: string | null
    orderUnitId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    encounterId?: boolean
    orderDatetime?: boolean
    instructions?: boolean
    dosage?: boolean
    route?: boolean
    frequency?: boolean
    asNeeded?: boolean
    prn?: boolean
    quantity?: boolean
    units?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderFrequencyId?: boolean
    orderRouteId?: boolean
    orderTypeId?: boolean
    orderUnitId?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    OrderFrequency?: boolean | Order$OrderFrequencyArgs<ExtArgs>
    OrderRoute?: boolean | Order$OrderRouteArgs<ExtArgs>
    OrderType?: boolean | Order$OrderTypeArgs<ExtArgs>
    OrderUnit?: boolean | Order$OrderUnitArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    encounterId?: boolean
    orderDatetime?: boolean
    instructions?: boolean
    dosage?: boolean
    route?: boolean
    frequency?: boolean
    asNeeded?: boolean
    prn?: boolean
    quantity?: boolean
    units?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderFrequencyId?: boolean
    orderRouteId?: boolean
    orderTypeId?: boolean
    orderUnitId?: boolean
  }


  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    OrderFrequency?: boolean | Order$OrderFrequencyArgs<ExtArgs>
    OrderRoute?: boolean | Order$OrderRouteArgs<ExtArgs>
    OrderType?: boolean | Order$OrderTypeArgs<ExtArgs>
    OrderUnit?: boolean | Order$OrderUnitArgs<ExtArgs>
  }


  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
      OrderFrequency: Prisma.$OrderFrequencyPayload<ExtArgs> | null
      OrderRoute: Prisma.$OrderRoutePayload<ExtArgs> | null
      OrderType: Prisma.$OrderTypePayload<ExtArgs> | null
      OrderUnit: Prisma.$OrderUnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      encounterId: string
      orderDatetime: Date
      instructions: string
      dosage: string
      route: string
      frequency: string
      asNeeded: boolean
      prn: boolean
      quantity: number
      units: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
      orderFrequencyId: string | null
      orderRouteId: string | null
      orderTypeId: string | null
      orderUnitId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    OrderFrequency<T extends Order$OrderFrequencyArgs<ExtArgs> = {}>(args?: Subset<T, Order$OrderFrequencyArgs<ExtArgs>>): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OrderRoute<T extends Order$OrderRouteArgs<ExtArgs> = {}>(args?: Subset<T, Order$OrderRouteArgs<ExtArgs>>): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OrderType<T extends Order$OrderTypeArgs<ExtArgs> = {}>(args?: Subset<T, Order$OrderTypeArgs<ExtArgs>>): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OrderUnit<T extends Order$OrderUnitArgs<ExtArgs> = {}>(args?: Subset<T, Order$OrderUnitArgs<ExtArgs>>): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly uuid: FieldRef<"Order", 'String'>
    readonly conceptId: FieldRef<"Order", 'String'>
    readonly encounterId: FieldRef<"Order", 'String'>
    readonly orderDatetime: FieldRef<"Order", 'DateTime'>
    readonly instructions: FieldRef<"Order", 'String'>
    readonly dosage: FieldRef<"Order", 'String'>
    readonly route: FieldRef<"Order", 'String'>
    readonly frequency: FieldRef<"Order", 'String'>
    readonly asNeeded: FieldRef<"Order", 'Boolean'>
    readonly prn: FieldRef<"Order", 'Boolean'>
    readonly quantity: FieldRef<"Order", 'Int'>
    readonly units: FieldRef<"Order", 'String'>
    readonly creator: FieldRef<"Order", 'String'>
    readonly dateCreated: FieldRef<"Order", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Order", 'String'>
    readonly lastChangedDate: FieldRef<"Order", 'DateTime'>
    readonly orderFrequencyId: FieldRef<"Order", 'String'>
    readonly orderRouteId: FieldRef<"Order", 'String'>
    readonly orderTypeId: FieldRef<"Order", 'String'>
    readonly orderUnitId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.OrderFrequency
   */
  export type Order$OrderFrequencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    where?: OrderFrequencyWhereInput
  }

  /**
   * Order.OrderRoute
   */
  export type Order$OrderRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    where?: OrderRouteWhereInput
  }

  /**
   * Order.OrderType
   */
  export type Order$OrderTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    where?: OrderTypeWhereInput
  }

  /**
   * Order.OrderUnit
   */
  export type Order$OrderUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    where?: OrderUnitWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderFrequency
   */

  export type AggregateOrderFrequency = {
    _count: OrderFrequencyCountAggregateOutputType | null
    _min: OrderFrequencyMinAggregateOutputType | null
    _max: OrderFrequencyMaxAggregateOutputType | null
  }

  export type OrderFrequencyMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderFrequencyMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderFrequencyCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type OrderFrequencyMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderFrequencyMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderFrequencyCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type OrderFrequencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderFrequency to aggregate.
     */
    where?: OrderFrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderFrequencies to fetch.
     */
    orderBy?: OrderFrequencyOrderByWithRelationInput | OrderFrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderFrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderFrequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderFrequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderFrequencies
    **/
    _count?: true | OrderFrequencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderFrequencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderFrequencyMaxAggregateInputType
  }

  export type GetOrderFrequencyAggregateType<T extends OrderFrequencyAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderFrequency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderFrequency[P]>
      : GetScalarType<T[P], AggregateOrderFrequency[P]>
  }




  export type OrderFrequencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderFrequencyWhereInput
    orderBy?: OrderFrequencyOrderByWithAggregationInput | OrderFrequencyOrderByWithAggregationInput[]
    by: OrderFrequencyScalarFieldEnum[] | OrderFrequencyScalarFieldEnum
    having?: OrderFrequencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderFrequencyCountAggregateInputType | true
    _min?: OrderFrequencyMinAggregateInputType
    _max?: OrderFrequencyMaxAggregateInputType
  }

  export type OrderFrequencyGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: OrderFrequencyCountAggregateOutputType | null
    _min: OrderFrequencyMinAggregateOutputType | null
    _max: OrderFrequencyMaxAggregateOutputType | null
  }

  type GetOrderFrequencyGroupByPayload<T extends OrderFrequencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderFrequencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderFrequencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderFrequencyGroupByOutputType[P]>
            : GetScalarType<T[P], OrderFrequencyGroupByOutputType[P]>
        }
      >
    >


  export type OrderFrequencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderList?: boolean | OrderFrequency$orderListArgs<ExtArgs>
    _count?: boolean | OrderFrequencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderFrequency"]>

  export type OrderFrequencySelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type OrderFrequencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderFrequency$orderListArgs<ExtArgs>
    _count?: boolean | OrderFrequencyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderFrequencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderFrequency"
    objects: {
      orderList: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["orderFrequency"]>
    composites: {}
  }


  type OrderFrequencyGetPayload<S extends boolean | null | undefined | OrderFrequencyDefaultArgs> = $Result.GetResult<Prisma.$OrderFrequencyPayload, S>

  type OrderFrequencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFrequencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderFrequencyCountAggregateInputType | true
    }

  export interface OrderFrequencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderFrequency'], meta: { name: 'OrderFrequency' } }
    /**
     * Find zero or one OrderFrequency that matches the filter.
     * @param {OrderFrequencyFindUniqueArgs} args - Arguments to find a OrderFrequency
     * @example
     * // Get one OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFrequencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderFrequency that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFrequencyFindUniqueOrThrowArgs} args - Arguments to find a OrderFrequency
     * @example
     * // Get one OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFrequencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderFrequency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyFindFirstArgs} args - Arguments to find a OrderFrequency
     * @example
     * // Get one OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFrequencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyFindFirstArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderFrequency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyFindFirstOrThrowArgs} args - Arguments to find a OrderFrequency
     * @example
     * // Get one OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFrequencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderFrequencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderFrequencies
     * const orderFrequencies = await prisma.orderFrequency.findMany()
     * 
     * // Get first 10 OrderFrequencies
     * const orderFrequencies = await prisma.orderFrequency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderFrequencyWithIdOnly = await prisma.orderFrequency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFrequencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderFrequency.
     * @param {OrderFrequencyCreateArgs} args - Arguments to create a OrderFrequency.
     * @example
     * // Create one OrderFrequency
     * const OrderFrequency = await prisma.orderFrequency.create({
     *   data: {
     *     // ... data to create a OrderFrequency
     *   }
     * })
     * 
    **/
    create<T extends OrderFrequencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyCreateArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderFrequencies.
     *     @param {OrderFrequencyCreateManyArgs} args - Arguments to create many OrderFrequencies.
     *     @example
     *     // Create many OrderFrequencies
     *     const orderFrequency = await prisma.orderFrequency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderFrequencyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderFrequency.
     * @param {OrderFrequencyDeleteArgs} args - Arguments to delete one OrderFrequency.
     * @example
     * // Delete one OrderFrequency
     * const OrderFrequency = await prisma.orderFrequency.delete({
     *   where: {
     *     // ... filter to delete one OrderFrequency
     *   }
     * })
     * 
    **/
    delete<T extends OrderFrequencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyDeleteArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderFrequency.
     * @param {OrderFrequencyUpdateArgs} args - Arguments to update one OrderFrequency.
     * @example
     * // Update one OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderFrequencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyUpdateArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderFrequencies.
     * @param {OrderFrequencyDeleteManyArgs} args - Arguments to filter OrderFrequencies to delete.
     * @example
     * // Delete a few OrderFrequencies
     * const { count } = await prisma.orderFrequency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderFrequencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFrequencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderFrequencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderFrequencies
     * const orderFrequency = await prisma.orderFrequency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderFrequencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderFrequency.
     * @param {OrderFrequencyUpsertArgs} args - Arguments to update or create a OrderFrequency.
     * @example
     * // Update or create a OrderFrequency
     * const orderFrequency = await prisma.orderFrequency.upsert({
     *   create: {
     *     // ... data to create a OrderFrequency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderFrequency we want to update
     *   }
     * })
    **/
    upsert<T extends OrderFrequencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderFrequencyUpsertArgs<ExtArgs>>
    ): Prisma__OrderFrequencyClient<$Result.GetResult<Prisma.$OrderFrequencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderFrequencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyCountArgs} args - Arguments to filter OrderFrequencies to count.
     * @example
     * // Count the number of OrderFrequencies
     * const count = await prisma.orderFrequency.count({
     *   where: {
     *     // ... the filter for the OrderFrequencies we want to count
     *   }
     * })
    **/
    count<T extends OrderFrequencyCountArgs>(
      args?: Subset<T, OrderFrequencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderFrequencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderFrequency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderFrequencyAggregateArgs>(args: Subset<T, OrderFrequencyAggregateArgs>): Prisma.PrismaPromise<GetOrderFrequencyAggregateType<T>>

    /**
     * Group by OrderFrequency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFrequencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderFrequencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderFrequencyGroupByArgs['orderBy'] }
        : { orderBy?: OrderFrequencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderFrequencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderFrequencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderFrequency model
   */
  readonly fields: OrderFrequencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderFrequency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderFrequencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderList<T extends OrderFrequency$orderListArgs<ExtArgs> = {}>(args?: Subset<T, OrderFrequency$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderFrequency model
   */ 
  interface OrderFrequencyFieldRefs {
    readonly id: FieldRef<"OrderFrequency", 'String'>
    readonly uuid: FieldRef<"OrderFrequency", 'String'>
    readonly name: FieldRef<"OrderFrequency", 'String'>
    readonly description: FieldRef<"OrderFrequency", 'String'>
    readonly creator: FieldRef<"OrderFrequency", 'String'>
    readonly dateCreated: FieldRef<"OrderFrequency", 'DateTime'>
    readonly lastChangedBy: FieldRef<"OrderFrequency", 'String'>
    readonly lastChangedDate: FieldRef<"OrderFrequency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderFrequency findUnique
   */
  export type OrderFrequencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter, which OrderFrequency to fetch.
     */
    where: OrderFrequencyWhereUniqueInput
  }

  /**
   * OrderFrequency findUniqueOrThrow
   */
  export type OrderFrequencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter, which OrderFrequency to fetch.
     */
    where: OrderFrequencyWhereUniqueInput
  }

  /**
   * OrderFrequency findFirst
   */
  export type OrderFrequencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter, which OrderFrequency to fetch.
     */
    where?: OrderFrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderFrequencies to fetch.
     */
    orderBy?: OrderFrequencyOrderByWithRelationInput | OrderFrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderFrequencies.
     */
    cursor?: OrderFrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderFrequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderFrequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderFrequencies.
     */
    distinct?: OrderFrequencyScalarFieldEnum | OrderFrequencyScalarFieldEnum[]
  }

  /**
   * OrderFrequency findFirstOrThrow
   */
  export type OrderFrequencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter, which OrderFrequency to fetch.
     */
    where?: OrderFrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderFrequencies to fetch.
     */
    orderBy?: OrderFrequencyOrderByWithRelationInput | OrderFrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderFrequencies.
     */
    cursor?: OrderFrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderFrequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderFrequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderFrequencies.
     */
    distinct?: OrderFrequencyScalarFieldEnum | OrderFrequencyScalarFieldEnum[]
  }

  /**
   * OrderFrequency findMany
   */
  export type OrderFrequencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter, which OrderFrequencies to fetch.
     */
    where?: OrderFrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderFrequencies to fetch.
     */
    orderBy?: OrderFrequencyOrderByWithRelationInput | OrderFrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderFrequencies.
     */
    cursor?: OrderFrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderFrequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderFrequencies.
     */
    skip?: number
    distinct?: OrderFrequencyScalarFieldEnum | OrderFrequencyScalarFieldEnum[]
  }

  /**
   * OrderFrequency create
   */
  export type OrderFrequencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderFrequency.
     */
    data: XOR<OrderFrequencyCreateInput, OrderFrequencyUncheckedCreateInput>
  }

  /**
   * OrderFrequency createMany
   */
  export type OrderFrequencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderFrequencies.
     */
    data: OrderFrequencyCreateManyInput | OrderFrequencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderFrequency update
   */
  export type OrderFrequencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderFrequency.
     */
    data: XOR<OrderFrequencyUpdateInput, OrderFrequencyUncheckedUpdateInput>
    /**
     * Choose, which OrderFrequency to update.
     */
    where: OrderFrequencyWhereUniqueInput
  }

  /**
   * OrderFrequency updateMany
   */
  export type OrderFrequencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderFrequencies.
     */
    data: XOR<OrderFrequencyUpdateManyMutationInput, OrderFrequencyUncheckedUpdateManyInput>
    /**
     * Filter which OrderFrequencies to update
     */
    where?: OrderFrequencyWhereInput
  }

  /**
   * OrderFrequency upsert
   */
  export type OrderFrequencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderFrequency to update in case it exists.
     */
    where: OrderFrequencyWhereUniqueInput
    /**
     * In case the OrderFrequency found by the `where` argument doesn't exist, create a new OrderFrequency with this data.
     */
    create: XOR<OrderFrequencyCreateInput, OrderFrequencyUncheckedCreateInput>
    /**
     * In case the OrderFrequency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderFrequencyUpdateInput, OrderFrequencyUncheckedUpdateInput>
  }

  /**
   * OrderFrequency delete
   */
  export type OrderFrequencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
    /**
     * Filter which OrderFrequency to delete.
     */
    where: OrderFrequencyWhereUniqueInput
  }

  /**
   * OrderFrequency deleteMany
   */
  export type OrderFrequencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderFrequencies to delete
     */
    where?: OrderFrequencyWhereInput
  }

  /**
   * OrderFrequency.orderList
   */
  export type OrderFrequency$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderFrequency without action
   */
  export type OrderFrequencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderFrequency
     */
    select?: OrderFrequencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderFrequencyInclude<ExtArgs> | null
  }


  /**
   * Model OrderRoute
   */

  export type AggregateOrderRoute = {
    _count: OrderRouteCountAggregateOutputType | null
    _min: OrderRouteMinAggregateOutputType | null
    _max: OrderRouteMaxAggregateOutputType | null
  }

  export type OrderRouteMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderRouteMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderRouteCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type OrderRouteMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderRouteMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderRouteCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type OrderRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderRoute to aggregate.
     */
    where?: OrderRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRoutes to fetch.
     */
    orderBy?: OrderRouteOrderByWithRelationInput | OrderRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderRoutes
    **/
    _count?: true | OrderRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderRouteMaxAggregateInputType
  }

  export type GetOrderRouteAggregateType<T extends OrderRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderRoute[P]>
      : GetScalarType<T[P], AggregateOrderRoute[P]>
  }




  export type OrderRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderRouteWhereInput
    orderBy?: OrderRouteOrderByWithAggregationInput | OrderRouteOrderByWithAggregationInput[]
    by: OrderRouteScalarFieldEnum[] | OrderRouteScalarFieldEnum
    having?: OrderRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderRouteCountAggregateInputType | true
    _min?: OrderRouteMinAggregateInputType
    _max?: OrderRouteMaxAggregateInputType
  }

  export type OrderRouteGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: OrderRouteCountAggregateOutputType | null
    _min: OrderRouteMinAggregateOutputType | null
    _max: OrderRouteMaxAggregateOutputType | null
  }

  type GetOrderRouteGroupByPayload<T extends OrderRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderRouteGroupByOutputType[P]>
            : GetScalarType<T[P], OrderRouteGroupByOutputType[P]>
        }
      >
    >


  export type OrderRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderList?: boolean | OrderRoute$orderListArgs<ExtArgs>
    _count?: boolean | OrderRouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderRoute"]>

  export type OrderRouteSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type OrderRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderRoute$orderListArgs<ExtArgs>
    _count?: boolean | OrderRouteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderRoute"
    objects: {
      orderList: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["orderRoute"]>
    composites: {}
  }


  type OrderRouteGetPayload<S extends boolean | null | undefined | OrderRouteDefaultArgs> = $Result.GetResult<Prisma.$OrderRoutePayload, S>

  type OrderRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderRouteCountAggregateInputType | true
    }

  export interface OrderRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderRoute'], meta: { name: 'OrderRoute' } }
    /**
     * Find zero or one OrderRoute that matches the filter.
     * @param {OrderRouteFindUniqueArgs} args - Arguments to find a OrderRoute
     * @example
     * // Get one OrderRoute
     * const orderRoute = await prisma.orderRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderRouteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderRoute that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderRouteFindUniqueOrThrowArgs} args - Arguments to find a OrderRoute
     * @example
     * // Get one OrderRoute
     * const orderRoute = await prisma.orderRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderRouteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteFindFirstArgs} args - Arguments to find a OrderRoute
     * @example
     * // Get one OrderRoute
     * const orderRoute = await prisma.orderRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderRouteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteFindFirstArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteFindFirstOrThrowArgs} args - Arguments to find a OrderRoute
     * @example
     * // Get one OrderRoute
     * const orderRoute = await prisma.orderRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderRouteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderRoutes
     * const orderRoutes = await prisma.orderRoute.findMany()
     * 
     * // Get first 10 OrderRoutes
     * const orderRoutes = await prisma.orderRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderRouteWithIdOnly = await prisma.orderRoute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderRouteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderRoute.
     * @param {OrderRouteCreateArgs} args - Arguments to create a OrderRoute.
     * @example
     * // Create one OrderRoute
     * const OrderRoute = await prisma.orderRoute.create({
     *   data: {
     *     // ... data to create a OrderRoute
     *   }
     * })
     * 
    **/
    create<T extends OrderRouteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteCreateArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderRoutes.
     *     @param {OrderRouteCreateManyArgs} args - Arguments to create many OrderRoutes.
     *     @example
     *     // Create many OrderRoutes
     *     const orderRoute = await prisma.orderRoute.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderRouteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderRoute.
     * @param {OrderRouteDeleteArgs} args - Arguments to delete one OrderRoute.
     * @example
     * // Delete one OrderRoute
     * const OrderRoute = await prisma.orderRoute.delete({
     *   where: {
     *     // ... filter to delete one OrderRoute
     *   }
     * })
     * 
    **/
    delete<T extends OrderRouteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteDeleteArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderRoute.
     * @param {OrderRouteUpdateArgs} args - Arguments to update one OrderRoute.
     * @example
     * // Update one OrderRoute
     * const orderRoute = await prisma.orderRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderRouteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteUpdateArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderRoutes.
     * @param {OrderRouteDeleteManyArgs} args - Arguments to filter OrderRoutes to delete.
     * @example
     * // Delete a few OrderRoutes
     * const { count } = await prisma.orderRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderRouteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderRouteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderRoutes
     * const orderRoute = await prisma.orderRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderRouteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderRoute.
     * @param {OrderRouteUpsertArgs} args - Arguments to update or create a OrderRoute.
     * @example
     * // Update or create a OrderRoute
     * const orderRoute = await prisma.orderRoute.upsert({
     *   create: {
     *     // ... data to create a OrderRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderRoute we want to update
     *   }
     * })
    **/
    upsert<T extends OrderRouteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderRouteUpsertArgs<ExtArgs>>
    ): Prisma__OrderRouteClient<$Result.GetResult<Prisma.$OrderRoutePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteCountArgs} args - Arguments to filter OrderRoutes to count.
     * @example
     * // Count the number of OrderRoutes
     * const count = await prisma.orderRoute.count({
     *   where: {
     *     // ... the filter for the OrderRoutes we want to count
     *   }
     * })
    **/
    count<T extends OrderRouteCountArgs>(
      args?: Subset<T, OrderRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderRouteAggregateArgs>(args: Subset<T, OrderRouteAggregateArgs>): Prisma.PrismaPromise<GetOrderRouteAggregateType<T>>

    /**
     * Group by OrderRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderRouteGroupByArgs['orderBy'] }
        : { orderBy?: OrderRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderRoute model
   */
  readonly fields: OrderRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderList<T extends OrderRoute$orderListArgs<ExtArgs> = {}>(args?: Subset<T, OrderRoute$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderRoute model
   */ 
  interface OrderRouteFieldRefs {
    readonly id: FieldRef<"OrderRoute", 'String'>
    readonly uuid: FieldRef<"OrderRoute", 'String'>
    readonly name: FieldRef<"OrderRoute", 'String'>
    readonly description: FieldRef<"OrderRoute", 'String'>
    readonly creator: FieldRef<"OrderRoute", 'String'>
    readonly dateCreated: FieldRef<"OrderRoute", 'DateTime'>
    readonly lastChangedBy: FieldRef<"OrderRoute", 'String'>
    readonly lastChangedDate: FieldRef<"OrderRoute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderRoute findUnique
   */
  export type OrderRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter, which OrderRoute to fetch.
     */
    where: OrderRouteWhereUniqueInput
  }

  /**
   * OrderRoute findUniqueOrThrow
   */
  export type OrderRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter, which OrderRoute to fetch.
     */
    where: OrderRouteWhereUniqueInput
  }

  /**
   * OrderRoute findFirst
   */
  export type OrderRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter, which OrderRoute to fetch.
     */
    where?: OrderRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRoutes to fetch.
     */
    orderBy?: OrderRouteOrderByWithRelationInput | OrderRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderRoutes.
     */
    cursor?: OrderRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderRoutes.
     */
    distinct?: OrderRouteScalarFieldEnum | OrderRouteScalarFieldEnum[]
  }

  /**
   * OrderRoute findFirstOrThrow
   */
  export type OrderRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter, which OrderRoute to fetch.
     */
    where?: OrderRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRoutes to fetch.
     */
    orderBy?: OrderRouteOrderByWithRelationInput | OrderRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderRoutes.
     */
    cursor?: OrderRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderRoutes.
     */
    distinct?: OrderRouteScalarFieldEnum | OrderRouteScalarFieldEnum[]
  }

  /**
   * OrderRoute findMany
   */
  export type OrderRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter, which OrderRoutes to fetch.
     */
    where?: OrderRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderRoutes to fetch.
     */
    orderBy?: OrderRouteOrderByWithRelationInput | OrderRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderRoutes.
     */
    cursor?: OrderRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderRoutes.
     */
    skip?: number
    distinct?: OrderRouteScalarFieldEnum | OrderRouteScalarFieldEnum[]
  }

  /**
   * OrderRoute create
   */
  export type OrderRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderRoute.
     */
    data: XOR<OrderRouteCreateInput, OrderRouteUncheckedCreateInput>
  }

  /**
   * OrderRoute createMany
   */
  export type OrderRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderRoutes.
     */
    data: OrderRouteCreateManyInput | OrderRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderRoute update
   */
  export type OrderRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderRoute.
     */
    data: XOR<OrderRouteUpdateInput, OrderRouteUncheckedUpdateInput>
    /**
     * Choose, which OrderRoute to update.
     */
    where: OrderRouteWhereUniqueInput
  }

  /**
   * OrderRoute updateMany
   */
  export type OrderRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderRoutes.
     */
    data: XOR<OrderRouteUpdateManyMutationInput, OrderRouteUncheckedUpdateManyInput>
    /**
     * Filter which OrderRoutes to update
     */
    where?: OrderRouteWhereInput
  }

  /**
   * OrderRoute upsert
   */
  export type OrderRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderRoute to update in case it exists.
     */
    where: OrderRouteWhereUniqueInput
    /**
     * In case the OrderRoute found by the `where` argument doesn't exist, create a new OrderRoute with this data.
     */
    create: XOR<OrderRouteCreateInput, OrderRouteUncheckedCreateInput>
    /**
     * In case the OrderRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderRouteUpdateInput, OrderRouteUncheckedUpdateInput>
  }

  /**
   * OrderRoute delete
   */
  export type OrderRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
    /**
     * Filter which OrderRoute to delete.
     */
    where: OrderRouteWhereUniqueInput
  }

  /**
   * OrderRoute deleteMany
   */
  export type OrderRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderRoutes to delete
     */
    where?: OrderRouteWhereInput
  }

  /**
   * OrderRoute.orderList
   */
  export type OrderRoute$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderRoute without action
   */
  export type OrderRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderRoute
     */
    select?: OrderRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderRouteInclude<ExtArgs> | null
  }


  /**
   * Model OrderType
   */

  export type AggregateOrderType = {
    _count: OrderTypeCountAggregateOutputType | null
    _min: OrderTypeMinAggregateOutputType | null
    _max: OrderTypeMaxAggregateOutputType | null
  }

  export type OrderTypeMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderTypeMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderTypeCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type OrderTypeMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderTypeMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderTypeCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type OrderTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderType to aggregate.
     */
    where?: OrderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTypes to fetch.
     */
    orderBy?: OrderTypeOrderByWithRelationInput | OrderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderTypes
    **/
    _count?: true | OrderTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTypeMaxAggregateInputType
  }

  export type GetOrderTypeAggregateType<T extends OrderTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderType[P]>
      : GetScalarType<T[P], AggregateOrderType[P]>
  }




  export type OrderTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTypeWhereInput
    orderBy?: OrderTypeOrderByWithAggregationInput | OrderTypeOrderByWithAggregationInput[]
    by: OrderTypeScalarFieldEnum[] | OrderTypeScalarFieldEnum
    having?: OrderTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTypeCountAggregateInputType | true
    _min?: OrderTypeMinAggregateInputType
    _max?: OrderTypeMaxAggregateInputType
  }

  export type OrderTypeGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: OrderTypeCountAggregateOutputType | null
    _min: OrderTypeMinAggregateOutputType | null
    _max: OrderTypeMaxAggregateOutputType | null
  }

  type GetOrderTypeGroupByPayload<T extends OrderTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderTypeGroupByOutputType[P]>
            : GetScalarType<T[P], OrderTypeGroupByOutputType[P]>
        }
      >
    >


  export type OrderTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderList?: boolean | OrderType$orderListArgs<ExtArgs>
    _count?: boolean | OrderTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderType"]>

  export type OrderTypeSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type OrderTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderType$orderListArgs<ExtArgs>
    _count?: boolean | OrderTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderType"
    objects: {
      orderList: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["orderType"]>
    composites: {}
  }


  type OrderTypeGetPayload<S extends boolean | null | undefined | OrderTypeDefaultArgs> = $Result.GetResult<Prisma.$OrderTypePayload, S>

  type OrderTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderTypeCountAggregateInputType | true
    }

  export interface OrderTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderType'], meta: { name: 'OrderType' } }
    /**
     * Find zero or one OrderType that matches the filter.
     * @param {OrderTypeFindUniqueArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderTypeFindUniqueOrThrowArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeFindFirstArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeFindFirstArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeFindFirstOrThrowArgs} args - Arguments to find a OrderType
     * @example
     * // Get one OrderType
     * const orderType = await prisma.orderType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTypes
     * const orderTypes = await prisma.orderType.findMany()
     * 
     * // Get first 10 OrderTypes
     * const orderTypes = await prisma.orderType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderTypeWithIdOnly = await prisma.orderType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderType.
     * @param {OrderTypeCreateArgs} args - Arguments to create a OrderType.
     * @example
     * // Create one OrderType
     * const OrderType = await prisma.orderType.create({
     *   data: {
     *     // ... data to create a OrderType
     *   }
     * })
     * 
    **/
    create<T extends OrderTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeCreateArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderTypes.
     *     @param {OrderTypeCreateManyArgs} args - Arguments to create many OrderTypes.
     *     @example
     *     // Create many OrderTypes
     *     const orderType = await prisma.orderType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderType.
     * @param {OrderTypeDeleteArgs} args - Arguments to delete one OrderType.
     * @example
     * // Delete one OrderType
     * const OrderType = await prisma.orderType.delete({
     *   where: {
     *     // ... filter to delete one OrderType
     *   }
     * })
     * 
    **/
    delete<T extends OrderTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeDeleteArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderType.
     * @param {OrderTypeUpdateArgs} args - Arguments to update one OrderType.
     * @example
     * // Update one OrderType
     * const orderType = await prisma.orderType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeUpdateArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderTypes.
     * @param {OrderTypeDeleteManyArgs} args - Arguments to filter OrderTypes to delete.
     * @example
     * // Delete a few OrderTypes
     * const { count } = await prisma.orderType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTypes
     * const orderType = await prisma.orderType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderType.
     * @param {OrderTypeUpsertArgs} args - Arguments to update or create a OrderType.
     * @example
     * // Update or create a OrderType
     * const orderType = await prisma.orderType.upsert({
     *   create: {
     *     // ... data to create a OrderType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderType we want to update
     *   }
     * })
    **/
    upsert<T extends OrderTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderTypeUpsertArgs<ExtArgs>>
    ): Prisma__OrderTypeClient<$Result.GetResult<Prisma.$OrderTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeCountArgs} args - Arguments to filter OrderTypes to count.
     * @example
     * // Count the number of OrderTypes
     * const count = await prisma.orderType.count({
     *   where: {
     *     // ... the filter for the OrderTypes we want to count
     *   }
     * })
    **/
    count<T extends OrderTypeCountArgs>(
      args?: Subset<T, OrderTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTypeAggregateArgs>(args: Subset<T, OrderTypeAggregateArgs>): Prisma.PrismaPromise<GetOrderTypeAggregateType<T>>

    /**
     * Group by OrderType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderTypeGroupByArgs['orderBy'] }
        : { orderBy?: OrderTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderType model
   */
  readonly fields: OrderTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderList<T extends OrderType$orderListArgs<ExtArgs> = {}>(args?: Subset<T, OrderType$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderType model
   */ 
  interface OrderTypeFieldRefs {
    readonly id: FieldRef<"OrderType", 'String'>
    readonly uuid: FieldRef<"OrderType", 'String'>
    readonly name: FieldRef<"OrderType", 'String'>
    readonly description: FieldRef<"OrderType", 'String'>
    readonly creator: FieldRef<"OrderType", 'String'>
    readonly dateCreated: FieldRef<"OrderType", 'DateTime'>
    readonly lastChangedBy: FieldRef<"OrderType", 'String'>
    readonly lastChangedDate: FieldRef<"OrderType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderType findUnique
   */
  export type OrderTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter, which OrderType to fetch.
     */
    where: OrderTypeWhereUniqueInput
  }

  /**
   * OrderType findUniqueOrThrow
   */
  export type OrderTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter, which OrderType to fetch.
     */
    where: OrderTypeWhereUniqueInput
  }

  /**
   * OrderType findFirst
   */
  export type OrderTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter, which OrderType to fetch.
     */
    where?: OrderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTypes to fetch.
     */
    orderBy?: OrderTypeOrderByWithRelationInput | OrderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTypes.
     */
    cursor?: OrderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTypes.
     */
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * OrderType findFirstOrThrow
   */
  export type OrderTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter, which OrderType to fetch.
     */
    where?: OrderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTypes to fetch.
     */
    orderBy?: OrderTypeOrderByWithRelationInput | OrderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTypes.
     */
    cursor?: OrderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTypes.
     */
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * OrderType findMany
   */
  export type OrderTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter, which OrderTypes to fetch.
     */
    where?: OrderTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTypes to fetch.
     */
    orderBy?: OrderTypeOrderByWithRelationInput | OrderTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderTypes.
     */
    cursor?: OrderTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTypes.
     */
    skip?: number
    distinct?: OrderTypeScalarFieldEnum | OrderTypeScalarFieldEnum[]
  }

  /**
   * OrderType create
   */
  export type OrderTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderType.
     */
    data: XOR<OrderTypeCreateInput, OrderTypeUncheckedCreateInput>
  }

  /**
   * OrderType createMany
   */
  export type OrderTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderTypes.
     */
    data: OrderTypeCreateManyInput | OrderTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderType update
   */
  export type OrderTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderType.
     */
    data: XOR<OrderTypeUpdateInput, OrderTypeUncheckedUpdateInput>
    /**
     * Choose, which OrderType to update.
     */
    where: OrderTypeWhereUniqueInput
  }

  /**
   * OrderType updateMany
   */
  export type OrderTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderTypes.
     */
    data: XOR<OrderTypeUpdateManyMutationInput, OrderTypeUncheckedUpdateManyInput>
    /**
     * Filter which OrderTypes to update
     */
    where?: OrderTypeWhereInput
  }

  /**
   * OrderType upsert
   */
  export type OrderTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderType to update in case it exists.
     */
    where: OrderTypeWhereUniqueInput
    /**
     * In case the OrderType found by the `where` argument doesn't exist, create a new OrderType with this data.
     */
    create: XOR<OrderTypeCreateInput, OrderTypeUncheckedCreateInput>
    /**
     * In case the OrderType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderTypeUpdateInput, OrderTypeUncheckedUpdateInput>
  }

  /**
   * OrderType delete
   */
  export type OrderTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
    /**
     * Filter which OrderType to delete.
     */
    where: OrderTypeWhereUniqueInput
  }

  /**
   * OrderType deleteMany
   */
  export type OrderTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderTypes to delete
     */
    where?: OrderTypeWhereInput
  }

  /**
   * OrderType.orderList
   */
  export type OrderType$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderType without action
   */
  export type OrderTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderType
     */
    select?: OrderTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTypeInclude<ExtArgs> | null
  }


  /**
   * Model OrderUnit
   */

  export type AggregateOrderUnit = {
    _count: OrderUnitCountAggregateOutputType | null
    _min: OrderUnitMinAggregateOutputType | null
    _max: OrderUnitMaxAggregateOutputType | null
  }

  export type OrderUnitMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderUnitMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type OrderUnitCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type OrderUnitMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderUnitMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type OrderUnitCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type OrderUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderUnit to aggregate.
     */
    where?: OrderUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderUnits to fetch.
     */
    orderBy?: OrderUnitOrderByWithRelationInput | OrderUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderUnits
    **/
    _count?: true | OrderUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderUnitMaxAggregateInputType
  }

  export type GetOrderUnitAggregateType<T extends OrderUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderUnit[P]>
      : GetScalarType<T[P], AggregateOrderUnit[P]>
  }




  export type OrderUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderUnitWhereInput
    orderBy?: OrderUnitOrderByWithAggregationInput | OrderUnitOrderByWithAggregationInput[]
    by: OrderUnitScalarFieldEnum[] | OrderUnitScalarFieldEnum
    having?: OrderUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderUnitCountAggregateInputType | true
    _min?: OrderUnitMinAggregateInputType
    _max?: OrderUnitMaxAggregateInputType
  }

  export type OrderUnitGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: OrderUnitCountAggregateOutputType | null
    _min: OrderUnitMinAggregateOutputType | null
    _max: OrderUnitMaxAggregateOutputType | null
  }

  type GetOrderUnitGroupByPayload<T extends OrderUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderUnitGroupByOutputType[P]>
            : GetScalarType<T[P], OrderUnitGroupByOutputType[P]>
        }
      >
    >


  export type OrderUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    orderList?: boolean | OrderUnit$orderListArgs<ExtArgs>
    _count?: boolean | OrderUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderUnit"]>

  export type OrderUnitSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type OrderUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderList?: boolean | OrderUnit$orderListArgs<ExtArgs>
    _count?: boolean | OrderUnitCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderUnit"
    objects: {
      orderList: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["orderUnit"]>
    composites: {}
  }


  type OrderUnitGetPayload<S extends boolean | null | undefined | OrderUnitDefaultArgs> = $Result.GetResult<Prisma.$OrderUnitPayload, S>

  type OrderUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderUnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderUnitCountAggregateInputType | true
    }

  export interface OrderUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderUnit'], meta: { name: 'OrderUnit' } }
    /**
     * Find zero or one OrderUnit that matches the filter.
     * @param {OrderUnitFindUniqueArgs} args - Arguments to find a OrderUnit
     * @example
     * // Get one OrderUnit
     * const orderUnit = await prisma.orderUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderUnitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderUnit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderUnitFindUniqueOrThrowArgs} args - Arguments to find a OrderUnit
     * @example
     * // Get one OrderUnit
     * const orderUnit = await prisma.orderUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderUnitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitFindFirstArgs} args - Arguments to find a OrderUnit
     * @example
     * // Get one OrderUnit
     * const orderUnit = await prisma.orderUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderUnitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitFindFirstArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitFindFirstOrThrowArgs} args - Arguments to find a OrderUnit
     * @example
     * // Get one OrderUnit
     * const orderUnit = await prisma.orderUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderUnitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderUnits
     * const orderUnits = await prisma.orderUnit.findMany()
     * 
     * // Get first 10 OrderUnits
     * const orderUnits = await prisma.orderUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderUnitWithIdOnly = await prisma.orderUnit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderUnitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderUnit.
     * @param {OrderUnitCreateArgs} args - Arguments to create a OrderUnit.
     * @example
     * // Create one OrderUnit
     * const OrderUnit = await prisma.orderUnit.create({
     *   data: {
     *     // ... data to create a OrderUnit
     *   }
     * })
     * 
    **/
    create<T extends OrderUnitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitCreateArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderUnits.
     *     @param {OrderUnitCreateManyArgs} args - Arguments to create many OrderUnits.
     *     @example
     *     // Create many OrderUnits
     *     const orderUnit = await prisma.orderUnit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderUnitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderUnit.
     * @param {OrderUnitDeleteArgs} args - Arguments to delete one OrderUnit.
     * @example
     * // Delete one OrderUnit
     * const OrderUnit = await prisma.orderUnit.delete({
     *   where: {
     *     // ... filter to delete one OrderUnit
     *   }
     * })
     * 
    **/
    delete<T extends OrderUnitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitDeleteArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderUnit.
     * @param {OrderUnitUpdateArgs} args - Arguments to update one OrderUnit.
     * @example
     * // Update one OrderUnit
     * const orderUnit = await prisma.orderUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUnitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitUpdateArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderUnits.
     * @param {OrderUnitDeleteManyArgs} args - Arguments to filter OrderUnits to delete.
     * @example
     * // Delete a few OrderUnits
     * const { count } = await prisma.orderUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderUnitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderUnitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderUnits
     * const orderUnit = await prisma.orderUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUnitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderUnit.
     * @param {OrderUnitUpsertArgs} args - Arguments to update or create a OrderUnit.
     * @example
     * // Update or create a OrderUnit
     * const orderUnit = await prisma.orderUnit.upsert({
     *   create: {
     *     // ... data to create a OrderUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderUnit we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUnitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUnitUpsertArgs<ExtArgs>>
    ): Prisma__OrderUnitClient<$Result.GetResult<Prisma.$OrderUnitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitCountArgs} args - Arguments to filter OrderUnits to count.
     * @example
     * // Count the number of OrderUnits
     * const count = await prisma.orderUnit.count({
     *   where: {
     *     // ... the filter for the OrderUnits we want to count
     *   }
     * })
    **/
    count<T extends OrderUnitCountArgs>(
      args?: Subset<T, OrderUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderUnitAggregateArgs>(args: Subset<T, OrderUnitAggregateArgs>): Prisma.PrismaPromise<GetOrderUnitAggregateType<T>>

    /**
     * Group by OrderUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderUnitGroupByArgs['orderBy'] }
        : { orderBy?: OrderUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderUnit model
   */
  readonly fields: OrderUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderList<T extends OrderUnit$orderListArgs<ExtArgs> = {}>(args?: Subset<T, OrderUnit$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderUnit model
   */ 
  interface OrderUnitFieldRefs {
    readonly id: FieldRef<"OrderUnit", 'String'>
    readonly uuid: FieldRef<"OrderUnit", 'String'>
    readonly name: FieldRef<"OrderUnit", 'String'>
    readonly description: FieldRef<"OrderUnit", 'String'>
    readonly creator: FieldRef<"OrderUnit", 'String'>
    readonly dateCreated: FieldRef<"OrderUnit", 'DateTime'>
    readonly lastChangedBy: FieldRef<"OrderUnit", 'String'>
    readonly lastChangedDate: FieldRef<"OrderUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderUnit findUnique
   */
  export type OrderUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter, which OrderUnit to fetch.
     */
    where: OrderUnitWhereUniqueInput
  }

  /**
   * OrderUnit findUniqueOrThrow
   */
  export type OrderUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter, which OrderUnit to fetch.
     */
    where: OrderUnitWhereUniqueInput
  }

  /**
   * OrderUnit findFirst
   */
  export type OrderUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter, which OrderUnit to fetch.
     */
    where?: OrderUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderUnits to fetch.
     */
    orderBy?: OrderUnitOrderByWithRelationInput | OrderUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderUnits.
     */
    cursor?: OrderUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderUnits.
     */
    distinct?: OrderUnitScalarFieldEnum | OrderUnitScalarFieldEnum[]
  }

  /**
   * OrderUnit findFirstOrThrow
   */
  export type OrderUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter, which OrderUnit to fetch.
     */
    where?: OrderUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderUnits to fetch.
     */
    orderBy?: OrderUnitOrderByWithRelationInput | OrderUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderUnits.
     */
    cursor?: OrderUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderUnits.
     */
    distinct?: OrderUnitScalarFieldEnum | OrderUnitScalarFieldEnum[]
  }

  /**
   * OrderUnit findMany
   */
  export type OrderUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter, which OrderUnits to fetch.
     */
    where?: OrderUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderUnits to fetch.
     */
    orderBy?: OrderUnitOrderByWithRelationInput | OrderUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderUnits.
     */
    cursor?: OrderUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderUnits.
     */
    skip?: number
    distinct?: OrderUnitScalarFieldEnum | OrderUnitScalarFieldEnum[]
  }

  /**
   * OrderUnit create
   */
  export type OrderUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderUnit.
     */
    data: XOR<OrderUnitCreateInput, OrderUnitUncheckedCreateInput>
  }

  /**
   * OrderUnit createMany
   */
  export type OrderUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderUnits.
     */
    data: OrderUnitCreateManyInput | OrderUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderUnit update
   */
  export type OrderUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderUnit.
     */
    data: XOR<OrderUnitUpdateInput, OrderUnitUncheckedUpdateInput>
    /**
     * Choose, which OrderUnit to update.
     */
    where: OrderUnitWhereUniqueInput
  }

  /**
   * OrderUnit updateMany
   */
  export type OrderUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderUnits.
     */
    data: XOR<OrderUnitUpdateManyMutationInput, OrderUnitUncheckedUpdateManyInput>
    /**
     * Filter which OrderUnits to update
     */
    where?: OrderUnitWhereInput
  }

  /**
   * OrderUnit upsert
   */
  export type OrderUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderUnit to update in case it exists.
     */
    where: OrderUnitWhereUniqueInput
    /**
     * In case the OrderUnit found by the `where` argument doesn't exist, create a new OrderUnit with this data.
     */
    create: XOR<OrderUnitCreateInput, OrderUnitUncheckedCreateInput>
    /**
     * In case the OrderUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUnitUpdateInput, OrderUnitUncheckedUpdateInput>
  }

  /**
   * OrderUnit delete
   */
  export type OrderUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
    /**
     * Filter which OrderUnit to delete.
     */
    where: OrderUnitWhereUniqueInput
  }

  /**
   * OrderUnit deleteMany
   */
  export type OrderUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderUnits to delete
     */
    where?: OrderUnitWhereInput
  }

  /**
   * OrderUnit.orderList
   */
  export type OrderUnit$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderUnit without action
   */
  export type OrderUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderUnit
     */
    select?: OrderUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderUnitInclude<ExtArgs> | null
  }


  /**
   * Model Concept
   */

  export type AggregateConcept = {
    _count: ConceptCountAggregateOutputType | null
    _min: ConceptMinAggregateOutputType | null
    _max: ConceptMaxAggregateOutputType | null
  }

  export type ConceptMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    dataType: string | null
    class: string | null
    isRetired: boolean | null
    retiredBy: string | null
    dateRetired: Date | null
    retiredReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    conceptClassId: string | null
    conceptDatatypeId: string | null
    conceptMapId: string | null
    conceptSetId: string | null
    conceptSourceId: string | null
  }

  export type ConceptMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    dataType: string | null
    class: string | null
    isRetired: boolean | null
    retiredBy: string | null
    dateRetired: Date | null
    retiredReason: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
    conceptClassId: string | null
    conceptDatatypeId: string | null
    conceptMapId: string | null
    conceptSetId: string | null
    conceptSourceId: string | null
  }

  export type ConceptCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    dataType: number
    class: number
    isRetired: number
    retiredBy: number
    dateRetired: number
    retiredReason: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    conceptClassId: number
    conceptDatatypeId: number
    conceptMapId: number
    conceptSetId: number
    conceptSourceId: number
    _all: number
  }


  export type ConceptMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    dataType?: true
    class?: true
    isRetired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    conceptClassId?: true
    conceptDatatypeId?: true
    conceptMapId?: true
    conceptSetId?: true
    conceptSourceId?: true
  }

  export type ConceptMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    dataType?: true
    class?: true
    isRetired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    conceptClassId?: true
    conceptDatatypeId?: true
    conceptMapId?: true
    conceptSetId?: true
    conceptSourceId?: true
  }

  export type ConceptCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    dataType?: true
    class?: true
    isRetired?: true
    retiredBy?: true
    dateRetired?: true
    retiredReason?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    conceptClassId?: true
    conceptDatatypeId?: true
    conceptMapId?: true
    conceptSetId?: true
    conceptSourceId?: true
    _all?: true
  }

  export type ConceptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concept to aggregate.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Concepts
    **/
    _count?: true | ConceptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptMaxAggregateInputType
  }

  export type GetConceptAggregateType<T extends ConceptAggregateArgs> = {
        [P in keyof T & keyof AggregateConcept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConcept[P]>
      : GetScalarType<T[P], AggregateConcept[P]>
  }




  export type ConceptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithAggregationInput | ConceptOrderByWithAggregationInput[]
    by: ConceptScalarFieldEnum[] | ConceptScalarFieldEnum
    having?: ConceptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptCountAggregateInputType | true
    _min?: ConceptMinAggregateInputType
    _max?: ConceptMaxAggregateInputType
  }

  export type ConceptGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired: boolean
    retiredBy: string
    dateRetired: Date
    retiredReason: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    conceptClassId: string | null
    conceptDatatypeId: string | null
    conceptMapId: string | null
    conceptSetId: string | null
    conceptSourceId: string | null
    _count: ConceptCountAggregateOutputType | null
    _min: ConceptMinAggregateOutputType | null
    _max: ConceptMaxAggregateOutputType | null
  }

  type GetConceptGroupByPayload<T extends ConceptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptGroupByOutputType[P]>
        }
      >
    >


  export type ConceptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    dataType?: boolean
    class?: boolean
    isRetired?: boolean
    retiredBy?: boolean
    dateRetired?: boolean
    retiredReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptClassId?: boolean
    conceptDatatypeId?: boolean
    conceptMapId?: boolean
    conceptSetId?: boolean
    conceptSourceId?: boolean
    metaList?: boolean | Concept$metaListArgs<ExtArgs>
    answerList?: boolean | Concept$answerListArgs<ExtArgs>
    fieldList?: boolean | Concept$fieldListArgs<ExtArgs>
    obsList?: boolean | Concept$obsListArgs<ExtArgs>
    orderList?: boolean | Concept$orderListArgs<ExtArgs>
    ConceptClass?: boolean | Concept$ConceptClassArgs<ExtArgs>
    ConceptDatatype?: boolean | Concept$ConceptDatatypeArgs<ExtArgs>
    conceptMap?: boolean | Concept$conceptMapArgs<ExtArgs>
    conceptNameList?: boolean | Concept$conceptNameListArgs<ExtArgs>
    conceptNumericList?: boolean | Concept$conceptNumericListArgs<ExtArgs>
    conceptProposalList?: boolean | Concept$conceptProposalListArgs<ExtArgs>
    conceptSet?: boolean | Concept$conceptSetArgs<ExtArgs>
    conceptSource?: boolean | Concept$conceptSourceArgs<ExtArgs>
    conceptWordList?: boolean | Concept$conceptWordListArgs<ExtArgs>
    _count?: boolean | ConceptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concept"]>

  export type ConceptSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    dataType?: boolean
    class?: boolean
    isRetired?: boolean
    retiredBy?: boolean
    dateRetired?: boolean
    retiredReason?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptClassId?: boolean
    conceptDatatypeId?: boolean
    conceptMapId?: boolean
    conceptSetId?: boolean
    conceptSourceId?: boolean
  }


  export type ConceptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaList?: boolean | Concept$metaListArgs<ExtArgs>
    answerList?: boolean | Concept$answerListArgs<ExtArgs>
    fieldList?: boolean | Concept$fieldListArgs<ExtArgs>
    obsList?: boolean | Concept$obsListArgs<ExtArgs>
    orderList?: boolean | Concept$orderListArgs<ExtArgs>
    ConceptClass?: boolean | Concept$ConceptClassArgs<ExtArgs>
    ConceptDatatype?: boolean | Concept$ConceptDatatypeArgs<ExtArgs>
    conceptMap?: boolean | Concept$conceptMapArgs<ExtArgs>
    conceptNameList?: boolean | Concept$conceptNameListArgs<ExtArgs>
    conceptNumericList?: boolean | Concept$conceptNumericListArgs<ExtArgs>
    conceptProposalList?: boolean | Concept$conceptProposalListArgs<ExtArgs>
    conceptSet?: boolean | Concept$conceptSetArgs<ExtArgs>
    conceptSource?: boolean | Concept$conceptSourceArgs<ExtArgs>
    conceptWordList?: boolean | Concept$conceptWordListArgs<ExtArgs>
    _count?: boolean | ConceptCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Concept"
    objects: {
      metaList: Prisma.$ConceptAnswerPayload<ExtArgs>[]
      answerList: Prisma.$ConceptAnswerPayload<ExtArgs>[]
      fieldList: Prisma.$FieldPayload<ExtArgs>[]
      obsList: Prisma.$ObsPayload<ExtArgs>[]
      orderList: Prisma.$OrderPayload<ExtArgs>[]
      ConceptClass: Prisma.$ConceptClassPayload<ExtArgs> | null
      ConceptDatatype: Prisma.$ConceptDatatypePayload<ExtArgs> | null
      conceptMap: Prisma.$ConceptMapPayload<ExtArgs> | null
      conceptNameList: Prisma.$ConceptNamePayload<ExtArgs>[]
      conceptNumericList: Prisma.$ConceptNumericPayload<ExtArgs>[]
      conceptProposalList: Prisma.$ConceptProposalPayload<ExtArgs>[]
      conceptSet: Prisma.$ConceptSetPayload<ExtArgs> | null
      conceptSource: Prisma.$ConceptSourcePayload<ExtArgs> | null
      conceptWordList: Prisma.$ConceptWordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      dataType: string
      class: string
      isRetired: boolean
      retiredBy: string
      dateRetired: Date
      retiredReason: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
      conceptClassId: string | null
      conceptDatatypeId: string | null
      conceptMapId: string | null
      conceptSetId: string | null
      conceptSourceId: string | null
    }, ExtArgs["result"]["concept"]>
    composites: {}
  }


  type ConceptGetPayload<S extends boolean | null | undefined | ConceptDefaultArgs> = $Result.GetResult<Prisma.$ConceptPayload, S>

  type ConceptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptCountAggregateInputType | true
    }

  export interface ConceptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Concept'], meta: { name: 'Concept' } }
    /**
     * Find zero or one Concept that matches the filter.
     * @param {ConceptFindUniqueArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Concept that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptFindUniqueOrThrowArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Concept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindFirstArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Concept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindFirstOrThrowArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Concepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Concepts
     * const concepts = await prisma.concept.findMany()
     * 
     * // Get first 10 Concepts
     * const concepts = await prisma.concept.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptWithIdOnly = await prisma.concept.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Concept.
     * @param {ConceptCreateArgs} args - Arguments to create a Concept.
     * @example
     * // Create one Concept
     * const Concept = await prisma.concept.create({
     *   data: {
     *     // ... data to create a Concept
     *   }
     * })
     * 
    **/
    create<T extends ConceptCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptCreateArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Concepts.
     *     @param {ConceptCreateManyArgs} args - Arguments to create many Concepts.
     *     @example
     *     // Create many Concepts
     *     const concept = await prisma.concept.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Concept.
     * @param {ConceptDeleteArgs} args - Arguments to delete one Concept.
     * @example
     * // Delete one Concept
     * const Concept = await prisma.concept.delete({
     *   where: {
     *     // ... filter to delete one Concept
     *   }
     * })
     * 
    **/
    delete<T extends ConceptDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDeleteArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Concept.
     * @param {ConceptUpdateArgs} args - Arguments to update one Concept.
     * @example
     * // Update one Concept
     * const concept = await prisma.concept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptUpdateArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Concepts.
     * @param {ConceptDeleteManyArgs} args - Arguments to filter Concepts to delete.
     * @example
     * // Delete a few Concepts
     * const { count } = await prisma.concept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Concepts
     * const concept = await prisma.concept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Concept.
     * @param {ConceptUpsertArgs} args - Arguments to update or create a Concept.
     * @example
     * // Update or create a Concept
     * const concept = await prisma.concept.upsert({
     *   create: {
     *     // ... data to create a Concept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Concept we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptUpsertArgs<ExtArgs>>
    ): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptCountArgs} args - Arguments to filter Concepts to count.
     * @example
     * // Count the number of Concepts
     * const count = await prisma.concept.count({
     *   where: {
     *     // ... the filter for the Concepts we want to count
     *   }
     * })
    **/
    count<T extends ConceptCountArgs>(
      args?: Subset<T, ConceptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Concept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptAggregateArgs>(args: Subset<T, ConceptAggregateArgs>): Prisma.PrismaPromise<GetConceptAggregateType<T>>

    /**
     * Group by Concept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptGroupByArgs['orderBy'] }
        : { orderBy?: ConceptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Concept model
   */
  readonly fields: ConceptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Concept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    metaList<T extends Concept$metaListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$metaListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findMany'> | Null>;

    answerList<T extends Concept$answerListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$answerListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findMany'> | Null>;

    fieldList<T extends Concept$fieldListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$fieldListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, 'findMany'> | Null>;

    obsList<T extends Concept$obsListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$obsListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObsPayload<ExtArgs>, T, 'findMany'> | Null>;

    orderList<T extends Concept$orderListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$orderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;

    ConceptClass<T extends Concept$ConceptClassArgs<ExtArgs> = {}>(args?: Subset<T, Concept$ConceptClassArgs<ExtArgs>>): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ConceptDatatype<T extends Concept$ConceptDatatypeArgs<ExtArgs> = {}>(args?: Subset<T, Concept$ConceptDatatypeArgs<ExtArgs>>): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    conceptMap<T extends Concept$conceptMapArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptMapArgs<ExtArgs>>): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    conceptNameList<T extends Concept$conceptNameListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptNameListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findMany'> | Null>;

    conceptNumericList<T extends Concept$conceptNumericListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptNumericListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findMany'> | Null>;

    conceptProposalList<T extends Concept$conceptProposalListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptProposalListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findMany'> | Null>;

    conceptSet<T extends Concept$conceptSetArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptSetArgs<ExtArgs>>): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    conceptSource<T extends Concept$conceptSourceArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptSourceArgs<ExtArgs>>): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    conceptWordList<T extends Concept$conceptWordListArgs<ExtArgs> = {}>(args?: Subset<T, Concept$conceptWordListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Concept model
   */ 
  interface ConceptFieldRefs {
    readonly id: FieldRef<"Concept", 'String'>
    readonly uuid: FieldRef<"Concept", 'String'>
    readonly name: FieldRef<"Concept", 'String'>
    readonly description: FieldRef<"Concept", 'String'>
    readonly dataType: FieldRef<"Concept", 'String'>
    readonly class: FieldRef<"Concept", 'String'>
    readonly isRetired: FieldRef<"Concept", 'Boolean'>
    readonly retiredBy: FieldRef<"Concept", 'String'>
    readonly dateRetired: FieldRef<"Concept", 'DateTime'>
    readonly retiredReason: FieldRef<"Concept", 'String'>
    readonly creator: FieldRef<"Concept", 'String'>
    readonly dateCreated: FieldRef<"Concept", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Concept", 'String'>
    readonly lastChangedDate: FieldRef<"Concept", 'DateTime'>
    readonly conceptClassId: FieldRef<"Concept", 'String'>
    readonly conceptDatatypeId: FieldRef<"Concept", 'String'>
    readonly conceptMapId: FieldRef<"Concept", 'String'>
    readonly conceptSetId: FieldRef<"Concept", 'String'>
    readonly conceptSourceId: FieldRef<"Concept", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Concept findUnique
   */
  export type ConceptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept findUniqueOrThrow
   */
  export type ConceptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept findFirst
   */
  export type ConceptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept findFirstOrThrow
   */
  export type ConceptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept findMany
   */
  export type ConceptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept create
   */
  export type ConceptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The data needed to create a Concept.
     */
    data: XOR<ConceptCreateInput, ConceptUncheckedCreateInput>
  }

  /**
   * Concept createMany
   */
  export type ConceptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Concepts.
     */
    data: ConceptCreateManyInput | ConceptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concept update
   */
  export type ConceptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The data needed to update a Concept.
     */
    data: XOR<ConceptUpdateInput, ConceptUncheckedUpdateInput>
    /**
     * Choose, which Concept to update.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept updateMany
   */
  export type ConceptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Concepts.
     */
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyInput>
    /**
     * Filter which Concepts to update
     */
    where?: ConceptWhereInput
  }

  /**
   * Concept upsert
   */
  export type ConceptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The filter to search for the Concept to update in case it exists.
     */
    where: ConceptWhereUniqueInput
    /**
     * In case the Concept found by the `where` argument doesn't exist, create a new Concept with this data.
     */
    create: XOR<ConceptCreateInput, ConceptUncheckedCreateInput>
    /**
     * In case the Concept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptUpdateInput, ConceptUncheckedUpdateInput>
  }

  /**
   * Concept delete
   */
  export type ConceptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter which Concept to delete.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept deleteMany
   */
  export type ConceptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concepts to delete
     */
    where?: ConceptWhereInput
  }

  /**
   * Concept.metaList
   */
  export type Concept$metaListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    where?: ConceptAnswerWhereInput
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    cursor?: ConceptAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptAnswerScalarFieldEnum | ConceptAnswerScalarFieldEnum[]
  }

  /**
   * Concept.answerList
   */
  export type Concept$answerListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    where?: ConceptAnswerWhereInput
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    cursor?: ConceptAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptAnswerScalarFieldEnum | ConceptAnswerScalarFieldEnum[]
  }

  /**
   * Concept.fieldList
   */
  export type Concept$fieldListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    cursor?: FieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Concept.obsList
   */
  export type Concept$obsListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obs
     */
    select?: ObsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObsInclude<ExtArgs> | null
    where?: ObsWhereInput
    orderBy?: ObsOrderByWithRelationInput | ObsOrderByWithRelationInput[]
    cursor?: ObsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObsScalarFieldEnum | ObsScalarFieldEnum[]
  }

  /**
   * Concept.orderList
   */
  export type Concept$orderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Concept.ConceptClass
   */
  export type Concept$ConceptClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    where?: ConceptClassWhereInput
  }

  /**
   * Concept.ConceptDatatype
   */
  export type Concept$ConceptDatatypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    where?: ConceptDatatypeWhereInput
  }

  /**
   * Concept.conceptMap
   */
  export type Concept$conceptMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    where?: ConceptMapWhereInput
  }

  /**
   * Concept.conceptNameList
   */
  export type Concept$conceptNameListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    where?: ConceptNameWhereInput
    orderBy?: ConceptNameOrderByWithRelationInput | ConceptNameOrderByWithRelationInput[]
    cursor?: ConceptNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptNameScalarFieldEnum | ConceptNameScalarFieldEnum[]
  }

  /**
   * Concept.conceptNumericList
   */
  export type Concept$conceptNumericListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    where?: ConceptNumericWhereInput
    orderBy?: ConceptNumericOrderByWithRelationInput | ConceptNumericOrderByWithRelationInput[]
    cursor?: ConceptNumericWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptNumericScalarFieldEnum | ConceptNumericScalarFieldEnum[]
  }

  /**
   * Concept.conceptProposalList
   */
  export type Concept$conceptProposalListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    where?: ConceptProposalWhereInput
    orderBy?: ConceptProposalOrderByWithRelationInput | ConceptProposalOrderByWithRelationInput[]
    cursor?: ConceptProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptProposalScalarFieldEnum | ConceptProposalScalarFieldEnum[]
  }

  /**
   * Concept.conceptSet
   */
  export type Concept$conceptSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    where?: ConceptSetWhereInput
  }

  /**
   * Concept.conceptSource
   */
  export type Concept$conceptSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    where?: ConceptSourceWhereInput
  }

  /**
   * Concept.conceptWordList
   */
  export type Concept$conceptWordListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    where?: ConceptWordWhereInput
    orderBy?: ConceptWordOrderByWithRelationInput | ConceptWordOrderByWithRelationInput[]
    cursor?: ConceptWordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptWordScalarFieldEnum | ConceptWordScalarFieldEnum[]
  }

  /**
   * Concept without action
   */
  export type ConceptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
  }


  /**
   * Model ConceptAnswer
   */

  export type AggregateConceptAnswer = {
    _count: ConceptAnswerCountAggregateOutputType | null
    _min: ConceptAnswerMinAggregateOutputType | null
    _max: ConceptAnswerMaxAggregateOutputType | null
  }

  export type ConceptAnswerMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    answerConceptId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptAnswerMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    answerConceptId: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptAnswerCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    answerConceptId: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptAnswerMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    answerConceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptAnswerMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    answerConceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptAnswerCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    answerConceptId?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptAnswer to aggregate.
     */
    where?: ConceptAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptAnswers to fetch.
     */
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptAnswers
    **/
    _count?: true | ConceptAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptAnswerMaxAggregateInputType
  }

  export type GetConceptAnswerAggregateType<T extends ConceptAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptAnswer[P]>
      : GetScalarType<T[P], AggregateConceptAnswer[P]>
  }




  export type ConceptAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptAnswerWhereInput
    orderBy?: ConceptAnswerOrderByWithAggregationInput | ConceptAnswerOrderByWithAggregationInput[]
    by: ConceptAnswerScalarFieldEnum[] | ConceptAnswerScalarFieldEnum
    having?: ConceptAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptAnswerCountAggregateInputType | true
    _min?: ConceptAnswerMinAggregateInputType
    _max?: ConceptAnswerMaxAggregateInputType
  }

  export type ConceptAnswerGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    answerConceptId: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptAnswerCountAggregateOutputType | null
    _min: ConceptAnswerMinAggregateOutputType | null
    _max: ConceptAnswerMaxAggregateOutputType | null
  }

  type GetConceptAnswerGroupByPayload<T extends ConceptAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptAnswerGroupByOutputType[P]>
        }
      >
    >


  export type ConceptAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    answerConceptId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    answerConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptAnswer"]>

  export type ConceptAnswerSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    answerConceptId?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
    answerConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }


  export type $ConceptAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptAnswer"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
      answerConcept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      answerConceptId: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptAnswer"]>
    composites: {}
  }


  type ConceptAnswerGetPayload<S extends boolean | null | undefined | ConceptAnswerDefaultArgs> = $Result.GetResult<Prisma.$ConceptAnswerPayload, S>

  type ConceptAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptAnswerCountAggregateInputType | true
    }

  export interface ConceptAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptAnswer'], meta: { name: 'ConceptAnswer' } }
    /**
     * Find zero or one ConceptAnswer that matches the filter.
     * @param {ConceptAnswerFindUniqueArgs} args - Arguments to find a ConceptAnswer
     * @example
     * // Get one ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptAnswerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptAnswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptAnswerFindUniqueOrThrowArgs} args - Arguments to find a ConceptAnswer
     * @example
     * // Get one ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptAnswerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerFindFirstArgs} args - Arguments to find a ConceptAnswer
     * @example
     * // Get one ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptAnswerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerFindFirstOrThrowArgs} args - Arguments to find a ConceptAnswer
     * @example
     * // Get one ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptAnswerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptAnswers
     * const conceptAnswers = await prisma.conceptAnswer.findMany()
     * 
     * // Get first 10 ConceptAnswers
     * const conceptAnswers = await prisma.conceptAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptAnswerWithIdOnly = await prisma.conceptAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptAnswerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptAnswer.
     * @param {ConceptAnswerCreateArgs} args - Arguments to create a ConceptAnswer.
     * @example
     * // Create one ConceptAnswer
     * const ConceptAnswer = await prisma.conceptAnswer.create({
     *   data: {
     *     // ... data to create a ConceptAnswer
     *   }
     * })
     * 
    **/
    create<T extends ConceptAnswerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerCreateArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptAnswers.
     *     @param {ConceptAnswerCreateManyArgs} args - Arguments to create many ConceptAnswers.
     *     @example
     *     // Create many ConceptAnswers
     *     const conceptAnswer = await prisma.conceptAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptAnswerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptAnswer.
     * @param {ConceptAnswerDeleteArgs} args - Arguments to delete one ConceptAnswer.
     * @example
     * // Delete one ConceptAnswer
     * const ConceptAnswer = await prisma.conceptAnswer.delete({
     *   where: {
     *     // ... filter to delete one ConceptAnswer
     *   }
     * })
     * 
    **/
    delete<T extends ConceptAnswerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerDeleteArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptAnswer.
     * @param {ConceptAnswerUpdateArgs} args - Arguments to update one ConceptAnswer.
     * @example
     * // Update one ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptAnswerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerUpdateArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptAnswers.
     * @param {ConceptAnswerDeleteManyArgs} args - Arguments to filter ConceptAnswers to delete.
     * @example
     * // Delete a few ConceptAnswers
     * const { count } = await prisma.conceptAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptAnswerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptAnswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptAnswers
     * const conceptAnswer = await prisma.conceptAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptAnswerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptAnswer.
     * @param {ConceptAnswerUpsertArgs} args - Arguments to update or create a ConceptAnswer.
     * @example
     * // Update or create a ConceptAnswer
     * const conceptAnswer = await prisma.conceptAnswer.upsert({
     *   create: {
     *     // ... data to create a ConceptAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptAnswerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptAnswerUpsertArgs<ExtArgs>>
    ): Prisma__ConceptAnswerClient<$Result.GetResult<Prisma.$ConceptAnswerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerCountArgs} args - Arguments to filter ConceptAnswers to count.
     * @example
     * // Count the number of ConceptAnswers
     * const count = await prisma.conceptAnswer.count({
     *   where: {
     *     // ... the filter for the ConceptAnswers we want to count
     *   }
     * })
    **/
    count<T extends ConceptAnswerCountArgs>(
      args?: Subset<T, ConceptAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptAnswerAggregateArgs>(args: Subset<T, ConceptAnswerAggregateArgs>): Prisma.PrismaPromise<GetConceptAnswerAggregateType<T>>

    /**
     * Group by ConceptAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptAnswerGroupByArgs['orderBy'] }
        : { orderBy?: ConceptAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptAnswer model
   */
  readonly fields: ConceptAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    answerConcept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptAnswer model
   */ 
  interface ConceptAnswerFieldRefs {
    readonly id: FieldRef<"ConceptAnswer", 'String'>
    readonly uuid: FieldRef<"ConceptAnswer", 'String'>
    readonly conceptId: FieldRef<"ConceptAnswer", 'String'>
    readonly answerConceptId: FieldRef<"ConceptAnswer", 'String'>
    readonly creator: FieldRef<"ConceptAnswer", 'String'>
    readonly dateCreated: FieldRef<"ConceptAnswer", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptAnswer", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptAnswer findUnique
   */
  export type ConceptAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ConceptAnswer to fetch.
     */
    where: ConceptAnswerWhereUniqueInput
  }

  /**
   * ConceptAnswer findUniqueOrThrow
   */
  export type ConceptAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ConceptAnswer to fetch.
     */
    where: ConceptAnswerWhereUniqueInput
  }

  /**
   * ConceptAnswer findFirst
   */
  export type ConceptAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ConceptAnswer to fetch.
     */
    where?: ConceptAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptAnswers to fetch.
     */
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptAnswers.
     */
    cursor?: ConceptAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptAnswers.
     */
    distinct?: ConceptAnswerScalarFieldEnum | ConceptAnswerScalarFieldEnum[]
  }

  /**
   * ConceptAnswer findFirstOrThrow
   */
  export type ConceptAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ConceptAnswer to fetch.
     */
    where?: ConceptAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptAnswers to fetch.
     */
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptAnswers.
     */
    cursor?: ConceptAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptAnswers.
     */
    distinct?: ConceptAnswerScalarFieldEnum | ConceptAnswerScalarFieldEnum[]
  }

  /**
   * ConceptAnswer findMany
   */
  export type ConceptAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ConceptAnswers to fetch.
     */
    where?: ConceptAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptAnswers to fetch.
     */
    orderBy?: ConceptAnswerOrderByWithRelationInput | ConceptAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptAnswers.
     */
    cursor?: ConceptAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptAnswers.
     */
    skip?: number
    distinct?: ConceptAnswerScalarFieldEnum | ConceptAnswerScalarFieldEnum[]
  }

  /**
   * ConceptAnswer create
   */
  export type ConceptAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptAnswer.
     */
    data: XOR<ConceptAnswerCreateInput, ConceptAnswerUncheckedCreateInput>
  }

  /**
   * ConceptAnswer createMany
   */
  export type ConceptAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptAnswers.
     */
    data: ConceptAnswerCreateManyInput | ConceptAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptAnswer update
   */
  export type ConceptAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptAnswer.
     */
    data: XOR<ConceptAnswerUpdateInput, ConceptAnswerUncheckedUpdateInput>
    /**
     * Choose, which ConceptAnswer to update.
     */
    where: ConceptAnswerWhereUniqueInput
  }

  /**
   * ConceptAnswer updateMany
   */
  export type ConceptAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptAnswers.
     */
    data: XOR<ConceptAnswerUpdateManyMutationInput, ConceptAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ConceptAnswers to update
     */
    where?: ConceptAnswerWhereInput
  }

  /**
   * ConceptAnswer upsert
   */
  export type ConceptAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptAnswer to update in case it exists.
     */
    where: ConceptAnswerWhereUniqueInput
    /**
     * In case the ConceptAnswer found by the `where` argument doesn't exist, create a new ConceptAnswer with this data.
     */
    create: XOR<ConceptAnswerCreateInput, ConceptAnswerUncheckedCreateInput>
    /**
     * In case the ConceptAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptAnswerUpdateInput, ConceptAnswerUncheckedUpdateInput>
  }

  /**
   * ConceptAnswer delete
   */
  export type ConceptAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
    /**
     * Filter which ConceptAnswer to delete.
     */
    where: ConceptAnswerWhereUniqueInput
  }

  /**
   * ConceptAnswer deleteMany
   */
  export type ConceptAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptAnswers to delete
     */
    where?: ConceptAnswerWhereInput
  }

  /**
   * ConceptAnswer without action
   */
  export type ConceptAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptAnswer
     */
    select?: ConceptAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptAnswerInclude<ExtArgs> | null
  }


  /**
   * Model ConceptClass
   */

  export type AggregateConceptClass = {
    _count: ConceptClassCountAggregateOutputType | null
    _min: ConceptClassMinAggregateOutputType | null
    _max: ConceptClassMaxAggregateOutputType | null
  }

  export type ConceptClassMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptClassMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptClassCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptClassMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptClassMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptClassCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptClass to aggregate.
     */
    where?: ConceptClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptClasses to fetch.
     */
    orderBy?: ConceptClassOrderByWithRelationInput | ConceptClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptClasses
    **/
    _count?: true | ConceptClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptClassMaxAggregateInputType
  }

  export type GetConceptClassAggregateType<T extends ConceptClassAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptClass[P]>
      : GetScalarType<T[P], AggregateConceptClass[P]>
  }




  export type ConceptClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptClassWhereInput
    orderBy?: ConceptClassOrderByWithAggregationInput | ConceptClassOrderByWithAggregationInput[]
    by: ConceptClassScalarFieldEnum[] | ConceptClassScalarFieldEnum
    having?: ConceptClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptClassCountAggregateInputType | true
    _min?: ConceptClassMinAggregateInputType
    _max?: ConceptClassMaxAggregateInputType
  }

  export type ConceptClassGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptClassCountAggregateOutputType | null
    _min: ConceptClassMinAggregateOutputType | null
    _max: ConceptClassMaxAggregateOutputType | null
  }

  type GetConceptClassGroupByPayload<T extends ConceptClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptClassGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptClassGroupByOutputType[P]>
        }
      >
    >


  export type ConceptClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptList?: boolean | ConceptClass$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptClass"]>

  export type ConceptClassSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptClass$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptClassCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptClass"
    objects: {
      conceptList: Prisma.$ConceptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptClass"]>
    composites: {}
  }


  type ConceptClassGetPayload<S extends boolean | null | undefined | ConceptClassDefaultArgs> = $Result.GetResult<Prisma.$ConceptClassPayload, S>

  type ConceptClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptClassCountAggregateInputType | true
    }

  export interface ConceptClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptClass'], meta: { name: 'ConceptClass' } }
    /**
     * Find zero or one ConceptClass that matches the filter.
     * @param {ConceptClassFindUniqueArgs} args - Arguments to find a ConceptClass
     * @example
     * // Get one ConceptClass
     * const conceptClass = await prisma.conceptClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptClassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptClass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptClassFindUniqueOrThrowArgs} args - Arguments to find a ConceptClass
     * @example
     * // Get one ConceptClass
     * const conceptClass = await prisma.conceptClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptClassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassFindFirstArgs} args - Arguments to find a ConceptClass
     * @example
     * // Get one ConceptClass
     * const conceptClass = await prisma.conceptClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptClassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassFindFirstOrThrowArgs} args - Arguments to find a ConceptClass
     * @example
     * // Get one ConceptClass
     * const conceptClass = await prisma.conceptClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptClassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptClasses
     * const conceptClasses = await prisma.conceptClass.findMany()
     * 
     * // Get first 10 ConceptClasses
     * const conceptClasses = await prisma.conceptClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptClassWithIdOnly = await prisma.conceptClass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptClassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptClass.
     * @param {ConceptClassCreateArgs} args - Arguments to create a ConceptClass.
     * @example
     * // Create one ConceptClass
     * const ConceptClass = await prisma.conceptClass.create({
     *   data: {
     *     // ... data to create a ConceptClass
     *   }
     * })
     * 
    **/
    create<T extends ConceptClassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassCreateArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptClasses.
     *     @param {ConceptClassCreateManyArgs} args - Arguments to create many ConceptClasses.
     *     @example
     *     // Create many ConceptClasses
     *     const conceptClass = await prisma.conceptClass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptClassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptClass.
     * @param {ConceptClassDeleteArgs} args - Arguments to delete one ConceptClass.
     * @example
     * // Delete one ConceptClass
     * const ConceptClass = await prisma.conceptClass.delete({
     *   where: {
     *     // ... filter to delete one ConceptClass
     *   }
     * })
     * 
    **/
    delete<T extends ConceptClassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassDeleteArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptClass.
     * @param {ConceptClassUpdateArgs} args - Arguments to update one ConceptClass.
     * @example
     * // Update one ConceptClass
     * const conceptClass = await prisma.conceptClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptClassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassUpdateArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptClasses.
     * @param {ConceptClassDeleteManyArgs} args - Arguments to filter ConceptClasses to delete.
     * @example
     * // Delete a few ConceptClasses
     * const { count } = await prisma.conceptClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptClassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptClassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptClasses
     * const conceptClass = await prisma.conceptClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptClassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptClass.
     * @param {ConceptClassUpsertArgs} args - Arguments to update or create a ConceptClass.
     * @example
     * // Update or create a ConceptClass
     * const conceptClass = await prisma.conceptClass.upsert({
     *   create: {
     *     // ... data to create a ConceptClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptClass we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptClassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptClassUpsertArgs<ExtArgs>>
    ): Prisma__ConceptClassClient<$Result.GetResult<Prisma.$ConceptClassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassCountArgs} args - Arguments to filter ConceptClasses to count.
     * @example
     * // Count the number of ConceptClasses
     * const count = await prisma.conceptClass.count({
     *   where: {
     *     // ... the filter for the ConceptClasses we want to count
     *   }
     * })
    **/
    count<T extends ConceptClassCountArgs>(
      args?: Subset<T, ConceptClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptClassAggregateArgs>(args: Subset<T, ConceptClassAggregateArgs>): Prisma.PrismaPromise<GetConceptClassAggregateType<T>>

    /**
     * Group by ConceptClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptClassGroupByArgs['orderBy'] }
        : { orderBy?: ConceptClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptClass model
   */
  readonly fields: ConceptClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conceptList<T extends ConceptClass$conceptListArgs<ExtArgs> = {}>(args?: Subset<T, ConceptClass$conceptListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptClass model
   */ 
  interface ConceptClassFieldRefs {
    readonly id: FieldRef<"ConceptClass", 'String'>
    readonly uuid: FieldRef<"ConceptClass", 'String'>
    readonly name: FieldRef<"ConceptClass", 'String'>
    readonly description: FieldRef<"ConceptClass", 'String'>
    readonly creator: FieldRef<"ConceptClass", 'String'>
    readonly dateCreated: FieldRef<"ConceptClass", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptClass", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptClass findUnique
   */
  export type ConceptClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter, which ConceptClass to fetch.
     */
    where: ConceptClassWhereUniqueInput
  }

  /**
   * ConceptClass findUniqueOrThrow
   */
  export type ConceptClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter, which ConceptClass to fetch.
     */
    where: ConceptClassWhereUniqueInput
  }

  /**
   * ConceptClass findFirst
   */
  export type ConceptClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter, which ConceptClass to fetch.
     */
    where?: ConceptClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptClasses to fetch.
     */
    orderBy?: ConceptClassOrderByWithRelationInput | ConceptClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptClasses.
     */
    cursor?: ConceptClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptClasses.
     */
    distinct?: ConceptClassScalarFieldEnum | ConceptClassScalarFieldEnum[]
  }

  /**
   * ConceptClass findFirstOrThrow
   */
  export type ConceptClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter, which ConceptClass to fetch.
     */
    where?: ConceptClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptClasses to fetch.
     */
    orderBy?: ConceptClassOrderByWithRelationInput | ConceptClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptClasses.
     */
    cursor?: ConceptClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptClasses.
     */
    distinct?: ConceptClassScalarFieldEnum | ConceptClassScalarFieldEnum[]
  }

  /**
   * ConceptClass findMany
   */
  export type ConceptClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter, which ConceptClasses to fetch.
     */
    where?: ConceptClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptClasses to fetch.
     */
    orderBy?: ConceptClassOrderByWithRelationInput | ConceptClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptClasses.
     */
    cursor?: ConceptClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptClasses.
     */
    skip?: number
    distinct?: ConceptClassScalarFieldEnum | ConceptClassScalarFieldEnum[]
  }

  /**
   * ConceptClass create
   */
  export type ConceptClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptClass.
     */
    data: XOR<ConceptClassCreateInput, ConceptClassUncheckedCreateInput>
  }

  /**
   * ConceptClass createMany
   */
  export type ConceptClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptClasses.
     */
    data: ConceptClassCreateManyInput | ConceptClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptClass update
   */
  export type ConceptClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptClass.
     */
    data: XOR<ConceptClassUpdateInput, ConceptClassUncheckedUpdateInput>
    /**
     * Choose, which ConceptClass to update.
     */
    where: ConceptClassWhereUniqueInput
  }

  /**
   * ConceptClass updateMany
   */
  export type ConceptClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptClasses.
     */
    data: XOR<ConceptClassUpdateManyMutationInput, ConceptClassUncheckedUpdateManyInput>
    /**
     * Filter which ConceptClasses to update
     */
    where?: ConceptClassWhereInput
  }

  /**
   * ConceptClass upsert
   */
  export type ConceptClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptClass to update in case it exists.
     */
    where: ConceptClassWhereUniqueInput
    /**
     * In case the ConceptClass found by the `where` argument doesn't exist, create a new ConceptClass with this data.
     */
    create: XOR<ConceptClassCreateInput, ConceptClassUncheckedCreateInput>
    /**
     * In case the ConceptClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptClassUpdateInput, ConceptClassUncheckedUpdateInput>
  }

  /**
   * ConceptClass delete
   */
  export type ConceptClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
    /**
     * Filter which ConceptClass to delete.
     */
    where: ConceptClassWhereUniqueInput
  }

  /**
   * ConceptClass deleteMany
   */
  export type ConceptClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptClasses to delete
     */
    where?: ConceptClassWhereInput
  }

  /**
   * ConceptClass.conceptList
   */
  export type ConceptClass$conceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    cursor?: ConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * ConceptClass without action
   */
  export type ConceptClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptClass
     */
    select?: ConceptClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptClassInclude<ExtArgs> | null
  }


  /**
   * Model ConceptDatatype
   */

  export type AggregateConceptDatatype = {
    _count: ConceptDatatypeCountAggregateOutputType | null
    _min: ConceptDatatypeMinAggregateOutputType | null
    _max: ConceptDatatypeMaxAggregateOutputType | null
  }

  export type ConceptDatatypeMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptDatatypeMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptDatatypeCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptDatatypeMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptDatatypeMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptDatatypeCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptDatatypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptDatatype to aggregate.
     */
    where?: ConceptDatatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptDatatypes to fetch.
     */
    orderBy?: ConceptDatatypeOrderByWithRelationInput | ConceptDatatypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptDatatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptDatatypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptDatatypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptDatatypes
    **/
    _count?: true | ConceptDatatypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptDatatypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptDatatypeMaxAggregateInputType
  }

  export type GetConceptDatatypeAggregateType<T extends ConceptDatatypeAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptDatatype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptDatatype[P]>
      : GetScalarType<T[P], AggregateConceptDatatype[P]>
  }




  export type ConceptDatatypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptDatatypeWhereInput
    orderBy?: ConceptDatatypeOrderByWithAggregationInput | ConceptDatatypeOrderByWithAggregationInput[]
    by: ConceptDatatypeScalarFieldEnum[] | ConceptDatatypeScalarFieldEnum
    having?: ConceptDatatypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptDatatypeCountAggregateInputType | true
    _min?: ConceptDatatypeMinAggregateInputType
    _max?: ConceptDatatypeMaxAggregateInputType
  }

  export type ConceptDatatypeGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptDatatypeCountAggregateOutputType | null
    _min: ConceptDatatypeMinAggregateOutputType | null
    _max: ConceptDatatypeMaxAggregateOutputType | null
  }

  type GetConceptDatatypeGroupByPayload<T extends ConceptDatatypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptDatatypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptDatatypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptDatatypeGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptDatatypeGroupByOutputType[P]>
        }
      >
    >


  export type ConceptDatatypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptList?: boolean | ConceptDatatype$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptDatatypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptDatatype"]>

  export type ConceptDatatypeSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptDatatypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptDatatype$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptDatatypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptDatatypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptDatatype"
    objects: {
      conceptList: Prisma.$ConceptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptDatatype"]>
    composites: {}
  }


  type ConceptDatatypeGetPayload<S extends boolean | null | undefined | ConceptDatatypeDefaultArgs> = $Result.GetResult<Prisma.$ConceptDatatypePayload, S>

  type ConceptDatatypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptDatatypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptDatatypeCountAggregateInputType | true
    }

  export interface ConceptDatatypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptDatatype'], meta: { name: 'ConceptDatatype' } }
    /**
     * Find zero or one ConceptDatatype that matches the filter.
     * @param {ConceptDatatypeFindUniqueArgs} args - Arguments to find a ConceptDatatype
     * @example
     * // Get one ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptDatatypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptDatatype that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptDatatypeFindUniqueOrThrowArgs} args - Arguments to find a ConceptDatatype
     * @example
     * // Get one ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptDatatypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptDatatype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeFindFirstArgs} args - Arguments to find a ConceptDatatype
     * @example
     * // Get one ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptDatatypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptDatatype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeFindFirstOrThrowArgs} args - Arguments to find a ConceptDatatype
     * @example
     * // Get one ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptDatatypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptDatatypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptDatatypes
     * const conceptDatatypes = await prisma.conceptDatatype.findMany()
     * 
     * // Get first 10 ConceptDatatypes
     * const conceptDatatypes = await prisma.conceptDatatype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptDatatypeWithIdOnly = await prisma.conceptDatatype.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptDatatypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptDatatype.
     * @param {ConceptDatatypeCreateArgs} args - Arguments to create a ConceptDatatype.
     * @example
     * // Create one ConceptDatatype
     * const ConceptDatatype = await prisma.conceptDatatype.create({
     *   data: {
     *     // ... data to create a ConceptDatatype
     *   }
     * })
     * 
    **/
    create<T extends ConceptDatatypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeCreateArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptDatatypes.
     *     @param {ConceptDatatypeCreateManyArgs} args - Arguments to create many ConceptDatatypes.
     *     @example
     *     // Create many ConceptDatatypes
     *     const conceptDatatype = await prisma.conceptDatatype.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptDatatypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptDatatype.
     * @param {ConceptDatatypeDeleteArgs} args - Arguments to delete one ConceptDatatype.
     * @example
     * // Delete one ConceptDatatype
     * const ConceptDatatype = await prisma.conceptDatatype.delete({
     *   where: {
     *     // ... filter to delete one ConceptDatatype
     *   }
     * })
     * 
    **/
    delete<T extends ConceptDatatypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeDeleteArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptDatatype.
     * @param {ConceptDatatypeUpdateArgs} args - Arguments to update one ConceptDatatype.
     * @example
     * // Update one ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptDatatypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeUpdateArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptDatatypes.
     * @param {ConceptDatatypeDeleteManyArgs} args - Arguments to filter ConceptDatatypes to delete.
     * @example
     * // Delete a few ConceptDatatypes
     * const { count } = await prisma.conceptDatatype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptDatatypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptDatatypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptDatatypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptDatatypes
     * const conceptDatatype = await prisma.conceptDatatype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptDatatypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptDatatype.
     * @param {ConceptDatatypeUpsertArgs} args - Arguments to update or create a ConceptDatatype.
     * @example
     * // Update or create a ConceptDatatype
     * const conceptDatatype = await prisma.conceptDatatype.upsert({
     *   create: {
     *     // ... data to create a ConceptDatatype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptDatatype we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptDatatypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptDatatypeUpsertArgs<ExtArgs>>
    ): Prisma__ConceptDatatypeClient<$Result.GetResult<Prisma.$ConceptDatatypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptDatatypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeCountArgs} args - Arguments to filter ConceptDatatypes to count.
     * @example
     * // Count the number of ConceptDatatypes
     * const count = await prisma.conceptDatatype.count({
     *   where: {
     *     // ... the filter for the ConceptDatatypes we want to count
     *   }
     * })
    **/
    count<T extends ConceptDatatypeCountArgs>(
      args?: Subset<T, ConceptDatatypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptDatatypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptDatatype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptDatatypeAggregateArgs>(args: Subset<T, ConceptDatatypeAggregateArgs>): Prisma.PrismaPromise<GetConceptDatatypeAggregateType<T>>

    /**
     * Group by ConceptDatatype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptDatatypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptDatatypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptDatatypeGroupByArgs['orderBy'] }
        : { orderBy?: ConceptDatatypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptDatatypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptDatatypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptDatatype model
   */
  readonly fields: ConceptDatatypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptDatatype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptDatatypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conceptList<T extends ConceptDatatype$conceptListArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDatatype$conceptListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptDatatype model
   */ 
  interface ConceptDatatypeFieldRefs {
    readonly id: FieldRef<"ConceptDatatype", 'String'>
    readonly uuid: FieldRef<"ConceptDatatype", 'String'>
    readonly name: FieldRef<"ConceptDatatype", 'String'>
    readonly description: FieldRef<"ConceptDatatype", 'String'>
    readonly creator: FieldRef<"ConceptDatatype", 'String'>
    readonly dateCreated: FieldRef<"ConceptDatatype", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptDatatype", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptDatatype", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptDatatype findUnique
   */
  export type ConceptDatatypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter, which ConceptDatatype to fetch.
     */
    where: ConceptDatatypeWhereUniqueInput
  }

  /**
   * ConceptDatatype findUniqueOrThrow
   */
  export type ConceptDatatypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter, which ConceptDatatype to fetch.
     */
    where: ConceptDatatypeWhereUniqueInput
  }

  /**
   * ConceptDatatype findFirst
   */
  export type ConceptDatatypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter, which ConceptDatatype to fetch.
     */
    where?: ConceptDatatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptDatatypes to fetch.
     */
    orderBy?: ConceptDatatypeOrderByWithRelationInput | ConceptDatatypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptDatatypes.
     */
    cursor?: ConceptDatatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptDatatypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptDatatypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptDatatypes.
     */
    distinct?: ConceptDatatypeScalarFieldEnum | ConceptDatatypeScalarFieldEnum[]
  }

  /**
   * ConceptDatatype findFirstOrThrow
   */
  export type ConceptDatatypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter, which ConceptDatatype to fetch.
     */
    where?: ConceptDatatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptDatatypes to fetch.
     */
    orderBy?: ConceptDatatypeOrderByWithRelationInput | ConceptDatatypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptDatatypes.
     */
    cursor?: ConceptDatatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptDatatypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptDatatypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptDatatypes.
     */
    distinct?: ConceptDatatypeScalarFieldEnum | ConceptDatatypeScalarFieldEnum[]
  }

  /**
   * ConceptDatatype findMany
   */
  export type ConceptDatatypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter, which ConceptDatatypes to fetch.
     */
    where?: ConceptDatatypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptDatatypes to fetch.
     */
    orderBy?: ConceptDatatypeOrderByWithRelationInput | ConceptDatatypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptDatatypes.
     */
    cursor?: ConceptDatatypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptDatatypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptDatatypes.
     */
    skip?: number
    distinct?: ConceptDatatypeScalarFieldEnum | ConceptDatatypeScalarFieldEnum[]
  }

  /**
   * ConceptDatatype create
   */
  export type ConceptDatatypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptDatatype.
     */
    data: XOR<ConceptDatatypeCreateInput, ConceptDatatypeUncheckedCreateInput>
  }

  /**
   * ConceptDatatype createMany
   */
  export type ConceptDatatypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptDatatypes.
     */
    data: ConceptDatatypeCreateManyInput | ConceptDatatypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptDatatype update
   */
  export type ConceptDatatypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptDatatype.
     */
    data: XOR<ConceptDatatypeUpdateInput, ConceptDatatypeUncheckedUpdateInput>
    /**
     * Choose, which ConceptDatatype to update.
     */
    where: ConceptDatatypeWhereUniqueInput
  }

  /**
   * ConceptDatatype updateMany
   */
  export type ConceptDatatypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptDatatypes.
     */
    data: XOR<ConceptDatatypeUpdateManyMutationInput, ConceptDatatypeUncheckedUpdateManyInput>
    /**
     * Filter which ConceptDatatypes to update
     */
    where?: ConceptDatatypeWhereInput
  }

  /**
   * ConceptDatatype upsert
   */
  export type ConceptDatatypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptDatatype to update in case it exists.
     */
    where: ConceptDatatypeWhereUniqueInput
    /**
     * In case the ConceptDatatype found by the `where` argument doesn't exist, create a new ConceptDatatype with this data.
     */
    create: XOR<ConceptDatatypeCreateInput, ConceptDatatypeUncheckedCreateInput>
    /**
     * In case the ConceptDatatype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptDatatypeUpdateInput, ConceptDatatypeUncheckedUpdateInput>
  }

  /**
   * ConceptDatatype delete
   */
  export type ConceptDatatypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
    /**
     * Filter which ConceptDatatype to delete.
     */
    where: ConceptDatatypeWhereUniqueInput
  }

  /**
   * ConceptDatatype deleteMany
   */
  export type ConceptDatatypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptDatatypes to delete
     */
    where?: ConceptDatatypeWhereInput
  }

  /**
   * ConceptDatatype.conceptList
   */
  export type ConceptDatatype$conceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    cursor?: ConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * ConceptDatatype without action
   */
  export type ConceptDatatypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptDatatype
     */
    select?: ConceptDatatypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptDatatypeInclude<ExtArgs> | null
  }


  /**
   * Model ConceptMap
   */

  export type AggregateConceptMap = {
    _count: ConceptMapCountAggregateOutputType | null
    _min: ConceptMapMinAggregateOutputType | null
    _max: ConceptMapMaxAggregateOutputType | null
  }

  export type ConceptMapMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptMapMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptMapCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptMapMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptMapMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptMapCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptMap to aggregate.
     */
    where?: ConceptMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptMaps to fetch.
     */
    orderBy?: ConceptMapOrderByWithRelationInput | ConceptMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptMaps
    **/
    _count?: true | ConceptMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptMapMaxAggregateInputType
  }

  export type GetConceptMapAggregateType<T extends ConceptMapAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptMap[P]>
      : GetScalarType<T[P], AggregateConceptMap[P]>
  }




  export type ConceptMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptMapWhereInput
    orderBy?: ConceptMapOrderByWithAggregationInput | ConceptMapOrderByWithAggregationInput[]
    by: ConceptMapScalarFieldEnum[] | ConceptMapScalarFieldEnum
    having?: ConceptMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptMapCountAggregateInputType | true
    _min?: ConceptMapMinAggregateInputType
    _max?: ConceptMapMaxAggregateInputType
  }

  export type ConceptMapGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptMapCountAggregateOutputType | null
    _min: ConceptMapMinAggregateOutputType | null
    _max: ConceptMapMaxAggregateOutputType | null
  }

  type GetConceptMapGroupByPayload<T extends ConceptMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptMapGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptMapGroupByOutputType[P]>
        }
      >
    >


  export type ConceptMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptList?: boolean | ConceptMap$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptMapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptMap"]>

  export type ConceptMapSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptMap$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptMapCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptMap"
    objects: {
      conceptList: Prisma.$ConceptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptMap"]>
    composites: {}
  }


  type ConceptMapGetPayload<S extends boolean | null | undefined | ConceptMapDefaultArgs> = $Result.GetResult<Prisma.$ConceptMapPayload, S>

  type ConceptMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptMapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptMapCountAggregateInputType | true
    }

  export interface ConceptMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptMap'], meta: { name: 'ConceptMap' } }
    /**
     * Find zero or one ConceptMap that matches the filter.
     * @param {ConceptMapFindUniqueArgs} args - Arguments to find a ConceptMap
     * @example
     * // Get one ConceptMap
     * const conceptMap = await prisma.conceptMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptMapFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptMapFindUniqueOrThrowArgs} args - Arguments to find a ConceptMap
     * @example
     * // Get one ConceptMap
     * const conceptMap = await prisma.conceptMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptMapFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapFindFirstArgs} args - Arguments to find a ConceptMap
     * @example
     * // Get one ConceptMap
     * const conceptMap = await prisma.conceptMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptMapFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapFindFirstOrThrowArgs} args - Arguments to find a ConceptMap
     * @example
     * // Get one ConceptMap
     * const conceptMap = await prisma.conceptMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptMapFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptMaps
     * const conceptMaps = await prisma.conceptMap.findMany()
     * 
     * // Get first 10 ConceptMaps
     * const conceptMaps = await prisma.conceptMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptMapWithIdOnly = await prisma.conceptMap.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptMapFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptMap.
     * @param {ConceptMapCreateArgs} args - Arguments to create a ConceptMap.
     * @example
     * // Create one ConceptMap
     * const ConceptMap = await prisma.conceptMap.create({
     *   data: {
     *     // ... data to create a ConceptMap
     *   }
     * })
     * 
    **/
    create<T extends ConceptMapCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapCreateArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptMaps.
     *     @param {ConceptMapCreateManyArgs} args - Arguments to create many ConceptMaps.
     *     @example
     *     // Create many ConceptMaps
     *     const conceptMap = await prisma.conceptMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptMapCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptMap.
     * @param {ConceptMapDeleteArgs} args - Arguments to delete one ConceptMap.
     * @example
     * // Delete one ConceptMap
     * const ConceptMap = await prisma.conceptMap.delete({
     *   where: {
     *     // ... filter to delete one ConceptMap
     *   }
     * })
     * 
    **/
    delete<T extends ConceptMapDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapDeleteArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptMap.
     * @param {ConceptMapUpdateArgs} args - Arguments to update one ConceptMap.
     * @example
     * // Update one ConceptMap
     * const conceptMap = await prisma.conceptMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptMapUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapUpdateArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptMaps.
     * @param {ConceptMapDeleteManyArgs} args - Arguments to filter ConceptMaps to delete.
     * @example
     * // Delete a few ConceptMaps
     * const { count } = await prisma.conceptMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptMapDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptMapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptMaps
     * const conceptMap = await prisma.conceptMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptMapUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptMap.
     * @param {ConceptMapUpsertArgs} args - Arguments to update or create a ConceptMap.
     * @example
     * // Update or create a ConceptMap
     * const conceptMap = await prisma.conceptMap.upsert({
     *   create: {
     *     // ... data to create a ConceptMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptMap we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptMapUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptMapUpsertArgs<ExtArgs>>
    ): Prisma__ConceptMapClient<$Result.GetResult<Prisma.$ConceptMapPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapCountArgs} args - Arguments to filter ConceptMaps to count.
     * @example
     * // Count the number of ConceptMaps
     * const count = await prisma.conceptMap.count({
     *   where: {
     *     // ... the filter for the ConceptMaps we want to count
     *   }
     * })
    **/
    count<T extends ConceptMapCountArgs>(
      args?: Subset<T, ConceptMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptMapAggregateArgs>(args: Subset<T, ConceptMapAggregateArgs>): Prisma.PrismaPromise<GetConceptMapAggregateType<T>>

    /**
     * Group by ConceptMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptMapGroupByArgs['orderBy'] }
        : { orderBy?: ConceptMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptMap model
   */
  readonly fields: ConceptMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conceptList<T extends ConceptMap$conceptListArgs<ExtArgs> = {}>(args?: Subset<T, ConceptMap$conceptListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptMap model
   */ 
  interface ConceptMapFieldRefs {
    readonly id: FieldRef<"ConceptMap", 'String'>
    readonly uuid: FieldRef<"ConceptMap", 'String'>
    readonly name: FieldRef<"ConceptMap", 'String'>
    readonly description: FieldRef<"ConceptMap", 'String'>
    readonly creator: FieldRef<"ConceptMap", 'String'>
    readonly dateCreated: FieldRef<"ConceptMap", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptMap", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptMap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptMap findUnique
   */
  export type ConceptMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter, which ConceptMap to fetch.
     */
    where: ConceptMapWhereUniqueInput
  }

  /**
   * ConceptMap findUniqueOrThrow
   */
  export type ConceptMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter, which ConceptMap to fetch.
     */
    where: ConceptMapWhereUniqueInput
  }

  /**
   * ConceptMap findFirst
   */
  export type ConceptMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter, which ConceptMap to fetch.
     */
    where?: ConceptMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptMaps to fetch.
     */
    orderBy?: ConceptMapOrderByWithRelationInput | ConceptMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptMaps.
     */
    cursor?: ConceptMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptMaps.
     */
    distinct?: ConceptMapScalarFieldEnum | ConceptMapScalarFieldEnum[]
  }

  /**
   * ConceptMap findFirstOrThrow
   */
  export type ConceptMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter, which ConceptMap to fetch.
     */
    where?: ConceptMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptMaps to fetch.
     */
    orderBy?: ConceptMapOrderByWithRelationInput | ConceptMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptMaps.
     */
    cursor?: ConceptMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptMaps.
     */
    distinct?: ConceptMapScalarFieldEnum | ConceptMapScalarFieldEnum[]
  }

  /**
   * ConceptMap findMany
   */
  export type ConceptMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter, which ConceptMaps to fetch.
     */
    where?: ConceptMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptMaps to fetch.
     */
    orderBy?: ConceptMapOrderByWithRelationInput | ConceptMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptMaps.
     */
    cursor?: ConceptMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptMaps.
     */
    skip?: number
    distinct?: ConceptMapScalarFieldEnum | ConceptMapScalarFieldEnum[]
  }

  /**
   * ConceptMap create
   */
  export type ConceptMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptMap.
     */
    data: XOR<ConceptMapCreateInput, ConceptMapUncheckedCreateInput>
  }

  /**
   * ConceptMap createMany
   */
  export type ConceptMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptMaps.
     */
    data: ConceptMapCreateManyInput | ConceptMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptMap update
   */
  export type ConceptMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptMap.
     */
    data: XOR<ConceptMapUpdateInput, ConceptMapUncheckedUpdateInput>
    /**
     * Choose, which ConceptMap to update.
     */
    where: ConceptMapWhereUniqueInput
  }

  /**
   * ConceptMap updateMany
   */
  export type ConceptMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptMaps.
     */
    data: XOR<ConceptMapUpdateManyMutationInput, ConceptMapUncheckedUpdateManyInput>
    /**
     * Filter which ConceptMaps to update
     */
    where?: ConceptMapWhereInput
  }

  /**
   * ConceptMap upsert
   */
  export type ConceptMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptMap to update in case it exists.
     */
    where: ConceptMapWhereUniqueInput
    /**
     * In case the ConceptMap found by the `where` argument doesn't exist, create a new ConceptMap with this data.
     */
    create: XOR<ConceptMapCreateInput, ConceptMapUncheckedCreateInput>
    /**
     * In case the ConceptMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptMapUpdateInput, ConceptMapUncheckedUpdateInput>
  }

  /**
   * ConceptMap delete
   */
  export type ConceptMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
    /**
     * Filter which ConceptMap to delete.
     */
    where: ConceptMapWhereUniqueInput
  }

  /**
   * ConceptMap deleteMany
   */
  export type ConceptMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptMaps to delete
     */
    where?: ConceptMapWhereInput
  }

  /**
   * ConceptMap.conceptList
   */
  export type ConceptMap$conceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    cursor?: ConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * ConceptMap without action
   */
  export type ConceptMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptMap
     */
    select?: ConceptMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptMapInclude<ExtArgs> | null
  }


  /**
   * Model ConceptName
   */

  export type AggregateConceptName = {
    _count: ConceptNameCountAggregateOutputType | null
    _min: ConceptNameMinAggregateOutputType | null
    _max: ConceptNameMaxAggregateOutputType | null
  }

  export type ConceptNameMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    name: string | null
    locale: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptNameMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    name: string | null
    locale: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptNameCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    name: number
    locale: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptNameMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptNameMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptNameCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptName to aggregate.
     */
    where?: ConceptNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNames to fetch.
     */
    orderBy?: ConceptNameOrderByWithRelationInput | ConceptNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptNames
    **/
    _count?: true | ConceptNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptNameMaxAggregateInputType
  }

  export type GetConceptNameAggregateType<T extends ConceptNameAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptName[P]>
      : GetScalarType<T[P], AggregateConceptName[P]>
  }




  export type ConceptNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptNameWhereInput
    orderBy?: ConceptNameOrderByWithAggregationInput | ConceptNameOrderByWithAggregationInput[]
    by: ConceptNameScalarFieldEnum[] | ConceptNameScalarFieldEnum
    having?: ConceptNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptNameCountAggregateInputType | true
    _min?: ConceptNameMinAggregateInputType
    _max?: ConceptNameMaxAggregateInputType
  }

  export type ConceptNameGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    name: string
    locale: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptNameCountAggregateOutputType | null
    _min: ConceptNameMinAggregateOutputType | null
    _max: ConceptNameMaxAggregateOutputType | null
  }

  type GetConceptNameGroupByPayload<T extends ConceptNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptNameGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptNameGroupByOutputType[P]>
        }
      >
    >


  export type ConceptNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    name?: boolean
    locale?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptName"]>

  export type ConceptNameSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    name?: boolean
    locale?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }


  export type $ConceptNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptName"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      name: string
      locale: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptName"]>
    composites: {}
  }


  type ConceptNameGetPayload<S extends boolean | null | undefined | ConceptNameDefaultArgs> = $Result.GetResult<Prisma.$ConceptNamePayload, S>

  type ConceptNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptNameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptNameCountAggregateInputType | true
    }

  export interface ConceptNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptName'], meta: { name: 'ConceptName' } }
    /**
     * Find zero or one ConceptName that matches the filter.
     * @param {ConceptNameFindUniqueArgs} args - Arguments to find a ConceptName
     * @example
     * // Get one ConceptName
     * const conceptName = await prisma.conceptName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptNameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptName that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptNameFindUniqueOrThrowArgs} args - Arguments to find a ConceptName
     * @example
     * // Get one ConceptName
     * const conceptName = await prisma.conceptName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptNameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameFindFirstArgs} args - Arguments to find a ConceptName
     * @example
     * // Get one ConceptName
     * const conceptName = await prisma.conceptName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptNameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameFindFirstOrThrowArgs} args - Arguments to find a ConceptName
     * @example
     * // Get one ConceptName
     * const conceptName = await prisma.conceptName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptNameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptNames
     * const conceptNames = await prisma.conceptName.findMany()
     * 
     * // Get first 10 ConceptNames
     * const conceptNames = await prisma.conceptName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptNameWithIdOnly = await prisma.conceptName.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptNameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptName.
     * @param {ConceptNameCreateArgs} args - Arguments to create a ConceptName.
     * @example
     * // Create one ConceptName
     * const ConceptName = await prisma.conceptName.create({
     *   data: {
     *     // ... data to create a ConceptName
     *   }
     * })
     * 
    **/
    create<T extends ConceptNameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameCreateArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptNames.
     *     @param {ConceptNameCreateManyArgs} args - Arguments to create many ConceptNames.
     *     @example
     *     // Create many ConceptNames
     *     const conceptName = await prisma.conceptName.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptNameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptName.
     * @param {ConceptNameDeleteArgs} args - Arguments to delete one ConceptName.
     * @example
     * // Delete one ConceptName
     * const ConceptName = await prisma.conceptName.delete({
     *   where: {
     *     // ... filter to delete one ConceptName
     *   }
     * })
     * 
    **/
    delete<T extends ConceptNameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameDeleteArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptName.
     * @param {ConceptNameUpdateArgs} args - Arguments to update one ConceptName.
     * @example
     * // Update one ConceptName
     * const conceptName = await prisma.conceptName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptNameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameUpdateArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptNames.
     * @param {ConceptNameDeleteManyArgs} args - Arguments to filter ConceptNames to delete.
     * @example
     * // Delete a few ConceptNames
     * const { count } = await prisma.conceptName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptNameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptNames
     * const conceptName = await prisma.conceptName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptNameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptName.
     * @param {ConceptNameUpsertArgs} args - Arguments to update or create a ConceptName.
     * @example
     * // Update or create a ConceptName
     * const conceptName = await prisma.conceptName.upsert({
     *   create: {
     *     // ... data to create a ConceptName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptName we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptNameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNameUpsertArgs<ExtArgs>>
    ): Prisma__ConceptNameClient<$Result.GetResult<Prisma.$ConceptNamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameCountArgs} args - Arguments to filter ConceptNames to count.
     * @example
     * // Count the number of ConceptNames
     * const count = await prisma.conceptName.count({
     *   where: {
     *     // ... the filter for the ConceptNames we want to count
     *   }
     * })
    **/
    count<T extends ConceptNameCountArgs>(
      args?: Subset<T, ConceptNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptNameAggregateArgs>(args: Subset<T, ConceptNameAggregateArgs>): Prisma.PrismaPromise<GetConceptNameAggregateType<T>>

    /**
     * Group by ConceptName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptNameGroupByArgs['orderBy'] }
        : { orderBy?: ConceptNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptName model
   */
  readonly fields: ConceptNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptName model
   */ 
  interface ConceptNameFieldRefs {
    readonly id: FieldRef<"ConceptName", 'String'>
    readonly uuid: FieldRef<"ConceptName", 'String'>
    readonly conceptId: FieldRef<"ConceptName", 'String'>
    readonly name: FieldRef<"ConceptName", 'String'>
    readonly locale: FieldRef<"ConceptName", 'String'>
    readonly creator: FieldRef<"ConceptName", 'String'>
    readonly dateCreated: FieldRef<"ConceptName", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptName", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptName", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptName findUnique
   */
  export type ConceptNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter, which ConceptName to fetch.
     */
    where: ConceptNameWhereUniqueInput
  }

  /**
   * ConceptName findUniqueOrThrow
   */
  export type ConceptNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter, which ConceptName to fetch.
     */
    where: ConceptNameWhereUniqueInput
  }

  /**
   * ConceptName findFirst
   */
  export type ConceptNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter, which ConceptName to fetch.
     */
    where?: ConceptNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNames to fetch.
     */
    orderBy?: ConceptNameOrderByWithRelationInput | ConceptNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptNames.
     */
    cursor?: ConceptNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptNames.
     */
    distinct?: ConceptNameScalarFieldEnum | ConceptNameScalarFieldEnum[]
  }

  /**
   * ConceptName findFirstOrThrow
   */
  export type ConceptNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter, which ConceptName to fetch.
     */
    where?: ConceptNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNames to fetch.
     */
    orderBy?: ConceptNameOrderByWithRelationInput | ConceptNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptNames.
     */
    cursor?: ConceptNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptNames.
     */
    distinct?: ConceptNameScalarFieldEnum | ConceptNameScalarFieldEnum[]
  }

  /**
   * ConceptName findMany
   */
  export type ConceptNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNames to fetch.
     */
    where?: ConceptNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNames to fetch.
     */
    orderBy?: ConceptNameOrderByWithRelationInput | ConceptNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptNames.
     */
    cursor?: ConceptNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNames.
     */
    skip?: number
    distinct?: ConceptNameScalarFieldEnum | ConceptNameScalarFieldEnum[]
  }

  /**
   * ConceptName create
   */
  export type ConceptNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptName.
     */
    data: XOR<ConceptNameCreateInput, ConceptNameUncheckedCreateInput>
  }

  /**
   * ConceptName createMany
   */
  export type ConceptNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptNames.
     */
    data: ConceptNameCreateManyInput | ConceptNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptName update
   */
  export type ConceptNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptName.
     */
    data: XOR<ConceptNameUpdateInput, ConceptNameUncheckedUpdateInput>
    /**
     * Choose, which ConceptName to update.
     */
    where: ConceptNameWhereUniqueInput
  }

  /**
   * ConceptName updateMany
   */
  export type ConceptNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptNames.
     */
    data: XOR<ConceptNameUpdateManyMutationInput, ConceptNameUncheckedUpdateManyInput>
    /**
     * Filter which ConceptNames to update
     */
    where?: ConceptNameWhereInput
  }

  /**
   * ConceptName upsert
   */
  export type ConceptNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptName to update in case it exists.
     */
    where: ConceptNameWhereUniqueInput
    /**
     * In case the ConceptName found by the `where` argument doesn't exist, create a new ConceptName with this data.
     */
    create: XOR<ConceptNameCreateInput, ConceptNameUncheckedCreateInput>
    /**
     * In case the ConceptName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptNameUpdateInput, ConceptNameUncheckedUpdateInput>
  }

  /**
   * ConceptName delete
   */
  export type ConceptNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
    /**
     * Filter which ConceptName to delete.
     */
    where: ConceptNameWhereUniqueInput
  }

  /**
   * ConceptName deleteMany
   */
  export type ConceptNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptNames to delete
     */
    where?: ConceptNameWhereInput
  }

  /**
   * ConceptName without action
   */
  export type ConceptNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptName
     */
    select?: ConceptNameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNameInclude<ExtArgs> | null
  }


  /**
   * Model ConceptNumeric
   */

  export type AggregateConceptNumeric = {
    _count: ConceptNumericCountAggregateOutputType | null
    _avg: ConceptNumericAvgAggregateOutputType | null
    _sum: ConceptNumericSumAggregateOutputType | null
    _min: ConceptNumericMinAggregateOutputType | null
    _max: ConceptNumericMaxAggregateOutputType | null
  }

  export type ConceptNumericAvgAggregateOutputType = {
    hiAbsolute: number | null
    hiCritical: number | null
    hiNormal: number | null
    lowAbsolute: number | null
    lowCritical: number | null
    lowNormal: number | null
  }

  export type ConceptNumericSumAggregateOutputType = {
    hiAbsolute: number | null
    hiCritical: number | null
    hiNormal: number | null
    lowAbsolute: number | null
    lowCritical: number | null
    lowNormal: number | null
  }

  export type ConceptNumericMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    hiAbsolute: number | null
    hiCritical: number | null
    hiNormal: number | null
    lowAbsolute: number | null
    lowCritical: number | null
    lowNormal: number | null
    units: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptNumericMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    hiAbsolute: number | null
    hiCritical: number | null
    hiNormal: number | null
    lowAbsolute: number | null
    lowCritical: number | null
    lowNormal: number | null
    units: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptNumericCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptNumericAvgAggregateInputType = {
    hiAbsolute?: true
    hiCritical?: true
    hiNormal?: true
    lowAbsolute?: true
    lowCritical?: true
    lowNormal?: true
  }

  export type ConceptNumericSumAggregateInputType = {
    hiAbsolute?: true
    hiCritical?: true
    hiNormal?: true
    lowAbsolute?: true
    lowCritical?: true
    lowNormal?: true
  }

  export type ConceptNumericMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    hiAbsolute?: true
    hiCritical?: true
    hiNormal?: true
    lowAbsolute?: true
    lowCritical?: true
    lowNormal?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptNumericMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    hiAbsolute?: true
    hiCritical?: true
    hiNormal?: true
    lowAbsolute?: true
    lowCritical?: true
    lowNormal?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptNumericCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    hiAbsolute?: true
    hiCritical?: true
    hiNormal?: true
    lowAbsolute?: true
    lowCritical?: true
    lowNormal?: true
    units?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptNumericAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptNumeric to aggregate.
     */
    where?: ConceptNumericWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNumerics to fetch.
     */
    orderBy?: ConceptNumericOrderByWithRelationInput | ConceptNumericOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptNumericWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNumerics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNumerics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptNumerics
    **/
    _count?: true | ConceptNumericCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptNumericAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptNumericSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptNumericMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptNumericMaxAggregateInputType
  }

  export type GetConceptNumericAggregateType<T extends ConceptNumericAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptNumeric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptNumeric[P]>
      : GetScalarType<T[P], AggregateConceptNumeric[P]>
  }




  export type ConceptNumericGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptNumericWhereInput
    orderBy?: ConceptNumericOrderByWithAggregationInput | ConceptNumericOrderByWithAggregationInput[]
    by: ConceptNumericScalarFieldEnum[] | ConceptNumericScalarFieldEnum
    having?: ConceptNumericScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptNumericCountAggregateInputType | true
    _avg?: ConceptNumericAvgAggregateInputType
    _sum?: ConceptNumericSumAggregateInputType
    _min?: ConceptNumericMinAggregateInputType
    _max?: ConceptNumericMaxAggregateInputType
  }

  export type ConceptNumericGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptNumericCountAggregateOutputType | null
    _avg: ConceptNumericAvgAggregateOutputType | null
    _sum: ConceptNumericSumAggregateOutputType | null
    _min: ConceptNumericMinAggregateOutputType | null
    _max: ConceptNumericMaxAggregateOutputType | null
  }

  type GetConceptNumericGroupByPayload<T extends ConceptNumericGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptNumericGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptNumericGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptNumericGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptNumericGroupByOutputType[P]>
        }
      >
    >


  export type ConceptNumericSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    hiAbsolute?: boolean
    hiCritical?: boolean
    hiNormal?: boolean
    lowAbsolute?: boolean
    lowCritical?: boolean
    lowNormal?: boolean
    units?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptNumeric"]>

  export type ConceptNumericSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    hiAbsolute?: boolean
    hiCritical?: boolean
    hiNormal?: boolean
    lowAbsolute?: boolean
    lowCritical?: boolean
    lowNormal?: boolean
    units?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptNumericInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }


  export type $ConceptNumericPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptNumeric"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      hiAbsolute: number
      hiCritical: number
      hiNormal: number
      lowAbsolute: number
      lowCritical: number
      lowNormal: number
      units: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptNumeric"]>
    composites: {}
  }


  type ConceptNumericGetPayload<S extends boolean | null | undefined | ConceptNumericDefaultArgs> = $Result.GetResult<Prisma.$ConceptNumericPayload, S>

  type ConceptNumericCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptNumericFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptNumericCountAggregateInputType | true
    }

  export interface ConceptNumericDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptNumeric'], meta: { name: 'ConceptNumeric' } }
    /**
     * Find zero or one ConceptNumeric that matches the filter.
     * @param {ConceptNumericFindUniqueArgs} args - Arguments to find a ConceptNumeric
     * @example
     * // Get one ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptNumericFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptNumeric that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptNumericFindUniqueOrThrowArgs} args - Arguments to find a ConceptNumeric
     * @example
     * // Get one ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptNumericFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptNumeric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericFindFirstArgs} args - Arguments to find a ConceptNumeric
     * @example
     * // Get one ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptNumericFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptNumeric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericFindFirstOrThrowArgs} args - Arguments to find a ConceptNumeric
     * @example
     * // Get one ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptNumericFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptNumerics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptNumerics
     * const conceptNumerics = await prisma.conceptNumeric.findMany()
     * 
     * // Get first 10 ConceptNumerics
     * const conceptNumerics = await prisma.conceptNumeric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptNumericWithIdOnly = await prisma.conceptNumeric.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptNumericFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptNumeric.
     * @param {ConceptNumericCreateArgs} args - Arguments to create a ConceptNumeric.
     * @example
     * // Create one ConceptNumeric
     * const ConceptNumeric = await prisma.conceptNumeric.create({
     *   data: {
     *     // ... data to create a ConceptNumeric
     *   }
     * })
     * 
    **/
    create<T extends ConceptNumericCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericCreateArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptNumerics.
     *     @param {ConceptNumericCreateManyArgs} args - Arguments to create many ConceptNumerics.
     *     @example
     *     // Create many ConceptNumerics
     *     const conceptNumeric = await prisma.conceptNumeric.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptNumericCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptNumeric.
     * @param {ConceptNumericDeleteArgs} args - Arguments to delete one ConceptNumeric.
     * @example
     * // Delete one ConceptNumeric
     * const ConceptNumeric = await prisma.conceptNumeric.delete({
     *   where: {
     *     // ... filter to delete one ConceptNumeric
     *   }
     * })
     * 
    **/
    delete<T extends ConceptNumericDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericDeleteArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptNumeric.
     * @param {ConceptNumericUpdateArgs} args - Arguments to update one ConceptNumeric.
     * @example
     * // Update one ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptNumericUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericUpdateArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptNumerics.
     * @param {ConceptNumericDeleteManyArgs} args - Arguments to filter ConceptNumerics to delete.
     * @example
     * // Delete a few ConceptNumerics
     * const { count } = await prisma.conceptNumeric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptNumericDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptNumericDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptNumerics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptNumerics
     * const conceptNumeric = await prisma.conceptNumeric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptNumericUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptNumeric.
     * @param {ConceptNumericUpsertArgs} args - Arguments to update or create a ConceptNumeric.
     * @example
     * // Update or create a ConceptNumeric
     * const conceptNumeric = await prisma.conceptNumeric.upsert({
     *   create: {
     *     // ... data to create a ConceptNumeric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptNumeric we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptNumericUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptNumericUpsertArgs<ExtArgs>>
    ): Prisma__ConceptNumericClient<$Result.GetResult<Prisma.$ConceptNumericPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptNumerics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericCountArgs} args - Arguments to filter ConceptNumerics to count.
     * @example
     * // Count the number of ConceptNumerics
     * const count = await prisma.conceptNumeric.count({
     *   where: {
     *     // ... the filter for the ConceptNumerics we want to count
     *   }
     * })
    **/
    count<T extends ConceptNumericCountArgs>(
      args?: Subset<T, ConceptNumericCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptNumericCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptNumeric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptNumericAggregateArgs>(args: Subset<T, ConceptNumericAggregateArgs>): Prisma.PrismaPromise<GetConceptNumericAggregateType<T>>

    /**
     * Group by ConceptNumeric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptNumericGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptNumericGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptNumericGroupByArgs['orderBy'] }
        : { orderBy?: ConceptNumericGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptNumericGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptNumericGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptNumeric model
   */
  readonly fields: ConceptNumericFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptNumeric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptNumericClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptNumeric model
   */ 
  interface ConceptNumericFieldRefs {
    readonly id: FieldRef<"ConceptNumeric", 'String'>
    readonly uuid: FieldRef<"ConceptNumeric", 'String'>
    readonly conceptId: FieldRef<"ConceptNumeric", 'String'>
    readonly hiAbsolute: FieldRef<"ConceptNumeric", 'Float'>
    readonly hiCritical: FieldRef<"ConceptNumeric", 'Float'>
    readonly hiNormal: FieldRef<"ConceptNumeric", 'Float'>
    readonly lowAbsolute: FieldRef<"ConceptNumeric", 'Float'>
    readonly lowCritical: FieldRef<"ConceptNumeric", 'Float'>
    readonly lowNormal: FieldRef<"ConceptNumeric", 'Float'>
    readonly units: FieldRef<"ConceptNumeric", 'String'>
    readonly creator: FieldRef<"ConceptNumeric", 'String'>
    readonly dateCreated: FieldRef<"ConceptNumeric", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptNumeric", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptNumeric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptNumeric findUnique
   */
  export type ConceptNumericFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNumeric to fetch.
     */
    where: ConceptNumericWhereUniqueInput
  }

  /**
   * ConceptNumeric findUniqueOrThrow
   */
  export type ConceptNumericFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNumeric to fetch.
     */
    where: ConceptNumericWhereUniqueInput
  }

  /**
   * ConceptNumeric findFirst
   */
  export type ConceptNumericFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNumeric to fetch.
     */
    where?: ConceptNumericWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNumerics to fetch.
     */
    orderBy?: ConceptNumericOrderByWithRelationInput | ConceptNumericOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptNumerics.
     */
    cursor?: ConceptNumericWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNumerics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNumerics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptNumerics.
     */
    distinct?: ConceptNumericScalarFieldEnum | ConceptNumericScalarFieldEnum[]
  }

  /**
   * ConceptNumeric findFirstOrThrow
   */
  export type ConceptNumericFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNumeric to fetch.
     */
    where?: ConceptNumericWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNumerics to fetch.
     */
    orderBy?: ConceptNumericOrderByWithRelationInput | ConceptNumericOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptNumerics.
     */
    cursor?: ConceptNumericWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNumerics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNumerics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptNumerics.
     */
    distinct?: ConceptNumericScalarFieldEnum | ConceptNumericScalarFieldEnum[]
  }

  /**
   * ConceptNumeric findMany
   */
  export type ConceptNumericFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter, which ConceptNumerics to fetch.
     */
    where?: ConceptNumericWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptNumerics to fetch.
     */
    orderBy?: ConceptNumericOrderByWithRelationInput | ConceptNumericOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptNumerics.
     */
    cursor?: ConceptNumericWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptNumerics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptNumerics.
     */
    skip?: number
    distinct?: ConceptNumericScalarFieldEnum | ConceptNumericScalarFieldEnum[]
  }

  /**
   * ConceptNumeric create
   */
  export type ConceptNumericCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptNumeric.
     */
    data: XOR<ConceptNumericCreateInput, ConceptNumericUncheckedCreateInput>
  }

  /**
   * ConceptNumeric createMany
   */
  export type ConceptNumericCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptNumerics.
     */
    data: ConceptNumericCreateManyInput | ConceptNumericCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptNumeric update
   */
  export type ConceptNumericUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptNumeric.
     */
    data: XOR<ConceptNumericUpdateInput, ConceptNumericUncheckedUpdateInput>
    /**
     * Choose, which ConceptNumeric to update.
     */
    where: ConceptNumericWhereUniqueInput
  }

  /**
   * ConceptNumeric updateMany
   */
  export type ConceptNumericUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptNumerics.
     */
    data: XOR<ConceptNumericUpdateManyMutationInput, ConceptNumericUncheckedUpdateManyInput>
    /**
     * Filter which ConceptNumerics to update
     */
    where?: ConceptNumericWhereInput
  }

  /**
   * ConceptNumeric upsert
   */
  export type ConceptNumericUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptNumeric to update in case it exists.
     */
    where: ConceptNumericWhereUniqueInput
    /**
     * In case the ConceptNumeric found by the `where` argument doesn't exist, create a new ConceptNumeric with this data.
     */
    create: XOR<ConceptNumericCreateInput, ConceptNumericUncheckedCreateInput>
    /**
     * In case the ConceptNumeric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptNumericUpdateInput, ConceptNumericUncheckedUpdateInput>
  }

  /**
   * ConceptNumeric delete
   */
  export type ConceptNumericDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
    /**
     * Filter which ConceptNumeric to delete.
     */
    where: ConceptNumericWhereUniqueInput
  }

  /**
   * ConceptNumeric deleteMany
   */
  export type ConceptNumericDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptNumerics to delete
     */
    where?: ConceptNumericWhereInput
  }

  /**
   * ConceptNumeric without action
   */
  export type ConceptNumericDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptNumeric
     */
    select?: ConceptNumericSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptNumericInclude<ExtArgs> | null
  }


  /**
   * Model ConceptProposal
   */

  export type AggregateConceptProposal = {
    _count: ConceptProposalCountAggregateOutputType | null
    _min: ConceptProposalMinAggregateOutputType | null
    _max: ConceptProposalMaxAggregateOutputType | null
  }

  export type ConceptProposalMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptProposalMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptProposalCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptProposalMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptProposalMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptProposalCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptProposal to aggregate.
     */
    where?: ConceptProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptProposals to fetch.
     */
    orderBy?: ConceptProposalOrderByWithRelationInput | ConceptProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptProposals
    **/
    _count?: true | ConceptProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptProposalMaxAggregateInputType
  }

  export type GetConceptProposalAggregateType<T extends ConceptProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptProposal[P]>
      : GetScalarType<T[P], AggregateConceptProposal[P]>
  }




  export type ConceptProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptProposalWhereInput
    orderBy?: ConceptProposalOrderByWithAggregationInput | ConceptProposalOrderByWithAggregationInput[]
    by: ConceptProposalScalarFieldEnum[] | ConceptProposalScalarFieldEnum
    having?: ConceptProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptProposalCountAggregateInputType | true
    _min?: ConceptProposalMinAggregateInputType
    _max?: ConceptProposalMaxAggregateInputType
  }

  export type ConceptProposalGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptProposalCountAggregateOutputType | null
    _min: ConceptProposalMinAggregateOutputType | null
    _max: ConceptProposalMaxAggregateOutputType | null
  }

  type GetConceptProposalGroupByPayload<T extends ConceptProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptProposalGroupByOutputType[P]>
        }
      >
    >


  export type ConceptProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptProposal"]>

  export type ConceptProposalSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }


  export type $ConceptProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptProposal"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptProposal"]>
    composites: {}
  }


  type ConceptProposalGetPayload<S extends boolean | null | undefined | ConceptProposalDefaultArgs> = $Result.GetResult<Prisma.$ConceptProposalPayload, S>

  type ConceptProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptProposalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptProposalCountAggregateInputType | true
    }

  export interface ConceptProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptProposal'], meta: { name: 'ConceptProposal' } }
    /**
     * Find zero or one ConceptProposal that matches the filter.
     * @param {ConceptProposalFindUniqueArgs} args - Arguments to find a ConceptProposal
     * @example
     * // Get one ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptProposalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptProposal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptProposalFindUniqueOrThrowArgs} args - Arguments to find a ConceptProposal
     * @example
     * // Get one ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptProposalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalFindFirstArgs} args - Arguments to find a ConceptProposal
     * @example
     * // Get one ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptProposalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalFindFirstOrThrowArgs} args - Arguments to find a ConceptProposal
     * @example
     * // Get one ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptProposalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptProposals
     * const conceptProposals = await prisma.conceptProposal.findMany()
     * 
     * // Get first 10 ConceptProposals
     * const conceptProposals = await prisma.conceptProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptProposalWithIdOnly = await prisma.conceptProposal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptProposalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptProposal.
     * @param {ConceptProposalCreateArgs} args - Arguments to create a ConceptProposal.
     * @example
     * // Create one ConceptProposal
     * const ConceptProposal = await prisma.conceptProposal.create({
     *   data: {
     *     // ... data to create a ConceptProposal
     *   }
     * })
     * 
    **/
    create<T extends ConceptProposalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalCreateArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptProposals.
     *     @param {ConceptProposalCreateManyArgs} args - Arguments to create many ConceptProposals.
     *     @example
     *     // Create many ConceptProposals
     *     const conceptProposal = await prisma.conceptProposal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptProposalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptProposal.
     * @param {ConceptProposalDeleteArgs} args - Arguments to delete one ConceptProposal.
     * @example
     * // Delete one ConceptProposal
     * const ConceptProposal = await prisma.conceptProposal.delete({
     *   where: {
     *     // ... filter to delete one ConceptProposal
     *   }
     * })
     * 
    **/
    delete<T extends ConceptProposalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalDeleteArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptProposal.
     * @param {ConceptProposalUpdateArgs} args - Arguments to update one ConceptProposal.
     * @example
     * // Update one ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptProposalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalUpdateArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptProposals.
     * @param {ConceptProposalDeleteManyArgs} args - Arguments to filter ConceptProposals to delete.
     * @example
     * // Delete a few ConceptProposals
     * const { count } = await prisma.conceptProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptProposalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptProposalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptProposals
     * const conceptProposal = await prisma.conceptProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptProposalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptProposal.
     * @param {ConceptProposalUpsertArgs} args - Arguments to update or create a ConceptProposal.
     * @example
     * // Update or create a ConceptProposal
     * const conceptProposal = await prisma.conceptProposal.upsert({
     *   create: {
     *     // ... data to create a ConceptProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptProposal we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptProposalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptProposalUpsertArgs<ExtArgs>>
    ): Prisma__ConceptProposalClient<$Result.GetResult<Prisma.$ConceptProposalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalCountArgs} args - Arguments to filter ConceptProposals to count.
     * @example
     * // Count the number of ConceptProposals
     * const count = await prisma.conceptProposal.count({
     *   where: {
     *     // ... the filter for the ConceptProposals we want to count
     *   }
     * })
    **/
    count<T extends ConceptProposalCountArgs>(
      args?: Subset<T, ConceptProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptProposalAggregateArgs>(args: Subset<T, ConceptProposalAggregateArgs>): Prisma.PrismaPromise<GetConceptProposalAggregateType<T>>

    /**
     * Group by ConceptProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptProposalGroupByArgs['orderBy'] }
        : { orderBy?: ConceptProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptProposal model
   */
  readonly fields: ConceptProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptProposal model
   */ 
  interface ConceptProposalFieldRefs {
    readonly id: FieldRef<"ConceptProposal", 'String'>
    readonly uuid: FieldRef<"ConceptProposal", 'String'>
    readonly conceptId: FieldRef<"ConceptProposal", 'String'>
    readonly name: FieldRef<"ConceptProposal", 'String'>
    readonly description: FieldRef<"ConceptProposal", 'String'>
    readonly creator: FieldRef<"ConceptProposal", 'String'>
    readonly dateCreated: FieldRef<"ConceptProposal", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptProposal", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptProposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptProposal findUnique
   */
  export type ConceptProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter, which ConceptProposal to fetch.
     */
    where: ConceptProposalWhereUniqueInput
  }

  /**
   * ConceptProposal findUniqueOrThrow
   */
  export type ConceptProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter, which ConceptProposal to fetch.
     */
    where: ConceptProposalWhereUniqueInput
  }

  /**
   * ConceptProposal findFirst
   */
  export type ConceptProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter, which ConceptProposal to fetch.
     */
    where?: ConceptProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptProposals to fetch.
     */
    orderBy?: ConceptProposalOrderByWithRelationInput | ConceptProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptProposals.
     */
    cursor?: ConceptProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptProposals.
     */
    distinct?: ConceptProposalScalarFieldEnum | ConceptProposalScalarFieldEnum[]
  }

  /**
   * ConceptProposal findFirstOrThrow
   */
  export type ConceptProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter, which ConceptProposal to fetch.
     */
    where?: ConceptProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptProposals to fetch.
     */
    orderBy?: ConceptProposalOrderByWithRelationInput | ConceptProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptProposals.
     */
    cursor?: ConceptProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptProposals.
     */
    distinct?: ConceptProposalScalarFieldEnum | ConceptProposalScalarFieldEnum[]
  }

  /**
   * ConceptProposal findMany
   */
  export type ConceptProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter, which ConceptProposals to fetch.
     */
    where?: ConceptProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptProposals to fetch.
     */
    orderBy?: ConceptProposalOrderByWithRelationInput | ConceptProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptProposals.
     */
    cursor?: ConceptProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptProposals.
     */
    skip?: number
    distinct?: ConceptProposalScalarFieldEnum | ConceptProposalScalarFieldEnum[]
  }

  /**
   * ConceptProposal create
   */
  export type ConceptProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptProposal.
     */
    data: XOR<ConceptProposalCreateInput, ConceptProposalUncheckedCreateInput>
  }

  /**
   * ConceptProposal createMany
   */
  export type ConceptProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptProposals.
     */
    data: ConceptProposalCreateManyInput | ConceptProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptProposal update
   */
  export type ConceptProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptProposal.
     */
    data: XOR<ConceptProposalUpdateInput, ConceptProposalUncheckedUpdateInput>
    /**
     * Choose, which ConceptProposal to update.
     */
    where: ConceptProposalWhereUniqueInput
  }

  /**
   * ConceptProposal updateMany
   */
  export type ConceptProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptProposals.
     */
    data: XOR<ConceptProposalUpdateManyMutationInput, ConceptProposalUncheckedUpdateManyInput>
    /**
     * Filter which ConceptProposals to update
     */
    where?: ConceptProposalWhereInput
  }

  /**
   * ConceptProposal upsert
   */
  export type ConceptProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptProposal to update in case it exists.
     */
    where: ConceptProposalWhereUniqueInput
    /**
     * In case the ConceptProposal found by the `where` argument doesn't exist, create a new ConceptProposal with this data.
     */
    create: XOR<ConceptProposalCreateInput, ConceptProposalUncheckedCreateInput>
    /**
     * In case the ConceptProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptProposalUpdateInput, ConceptProposalUncheckedUpdateInput>
  }

  /**
   * ConceptProposal delete
   */
  export type ConceptProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
    /**
     * Filter which ConceptProposal to delete.
     */
    where: ConceptProposalWhereUniqueInput
  }

  /**
   * ConceptProposal deleteMany
   */
  export type ConceptProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptProposals to delete
     */
    where?: ConceptProposalWhereInput
  }

  /**
   * ConceptProposal without action
   */
  export type ConceptProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptProposal
     */
    select?: ConceptProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptProposalInclude<ExtArgs> | null
  }


  /**
   * Model ConceptSet
   */

  export type AggregateConceptSet = {
    _count: ConceptSetCountAggregateOutputType | null
    _min: ConceptSetMinAggregateOutputType | null
    _max: ConceptSetMaxAggregateOutputType | null
  }

  export type ConceptSetMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptSetMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptSetCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptSetMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptSetMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptSetCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptSet to aggregate.
     */
    where?: ConceptSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSets to fetch.
     */
    orderBy?: ConceptSetOrderByWithRelationInput | ConceptSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptSets
    **/
    _count?: true | ConceptSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptSetMaxAggregateInputType
  }

  export type GetConceptSetAggregateType<T extends ConceptSetAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptSet[P]>
      : GetScalarType<T[P], AggregateConceptSet[P]>
  }




  export type ConceptSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptSetWhereInput
    orderBy?: ConceptSetOrderByWithAggregationInput | ConceptSetOrderByWithAggregationInput[]
    by: ConceptSetScalarFieldEnum[] | ConceptSetScalarFieldEnum
    having?: ConceptSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptSetCountAggregateInputType | true
    _min?: ConceptSetMinAggregateInputType
    _max?: ConceptSetMaxAggregateInputType
  }

  export type ConceptSetGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptSetCountAggregateOutputType | null
    _min: ConceptSetMinAggregateOutputType | null
    _max: ConceptSetMaxAggregateOutputType | null
  }

  type GetConceptSetGroupByPayload<T extends ConceptSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptSetGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptSetGroupByOutputType[P]>
        }
      >
    >


  export type ConceptSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptList?: boolean | ConceptSet$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptSet"]>

  export type ConceptSetSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptSet$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptSetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptSet"
    objects: {
      conceptList: Prisma.$ConceptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptSet"]>
    composites: {}
  }


  type ConceptSetGetPayload<S extends boolean | null | undefined | ConceptSetDefaultArgs> = $Result.GetResult<Prisma.$ConceptSetPayload, S>

  type ConceptSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptSetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptSetCountAggregateInputType | true
    }

  export interface ConceptSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptSet'], meta: { name: 'ConceptSet' } }
    /**
     * Find zero or one ConceptSet that matches the filter.
     * @param {ConceptSetFindUniqueArgs} args - Arguments to find a ConceptSet
     * @example
     * // Get one ConceptSet
     * const conceptSet = await prisma.conceptSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptSetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptSet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptSetFindUniqueOrThrowArgs} args - Arguments to find a ConceptSet
     * @example
     * // Get one ConceptSet
     * const conceptSet = await prisma.conceptSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptSetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetFindFirstArgs} args - Arguments to find a ConceptSet
     * @example
     * // Get one ConceptSet
     * const conceptSet = await prisma.conceptSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptSetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetFindFirstOrThrowArgs} args - Arguments to find a ConceptSet
     * @example
     * // Get one ConceptSet
     * const conceptSet = await prisma.conceptSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptSetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptSets
     * const conceptSets = await prisma.conceptSet.findMany()
     * 
     * // Get first 10 ConceptSets
     * const conceptSets = await prisma.conceptSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptSetWithIdOnly = await prisma.conceptSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptSetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptSet.
     * @param {ConceptSetCreateArgs} args - Arguments to create a ConceptSet.
     * @example
     * // Create one ConceptSet
     * const ConceptSet = await prisma.conceptSet.create({
     *   data: {
     *     // ... data to create a ConceptSet
     *   }
     * })
     * 
    **/
    create<T extends ConceptSetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetCreateArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptSets.
     *     @param {ConceptSetCreateManyArgs} args - Arguments to create many ConceptSets.
     *     @example
     *     // Create many ConceptSets
     *     const conceptSet = await prisma.conceptSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptSetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptSet.
     * @param {ConceptSetDeleteArgs} args - Arguments to delete one ConceptSet.
     * @example
     * // Delete one ConceptSet
     * const ConceptSet = await prisma.conceptSet.delete({
     *   where: {
     *     // ... filter to delete one ConceptSet
     *   }
     * })
     * 
    **/
    delete<T extends ConceptSetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetDeleteArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptSet.
     * @param {ConceptSetUpdateArgs} args - Arguments to update one ConceptSet.
     * @example
     * // Update one ConceptSet
     * const conceptSet = await prisma.conceptSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptSetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetUpdateArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptSets.
     * @param {ConceptSetDeleteManyArgs} args - Arguments to filter ConceptSets to delete.
     * @example
     * // Delete a few ConceptSets
     * const { count } = await prisma.conceptSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptSetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptSets
     * const conceptSet = await prisma.conceptSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptSetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptSet.
     * @param {ConceptSetUpsertArgs} args - Arguments to update or create a ConceptSet.
     * @example
     * // Update or create a ConceptSet
     * const conceptSet = await prisma.conceptSet.upsert({
     *   create: {
     *     // ... data to create a ConceptSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptSet we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptSetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSetUpsertArgs<ExtArgs>>
    ): Prisma__ConceptSetClient<$Result.GetResult<Prisma.$ConceptSetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetCountArgs} args - Arguments to filter ConceptSets to count.
     * @example
     * // Count the number of ConceptSets
     * const count = await prisma.conceptSet.count({
     *   where: {
     *     // ... the filter for the ConceptSets we want to count
     *   }
     * })
    **/
    count<T extends ConceptSetCountArgs>(
      args?: Subset<T, ConceptSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptSetAggregateArgs>(args: Subset<T, ConceptSetAggregateArgs>): Prisma.PrismaPromise<GetConceptSetAggregateType<T>>

    /**
     * Group by ConceptSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptSetGroupByArgs['orderBy'] }
        : { orderBy?: ConceptSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptSet model
   */
  readonly fields: ConceptSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conceptList<T extends ConceptSet$conceptListArgs<ExtArgs> = {}>(args?: Subset<T, ConceptSet$conceptListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptSet model
   */ 
  interface ConceptSetFieldRefs {
    readonly id: FieldRef<"ConceptSet", 'String'>
    readonly uuid: FieldRef<"ConceptSet", 'String'>
    readonly name: FieldRef<"ConceptSet", 'String'>
    readonly description: FieldRef<"ConceptSet", 'String'>
    readonly creator: FieldRef<"ConceptSet", 'String'>
    readonly dateCreated: FieldRef<"ConceptSet", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptSet", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptSet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptSet findUnique
   */
  export type ConceptSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSet to fetch.
     */
    where: ConceptSetWhereUniqueInput
  }

  /**
   * ConceptSet findUniqueOrThrow
   */
  export type ConceptSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSet to fetch.
     */
    where: ConceptSetWhereUniqueInput
  }

  /**
   * ConceptSet findFirst
   */
  export type ConceptSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSet to fetch.
     */
    where?: ConceptSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSets to fetch.
     */
    orderBy?: ConceptSetOrderByWithRelationInput | ConceptSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptSets.
     */
    cursor?: ConceptSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptSets.
     */
    distinct?: ConceptSetScalarFieldEnum | ConceptSetScalarFieldEnum[]
  }

  /**
   * ConceptSet findFirstOrThrow
   */
  export type ConceptSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSet to fetch.
     */
    where?: ConceptSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSets to fetch.
     */
    orderBy?: ConceptSetOrderByWithRelationInput | ConceptSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptSets.
     */
    cursor?: ConceptSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptSets.
     */
    distinct?: ConceptSetScalarFieldEnum | ConceptSetScalarFieldEnum[]
  }

  /**
   * ConceptSet findMany
   */
  export type ConceptSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSets to fetch.
     */
    where?: ConceptSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSets to fetch.
     */
    orderBy?: ConceptSetOrderByWithRelationInput | ConceptSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptSets.
     */
    cursor?: ConceptSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSets.
     */
    skip?: number
    distinct?: ConceptSetScalarFieldEnum | ConceptSetScalarFieldEnum[]
  }

  /**
   * ConceptSet create
   */
  export type ConceptSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptSet.
     */
    data: XOR<ConceptSetCreateInput, ConceptSetUncheckedCreateInput>
  }

  /**
   * ConceptSet createMany
   */
  export type ConceptSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptSets.
     */
    data: ConceptSetCreateManyInput | ConceptSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptSet update
   */
  export type ConceptSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptSet.
     */
    data: XOR<ConceptSetUpdateInput, ConceptSetUncheckedUpdateInput>
    /**
     * Choose, which ConceptSet to update.
     */
    where: ConceptSetWhereUniqueInput
  }

  /**
   * ConceptSet updateMany
   */
  export type ConceptSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptSets.
     */
    data: XOR<ConceptSetUpdateManyMutationInput, ConceptSetUncheckedUpdateManyInput>
    /**
     * Filter which ConceptSets to update
     */
    where?: ConceptSetWhereInput
  }

  /**
   * ConceptSet upsert
   */
  export type ConceptSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptSet to update in case it exists.
     */
    where: ConceptSetWhereUniqueInput
    /**
     * In case the ConceptSet found by the `where` argument doesn't exist, create a new ConceptSet with this data.
     */
    create: XOR<ConceptSetCreateInput, ConceptSetUncheckedCreateInput>
    /**
     * In case the ConceptSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptSetUpdateInput, ConceptSetUncheckedUpdateInput>
  }

  /**
   * ConceptSet delete
   */
  export type ConceptSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
    /**
     * Filter which ConceptSet to delete.
     */
    where: ConceptSetWhereUniqueInput
  }

  /**
   * ConceptSet deleteMany
   */
  export type ConceptSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptSets to delete
     */
    where?: ConceptSetWhereInput
  }

  /**
   * ConceptSet.conceptList
   */
  export type ConceptSet$conceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    cursor?: ConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * ConceptSet without action
   */
  export type ConceptSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSet
     */
    select?: ConceptSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSetInclude<ExtArgs> | null
  }


  /**
   * Model ConceptSource
   */

  export type AggregateConceptSource = {
    _count: ConceptSourceCountAggregateOutputType | null
    _min: ConceptSourceMinAggregateOutputType | null
    _max: ConceptSourceMaxAggregateOutputType | null
  }

  export type ConceptSourceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptSourceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptSourceCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptSourceMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptSourceMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptSourceCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptSource to aggregate.
     */
    where?: ConceptSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSources to fetch.
     */
    orderBy?: ConceptSourceOrderByWithRelationInput | ConceptSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptSources
    **/
    _count?: true | ConceptSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptSourceMaxAggregateInputType
  }

  export type GetConceptSourceAggregateType<T extends ConceptSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptSource[P]>
      : GetScalarType<T[P], AggregateConceptSource[P]>
  }




  export type ConceptSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptSourceWhereInput
    orderBy?: ConceptSourceOrderByWithAggregationInput | ConceptSourceOrderByWithAggregationInput[]
    by: ConceptSourceScalarFieldEnum[] | ConceptSourceScalarFieldEnum
    having?: ConceptSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptSourceCountAggregateInputType | true
    _min?: ConceptSourceMinAggregateInputType
    _max?: ConceptSourceMaxAggregateInputType
  }

  export type ConceptSourceGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptSourceCountAggregateOutputType | null
    _min: ConceptSourceMinAggregateOutputType | null
    _max: ConceptSourceMaxAggregateOutputType | null
  }

  type GetConceptSourceGroupByPayload<T extends ConceptSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptSourceGroupByOutputType[P]>
        }
      >
    >


  export type ConceptSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    conceptList?: boolean | ConceptSource$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptSource"]>

  export type ConceptSourceSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conceptList?: boolean | ConceptSource$conceptListArgs<ExtArgs>
    _count?: boolean | ConceptSourceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConceptSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptSource"
    objects: {
      conceptList: Prisma.$ConceptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptSource"]>
    composites: {}
  }


  type ConceptSourceGetPayload<S extends boolean | null | undefined | ConceptSourceDefaultArgs> = $Result.GetResult<Prisma.$ConceptSourcePayload, S>

  type ConceptSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptSourceCountAggregateInputType | true
    }

  export interface ConceptSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptSource'], meta: { name: 'ConceptSource' } }
    /**
     * Find zero or one ConceptSource that matches the filter.
     * @param {ConceptSourceFindUniqueArgs} args - Arguments to find a ConceptSource
     * @example
     * // Get one ConceptSource
     * const conceptSource = await prisma.conceptSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptSourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptSource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptSourceFindUniqueOrThrowArgs} args - Arguments to find a ConceptSource
     * @example
     * // Get one ConceptSource
     * const conceptSource = await prisma.conceptSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptSourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceFindFirstArgs} args - Arguments to find a ConceptSource
     * @example
     * // Get one ConceptSource
     * const conceptSource = await prisma.conceptSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptSourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceFindFirstOrThrowArgs} args - Arguments to find a ConceptSource
     * @example
     * // Get one ConceptSource
     * const conceptSource = await prisma.conceptSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptSourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptSources
     * const conceptSources = await prisma.conceptSource.findMany()
     * 
     * // Get first 10 ConceptSources
     * const conceptSources = await prisma.conceptSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptSourceWithIdOnly = await prisma.conceptSource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptSourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptSource.
     * @param {ConceptSourceCreateArgs} args - Arguments to create a ConceptSource.
     * @example
     * // Create one ConceptSource
     * const ConceptSource = await prisma.conceptSource.create({
     *   data: {
     *     // ... data to create a ConceptSource
     *   }
     * })
     * 
    **/
    create<T extends ConceptSourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceCreateArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptSources.
     *     @param {ConceptSourceCreateManyArgs} args - Arguments to create many ConceptSources.
     *     @example
     *     // Create many ConceptSources
     *     const conceptSource = await prisma.conceptSource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptSourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptSource.
     * @param {ConceptSourceDeleteArgs} args - Arguments to delete one ConceptSource.
     * @example
     * // Delete one ConceptSource
     * const ConceptSource = await prisma.conceptSource.delete({
     *   where: {
     *     // ... filter to delete one ConceptSource
     *   }
     * })
     * 
    **/
    delete<T extends ConceptSourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceDeleteArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptSource.
     * @param {ConceptSourceUpdateArgs} args - Arguments to update one ConceptSource.
     * @example
     * // Update one ConceptSource
     * const conceptSource = await prisma.conceptSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptSourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceUpdateArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptSources.
     * @param {ConceptSourceDeleteManyArgs} args - Arguments to filter ConceptSources to delete.
     * @example
     * // Delete a few ConceptSources
     * const { count } = await prisma.conceptSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptSourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptSourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptSources
     * const conceptSource = await prisma.conceptSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptSourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptSource.
     * @param {ConceptSourceUpsertArgs} args - Arguments to update or create a ConceptSource.
     * @example
     * // Update or create a ConceptSource
     * const conceptSource = await prisma.conceptSource.upsert({
     *   create: {
     *     // ... data to create a ConceptSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptSource we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptSourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptSourceUpsertArgs<ExtArgs>>
    ): Prisma__ConceptSourceClient<$Result.GetResult<Prisma.$ConceptSourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceCountArgs} args - Arguments to filter ConceptSources to count.
     * @example
     * // Count the number of ConceptSources
     * const count = await prisma.conceptSource.count({
     *   where: {
     *     // ... the filter for the ConceptSources we want to count
     *   }
     * })
    **/
    count<T extends ConceptSourceCountArgs>(
      args?: Subset<T, ConceptSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptSourceAggregateArgs>(args: Subset<T, ConceptSourceAggregateArgs>): Prisma.PrismaPromise<GetConceptSourceAggregateType<T>>

    /**
     * Group by ConceptSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptSourceGroupByArgs['orderBy'] }
        : { orderBy?: ConceptSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptSource model
   */
  readonly fields: ConceptSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conceptList<T extends ConceptSource$conceptListArgs<ExtArgs> = {}>(args?: Subset<T, ConceptSource$conceptListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptSource model
   */ 
  interface ConceptSourceFieldRefs {
    readonly id: FieldRef<"ConceptSource", 'String'>
    readonly uuid: FieldRef<"ConceptSource", 'String'>
    readonly name: FieldRef<"ConceptSource", 'String'>
    readonly description: FieldRef<"ConceptSource", 'String'>
    readonly creator: FieldRef<"ConceptSource", 'String'>
    readonly dateCreated: FieldRef<"ConceptSource", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptSource", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptSource findUnique
   */
  export type ConceptSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSource to fetch.
     */
    where: ConceptSourceWhereUniqueInput
  }

  /**
   * ConceptSource findUniqueOrThrow
   */
  export type ConceptSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSource to fetch.
     */
    where: ConceptSourceWhereUniqueInput
  }

  /**
   * ConceptSource findFirst
   */
  export type ConceptSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSource to fetch.
     */
    where?: ConceptSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSources to fetch.
     */
    orderBy?: ConceptSourceOrderByWithRelationInput | ConceptSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptSources.
     */
    cursor?: ConceptSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptSources.
     */
    distinct?: ConceptSourceScalarFieldEnum | ConceptSourceScalarFieldEnum[]
  }

  /**
   * ConceptSource findFirstOrThrow
   */
  export type ConceptSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSource to fetch.
     */
    where?: ConceptSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSources to fetch.
     */
    orderBy?: ConceptSourceOrderByWithRelationInput | ConceptSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptSources.
     */
    cursor?: ConceptSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptSources.
     */
    distinct?: ConceptSourceScalarFieldEnum | ConceptSourceScalarFieldEnum[]
  }

  /**
   * ConceptSource findMany
   */
  export type ConceptSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter, which ConceptSources to fetch.
     */
    where?: ConceptSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptSources to fetch.
     */
    orderBy?: ConceptSourceOrderByWithRelationInput | ConceptSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptSources.
     */
    cursor?: ConceptSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptSources.
     */
    skip?: number
    distinct?: ConceptSourceScalarFieldEnum | ConceptSourceScalarFieldEnum[]
  }

  /**
   * ConceptSource create
   */
  export type ConceptSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptSource.
     */
    data: XOR<ConceptSourceCreateInput, ConceptSourceUncheckedCreateInput>
  }

  /**
   * ConceptSource createMany
   */
  export type ConceptSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptSources.
     */
    data: ConceptSourceCreateManyInput | ConceptSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptSource update
   */
  export type ConceptSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptSource.
     */
    data: XOR<ConceptSourceUpdateInput, ConceptSourceUncheckedUpdateInput>
    /**
     * Choose, which ConceptSource to update.
     */
    where: ConceptSourceWhereUniqueInput
  }

  /**
   * ConceptSource updateMany
   */
  export type ConceptSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptSources.
     */
    data: XOR<ConceptSourceUpdateManyMutationInput, ConceptSourceUncheckedUpdateManyInput>
    /**
     * Filter which ConceptSources to update
     */
    where?: ConceptSourceWhereInput
  }

  /**
   * ConceptSource upsert
   */
  export type ConceptSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptSource to update in case it exists.
     */
    where: ConceptSourceWhereUniqueInput
    /**
     * In case the ConceptSource found by the `where` argument doesn't exist, create a new ConceptSource with this data.
     */
    create: XOR<ConceptSourceCreateInput, ConceptSourceUncheckedCreateInput>
    /**
     * In case the ConceptSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptSourceUpdateInput, ConceptSourceUncheckedUpdateInput>
  }

  /**
   * ConceptSource delete
   */
  export type ConceptSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
    /**
     * Filter which ConceptSource to delete.
     */
    where: ConceptSourceWhereUniqueInput
  }

  /**
   * ConceptSource deleteMany
   */
  export type ConceptSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptSources to delete
     */
    where?: ConceptSourceWhereInput
  }

  /**
   * ConceptSource.conceptList
   */
  export type ConceptSource$conceptListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    cursor?: ConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * ConceptSource without action
   */
  export type ConceptSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptSource
     */
    select?: ConceptSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptSourceInclude<ExtArgs> | null
  }


  /**
   * Model ConceptWord
   */

  export type AggregateConceptWord = {
    _count: ConceptWordCountAggregateOutputType | null
    _min: ConceptWordMinAggregateOutputType | null
    _max: ConceptWordMaxAggregateOutputType | null
  }

  export type ConceptWordMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    word: string | null
    locale: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptWordMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    conceptId: string | null
    word: string | null
    locale: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ConceptWordCountAggregateOutputType = {
    id: number
    uuid: number
    conceptId: number
    word: number
    locale: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ConceptWordMinAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    word?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptWordMaxAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    word?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ConceptWordCountAggregateInputType = {
    id?: true
    uuid?: true
    conceptId?: true
    word?: true
    locale?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ConceptWordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptWord to aggregate.
     */
    where?: ConceptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptWords to fetch.
     */
    orderBy?: ConceptWordOrderByWithRelationInput | ConceptWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptWords
    **/
    _count?: true | ConceptWordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptWordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptWordMaxAggregateInputType
  }

  export type GetConceptWordAggregateType<T extends ConceptWordAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptWord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptWord[P]>
      : GetScalarType<T[P], AggregateConceptWord[P]>
  }




  export type ConceptWordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWordWhereInput
    orderBy?: ConceptWordOrderByWithAggregationInput | ConceptWordOrderByWithAggregationInput[]
    by: ConceptWordScalarFieldEnum[] | ConceptWordScalarFieldEnum
    having?: ConceptWordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptWordCountAggregateInputType | true
    _min?: ConceptWordMinAggregateInputType
    _max?: ConceptWordMaxAggregateInputType
  }

  export type ConceptWordGroupByOutputType = {
    id: string
    uuid: string
    conceptId: string
    word: string
    locale: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ConceptWordCountAggregateOutputType | null
    _min: ConceptWordMinAggregateOutputType | null
    _max: ConceptWordMaxAggregateOutputType | null
  }

  type GetConceptWordGroupByPayload<T extends ConceptWordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptWordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptWordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptWordGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptWordGroupByOutputType[P]>
        }
      >
    >


  export type ConceptWordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    word?: boolean
    locale?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptWord"]>

  export type ConceptWordSelectScalar = {
    id?: boolean
    uuid?: boolean
    conceptId?: boolean
    word?: boolean
    locale?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ConceptWordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concept?: boolean | ConceptDefaultArgs<ExtArgs>
  }


  export type $ConceptWordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptWord"
    objects: {
      concept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      conceptId: string
      word: string
      locale: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["conceptWord"]>
    composites: {}
  }


  type ConceptWordGetPayload<S extends boolean | null | undefined | ConceptWordDefaultArgs> = $Result.GetResult<Prisma.$ConceptWordPayload, S>

  type ConceptWordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptWordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptWordCountAggregateInputType | true
    }

  export interface ConceptWordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptWord'], meta: { name: 'ConceptWord' } }
    /**
     * Find zero or one ConceptWord that matches the filter.
     * @param {ConceptWordFindUniqueArgs} args - Arguments to find a ConceptWord
     * @example
     * // Get one ConceptWord
     * const conceptWord = await prisma.conceptWord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConceptWordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordFindUniqueArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConceptWord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConceptWordFindUniqueOrThrowArgs} args - Arguments to find a ConceptWord
     * @example
     * // Get one ConceptWord
     * const conceptWord = await prisma.conceptWord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConceptWordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConceptWord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordFindFirstArgs} args - Arguments to find a ConceptWord
     * @example
     * // Get one ConceptWord
     * const conceptWord = await prisma.conceptWord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConceptWordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordFindFirstArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConceptWord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordFindFirstOrThrowArgs} args - Arguments to find a ConceptWord
     * @example
     * // Get one ConceptWord
     * const conceptWord = await prisma.conceptWord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConceptWordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConceptWords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptWords
     * const conceptWords = await prisma.conceptWord.findMany()
     * 
     * // Get first 10 ConceptWords
     * const conceptWords = await prisma.conceptWord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptWordWithIdOnly = await prisma.conceptWord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConceptWordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConceptWord.
     * @param {ConceptWordCreateArgs} args - Arguments to create a ConceptWord.
     * @example
     * // Create one ConceptWord
     * const ConceptWord = await prisma.conceptWord.create({
     *   data: {
     *     // ... data to create a ConceptWord
     *   }
     * })
     * 
    **/
    create<T extends ConceptWordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordCreateArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConceptWords.
     *     @param {ConceptWordCreateManyArgs} args - Arguments to create many ConceptWords.
     *     @example
     *     // Create many ConceptWords
     *     const conceptWord = await prisma.conceptWord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConceptWordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConceptWord.
     * @param {ConceptWordDeleteArgs} args - Arguments to delete one ConceptWord.
     * @example
     * // Delete one ConceptWord
     * const ConceptWord = await prisma.conceptWord.delete({
     *   where: {
     *     // ... filter to delete one ConceptWord
     *   }
     * })
     * 
    **/
    delete<T extends ConceptWordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordDeleteArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConceptWord.
     * @param {ConceptWordUpdateArgs} args - Arguments to update one ConceptWord.
     * @example
     * // Update one ConceptWord
     * const conceptWord = await prisma.conceptWord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConceptWordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordUpdateArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConceptWords.
     * @param {ConceptWordDeleteManyArgs} args - Arguments to filter ConceptWords to delete.
     * @example
     * // Delete a few ConceptWords
     * const { count } = await prisma.conceptWord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConceptWordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConceptWordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptWords
     * const conceptWord = await prisma.conceptWord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConceptWordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptWord.
     * @param {ConceptWordUpsertArgs} args - Arguments to update or create a ConceptWord.
     * @example
     * // Update or create a ConceptWord
     * const conceptWord = await prisma.conceptWord.upsert({
     *   create: {
     *     // ... data to create a ConceptWord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptWord we want to update
     *   }
     * })
    **/
    upsert<T extends ConceptWordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConceptWordUpsertArgs<ExtArgs>>
    ): Prisma__ConceptWordClient<$Result.GetResult<Prisma.$ConceptWordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConceptWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordCountArgs} args - Arguments to filter ConceptWords to count.
     * @example
     * // Count the number of ConceptWords
     * const count = await prisma.conceptWord.count({
     *   where: {
     *     // ... the filter for the ConceptWords we want to count
     *   }
     * })
    **/
    count<T extends ConceptWordCountArgs>(
      args?: Subset<T, ConceptWordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptWordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptWordAggregateArgs>(args: Subset<T, ConceptWordAggregateArgs>): Prisma.PrismaPromise<GetConceptWordAggregateType<T>>

    /**
     * Group by ConceptWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptWordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptWordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptWordGroupByArgs['orderBy'] }
        : { orderBy?: ConceptWordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptWordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptWordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptWord model
   */
  readonly fields: ConceptWordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptWord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptWordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    concept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConceptWord model
   */ 
  interface ConceptWordFieldRefs {
    readonly id: FieldRef<"ConceptWord", 'String'>
    readonly uuid: FieldRef<"ConceptWord", 'String'>
    readonly conceptId: FieldRef<"ConceptWord", 'String'>
    readonly word: FieldRef<"ConceptWord", 'String'>
    readonly locale: FieldRef<"ConceptWord", 'String'>
    readonly creator: FieldRef<"ConceptWord", 'String'>
    readonly dateCreated: FieldRef<"ConceptWord", 'DateTime'>
    readonly lastChangedBy: FieldRef<"ConceptWord", 'String'>
    readonly lastChangedDate: FieldRef<"ConceptWord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptWord findUnique
   */
  export type ConceptWordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter, which ConceptWord to fetch.
     */
    where: ConceptWordWhereUniqueInput
  }

  /**
   * ConceptWord findUniqueOrThrow
   */
  export type ConceptWordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter, which ConceptWord to fetch.
     */
    where: ConceptWordWhereUniqueInput
  }

  /**
   * ConceptWord findFirst
   */
  export type ConceptWordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter, which ConceptWord to fetch.
     */
    where?: ConceptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptWords to fetch.
     */
    orderBy?: ConceptWordOrderByWithRelationInput | ConceptWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptWords.
     */
    cursor?: ConceptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptWords.
     */
    distinct?: ConceptWordScalarFieldEnum | ConceptWordScalarFieldEnum[]
  }

  /**
   * ConceptWord findFirstOrThrow
   */
  export type ConceptWordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter, which ConceptWord to fetch.
     */
    where?: ConceptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptWords to fetch.
     */
    orderBy?: ConceptWordOrderByWithRelationInput | ConceptWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptWords.
     */
    cursor?: ConceptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptWords.
     */
    distinct?: ConceptWordScalarFieldEnum | ConceptWordScalarFieldEnum[]
  }

  /**
   * ConceptWord findMany
   */
  export type ConceptWordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter, which ConceptWords to fetch.
     */
    where?: ConceptWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptWords to fetch.
     */
    orderBy?: ConceptWordOrderByWithRelationInput | ConceptWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptWords.
     */
    cursor?: ConceptWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptWords.
     */
    skip?: number
    distinct?: ConceptWordScalarFieldEnum | ConceptWordScalarFieldEnum[]
  }

  /**
   * ConceptWord create
   */
  export type ConceptWordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptWord.
     */
    data: XOR<ConceptWordCreateInput, ConceptWordUncheckedCreateInput>
  }

  /**
   * ConceptWord createMany
   */
  export type ConceptWordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptWords.
     */
    data: ConceptWordCreateManyInput | ConceptWordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptWord update
   */
  export type ConceptWordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptWord.
     */
    data: XOR<ConceptWordUpdateInput, ConceptWordUncheckedUpdateInput>
    /**
     * Choose, which ConceptWord to update.
     */
    where: ConceptWordWhereUniqueInput
  }

  /**
   * ConceptWord updateMany
   */
  export type ConceptWordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptWords.
     */
    data: XOR<ConceptWordUpdateManyMutationInput, ConceptWordUncheckedUpdateManyInput>
    /**
     * Filter which ConceptWords to update
     */
    where?: ConceptWordWhereInput
  }

  /**
   * ConceptWord upsert
   */
  export type ConceptWordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptWord to update in case it exists.
     */
    where: ConceptWordWhereUniqueInput
    /**
     * In case the ConceptWord found by the `where` argument doesn't exist, create a new ConceptWord with this data.
     */
    create: XOR<ConceptWordCreateInput, ConceptWordUncheckedCreateInput>
    /**
     * In case the ConceptWord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptWordUpdateInput, ConceptWordUncheckedUpdateInput>
  }

  /**
   * ConceptWord delete
   */
  export type ConceptWordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
    /**
     * Filter which ConceptWord to delete.
     */
    where: ConceptWordWhereUniqueInput
  }

  /**
   * ConceptWord deleteMany
   */
  export type ConceptWordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptWords to delete
     */
    where?: ConceptWordWhereInput
  }

  /**
   * ConceptWord without action
   */
  export type ConceptWordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptWord
     */
    select?: ConceptWordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptWordInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    name: string | null
    description: string | null
    creator: string | null
    dateCreated: Date | null
    lastChangedBy: string | null
    lastChangedDate: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    description: number
    creator: number
    dateCreated: number
    lastChangedBy: number
    lastChangedDate: number
    _all: number
  }


  export type ResourceMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    description?: true
    creator?: true
    dateCreated?: true
    lastChangedBy?: true
    lastChangedDate?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date
    lastChangedBy: string
    lastChangedDate: Date
    _count: ResourceCountAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
    formResourceList?: boolean | Resource$formResourceListArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    creator?: boolean
    dateCreated?: boolean
    lastChangedBy?: boolean
    lastChangedDate?: boolean
  }


  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formResourceList?: boolean | Resource$formResourceListArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      formResourceList: Prisma.$FormResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      name: string
      description: string
      creator: string
      dateCreated: Date
      lastChangedBy: string
      lastChangedDate: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }


  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
    **/
    create<T extends ResourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Resources.
     *     @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     *     @example
     *     // Create many Resources
     *     const resource = await prisma.resource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
    **/
    delete<T extends ResourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
    **/
    upsert<T extends ResourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    formResourceList<T extends Resource$formResourceListArgs<ExtArgs> = {}>(args?: Subset<T, Resource$formResourceListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResourcePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly uuid: FieldRef<"Resource", 'String'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly creator: FieldRef<"Resource", 'String'>
    readonly dateCreated: FieldRef<"Resource", 'DateTime'>
    readonly lastChangedBy: FieldRef<"Resource", 'String'>
    readonly lastChangedDate: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource.formResourceList
   */
  export type Resource$formResourceListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResource
     */
    select?: FormResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResourceInclude<ExtArgs> | null
    where?: FormResourceWhereInput
    orderBy?: FormResourceOrderByWithRelationInput | FormResourceOrderByWithRelationInput[]
    cursor?: FormResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResourceScalarFieldEnum | FormResourceScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    spaceTimeCoordinatesId: string | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    spaceTimeCoordinatesId: string | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    context: number
    authorId: number
    spaceTimeCoordinatesId: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    spaceTimeCoordinatesId?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    spaceTimeCoordinatesId?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    context?: true
    authorId?: true
    spaceTimeCoordinatesId?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    content: string
    context: JsonValue
    authorId: string
    spaceTimeCoordinatesId: string
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    context?: boolean
    authorId?: boolean
    spaceTimeCoordinatesId?: boolean
    author?: boolean | BlogPostAuthorDefaultArgs<ExtArgs>
    spaceTimeCoordinates?: boolean | SpaceTimeCoordinatesDefaultArgs<ExtArgs>
    tagArrowList?: boolean | BlogPost$tagArrowListArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    context?: boolean
    authorId?: boolean
    spaceTimeCoordinatesId?: boolean
  }


  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | BlogPostAuthorDefaultArgs<ExtArgs>
    spaceTimeCoordinates?: boolean | SpaceTimeCoordinatesDefaultArgs<ExtArgs>
    tagArrowList?: boolean | BlogPost$tagArrowListArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$BlogPostAuthorPayload<ExtArgs>
      spaceTimeCoordinates: Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>
      tagArrowList: Prisma.$BlogPostTagArrowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      context: Prisma.JsonValue
      authorId: string
      spaceTimeCoordinatesId: string
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }


  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
    **/
    create<T extends BlogPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BlogPosts.
     *     @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     *     @example
     *     // Create many BlogPosts
     *     const blogPost = await prisma.blogPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
    **/
    delete<T extends BlogPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
    **/
    upsert<T extends BlogPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>
    ): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    author<T extends BlogPostAuthorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostAuthorDefaultArgs<ExtArgs>>): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spaceTimeCoordinates<T extends SpaceTimeCoordinatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceTimeCoordinatesDefaultArgs<ExtArgs>>): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tagArrowList<T extends BlogPost$tagArrowListArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$tagArrowListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly context: FieldRef<"BlogPost", 'Json'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly spaceTimeCoordinatesId: FieldRef<"BlogPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost.tagArrowList
   */
  export type BlogPost$tagArrowListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    where?: BlogPostTagArrowWhereInput
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    cursor?: BlogPostTagArrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostTagArrowScalarFieldEnum | BlogPostTagArrowScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model BlogPostTag
   */

  export type AggregateBlogPostTag = {
    _count: BlogPostTagCountAggregateOutputType | null
    _min: BlogPostTagMinAggregateOutputType | null
    _max: BlogPostTagMaxAggregateOutputType | null
  }

  export type BlogPostTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    descriptor: string | null
  }

  export type BlogPostTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    descriptor: string | null
  }

  export type BlogPostTagCountAggregateOutputType = {
    id: number
    name: number
    descriptor: number
    _all: number
  }


  export type BlogPostTagMinAggregateInputType = {
    id?: true
    name?: true
    descriptor?: true
  }

  export type BlogPostTagMaxAggregateInputType = {
    id?: true
    name?: true
    descriptor?: true
  }

  export type BlogPostTagCountAggregateInputType = {
    id?: true
    name?: true
    descriptor?: true
    _all?: true
  }

  export type BlogPostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTag to aggregate.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPostTags
    **/
    _count?: true | BlogPostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostTagMaxAggregateInputType
  }

  export type GetBlogPostTagAggregateType<T extends BlogPostTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPostTag[P]>
      : GetScalarType<T[P], AggregateBlogPostTag[P]>
  }




  export type BlogPostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagWhereInput
    orderBy?: BlogPostTagOrderByWithAggregationInput | BlogPostTagOrderByWithAggregationInput[]
    by: BlogPostTagScalarFieldEnum[] | BlogPostTagScalarFieldEnum
    having?: BlogPostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostTagCountAggregateInputType | true
    _min?: BlogPostTagMinAggregateInputType
    _max?: BlogPostTagMaxAggregateInputType
  }

  export type BlogPostTagGroupByOutputType = {
    id: string
    name: string
    descriptor: string | null
    _count: BlogPostTagCountAggregateOutputType | null
    _min: BlogPostTagMinAggregateOutputType | null
    _max: BlogPostTagMaxAggregateOutputType | null
  }

  type GetBlogPostTagGroupByPayload<T extends BlogPostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    descriptor?: boolean
    postArrowList?: boolean | BlogPostTag$postArrowListArgs<ExtArgs>
    _count?: boolean | BlogPostTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostTag"]>

  export type BlogPostTagSelectScalar = {
    id?: boolean
    name?: boolean
    descriptor?: boolean
  }


  export type BlogPostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postArrowList?: boolean | BlogPostTag$postArrowListArgs<ExtArgs>
    _count?: boolean | BlogPostTagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BlogPostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPostTag"
    objects: {
      postArrowList: Prisma.$BlogPostTagArrowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      descriptor: string | null
    }, ExtArgs["result"]["blogPostTag"]>
    composites: {}
  }


  type BlogPostTagGetPayload<S extends boolean | null | undefined | BlogPostTagDefaultArgs> = $Result.GetResult<Prisma.$BlogPostTagPayload, S>

  type BlogPostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostTagCountAggregateInputType | true
    }

  export interface BlogPostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPostTag'], meta: { name: 'BlogPostTag' } }
    /**
     * Find zero or one BlogPostTag that matches the filter.
     * @param {BlogPostTagFindUniqueArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogPostTagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BlogPostTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogPostTagFindUniqueOrThrowArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogPostTagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BlogPostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindFirstArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogPostTagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagFindFirstArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BlogPostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindFirstOrThrowArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogPostTagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BlogPostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPostTags
     * const blogPostTags = await prisma.blogPostTag.findMany()
     * 
     * // Get first 10 BlogPostTags
     * const blogPostTags = await prisma.blogPostTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostTagWithIdOnly = await prisma.blogPostTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogPostTagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BlogPostTag.
     * @param {BlogPostTagCreateArgs} args - Arguments to create a BlogPostTag.
     * @example
     * // Create one BlogPostTag
     * const BlogPostTag = await prisma.blogPostTag.create({
     *   data: {
     *     // ... data to create a BlogPostTag
     *   }
     * })
     * 
    **/
    create<T extends BlogPostTagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagCreateArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BlogPostTags.
     *     @param {BlogPostTagCreateManyArgs} args - Arguments to create many BlogPostTags.
     *     @example
     *     // Create many BlogPostTags
     *     const blogPostTag = await prisma.blogPostTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogPostTagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogPostTag.
     * @param {BlogPostTagDeleteArgs} args - Arguments to delete one BlogPostTag.
     * @example
     * // Delete one BlogPostTag
     * const BlogPostTag = await prisma.blogPostTag.delete({
     *   where: {
     *     // ... filter to delete one BlogPostTag
     *   }
     * })
     * 
    **/
    delete<T extends BlogPostTagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagDeleteArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BlogPostTag.
     * @param {BlogPostTagUpdateArgs} args - Arguments to update one BlogPostTag.
     * @example
     * // Update one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogPostTagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagUpdateArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BlogPostTags.
     * @param {BlogPostTagDeleteManyArgs} args - Arguments to filter BlogPostTags to delete.
     * @example
     * // Delete a few BlogPostTags
     * const { count } = await prisma.blogPostTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogPostTagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPostTags
     * const blogPostTag = await prisma.blogPostTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogPostTagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPostTag.
     * @param {BlogPostTagUpsertArgs} args - Arguments to update or create a BlogPostTag.
     * @example
     * // Update or create a BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.upsert({
     *   create: {
     *     // ... data to create a BlogPostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPostTag we want to update
     *   }
     * })
    **/
    upsert<T extends BlogPostTagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagUpsertArgs<ExtArgs>>
    ): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BlogPostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagCountArgs} args - Arguments to filter BlogPostTags to count.
     * @example
     * // Count the number of BlogPostTags
     * const count = await prisma.blogPostTag.count({
     *   where: {
     *     // ... the filter for the BlogPostTags we want to count
     *   }
     * })
    **/
    count<T extends BlogPostTagCountArgs>(
      args?: Subset<T, BlogPostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostTagAggregateArgs>(args: Subset<T, BlogPostTagAggregateArgs>): Prisma.PrismaPromise<GetBlogPostTagAggregateType<T>>

    /**
     * Group by BlogPostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPostTag model
   */
  readonly fields: BlogPostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    postArrowList<T extends BlogPostTag$postArrowListArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostTag$postArrowListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BlogPostTag model
   */ 
  interface BlogPostTagFieldRefs {
    readonly id: FieldRef<"BlogPostTag", 'String'>
    readonly name: FieldRef<"BlogPostTag", 'String'>
    readonly descriptor: FieldRef<"BlogPostTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPostTag findUnique
   */
  export type BlogPostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag findUniqueOrThrow
   */
  export type BlogPostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag findFirst
   */
  export type BlogPostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTags.
     */
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag findFirstOrThrow
   */
  export type BlogPostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTags.
     */
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag findMany
   */
  export type BlogPostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTags to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag create
   */
  export type BlogPostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPostTag.
     */
    data: XOR<BlogPostTagCreateInput, BlogPostTagUncheckedCreateInput>
  }

  /**
   * BlogPostTag createMany
   */
  export type BlogPostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPostTags.
     */
    data: BlogPostTagCreateManyInput | BlogPostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPostTag update
   */
  export type BlogPostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPostTag.
     */
    data: XOR<BlogPostTagUpdateInput, BlogPostTagUncheckedUpdateInput>
    /**
     * Choose, which BlogPostTag to update.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag updateMany
   */
  export type BlogPostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPostTags.
     */
    data: XOR<BlogPostTagUpdateManyMutationInput, BlogPostTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostTags to update
     */
    where?: BlogPostTagWhereInput
  }

  /**
   * BlogPostTag upsert
   */
  export type BlogPostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPostTag to update in case it exists.
     */
    where: BlogPostTagWhereUniqueInput
    /**
     * In case the BlogPostTag found by the `where` argument doesn't exist, create a new BlogPostTag with this data.
     */
    create: XOR<BlogPostTagCreateInput, BlogPostTagUncheckedCreateInput>
    /**
     * In case the BlogPostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostTagUpdateInput, BlogPostTagUncheckedUpdateInput>
  }

  /**
   * BlogPostTag delete
   */
  export type BlogPostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter which BlogPostTag to delete.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag deleteMany
   */
  export type BlogPostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTags to delete
     */
    where?: BlogPostTagWhereInput
  }

  /**
   * BlogPostTag.postArrowList
   */
  export type BlogPostTag$postArrowListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    where?: BlogPostTagArrowWhereInput
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    cursor?: BlogPostTagArrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostTagArrowScalarFieldEnum | BlogPostTagArrowScalarFieldEnum[]
  }

  /**
   * BlogPostTag without action
   */
  export type BlogPostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
  }


  /**
   * Model BlogPostTagArrow
   */

  export type AggregateBlogPostTagArrow = {
    _count: BlogPostTagArrowCountAggregateOutputType | null
    _min: BlogPostTagArrowMinAggregateOutputType | null
    _max: BlogPostTagArrowMaxAggregateOutputType | null
  }

  export type BlogPostTagArrowMinAggregateOutputType = {
    id: string | null
    postId: string | null
    tagId: string | null
  }

  export type BlogPostTagArrowMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    tagId: string | null
  }

  export type BlogPostTagArrowCountAggregateOutputType = {
    id: number
    postId: number
    tagId: number
    _all: number
  }


  export type BlogPostTagArrowMinAggregateInputType = {
    id?: true
    postId?: true
    tagId?: true
  }

  export type BlogPostTagArrowMaxAggregateInputType = {
    id?: true
    postId?: true
    tagId?: true
  }

  export type BlogPostTagArrowCountAggregateInputType = {
    id?: true
    postId?: true
    tagId?: true
    _all?: true
  }

  export type BlogPostTagArrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTagArrow to aggregate.
     */
    where?: BlogPostTagArrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTagArrows to fetch.
     */
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostTagArrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTagArrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTagArrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPostTagArrows
    **/
    _count?: true | BlogPostTagArrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostTagArrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostTagArrowMaxAggregateInputType
  }

  export type GetBlogPostTagArrowAggregateType<T extends BlogPostTagArrowAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPostTagArrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPostTagArrow[P]>
      : GetScalarType<T[P], AggregateBlogPostTagArrow[P]>
  }




  export type BlogPostTagArrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagArrowWhereInput
    orderBy?: BlogPostTagArrowOrderByWithAggregationInput | BlogPostTagArrowOrderByWithAggregationInput[]
    by: BlogPostTagArrowScalarFieldEnum[] | BlogPostTagArrowScalarFieldEnum
    having?: BlogPostTagArrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostTagArrowCountAggregateInputType | true
    _min?: BlogPostTagArrowMinAggregateInputType
    _max?: BlogPostTagArrowMaxAggregateInputType
  }

  export type BlogPostTagArrowGroupByOutputType = {
    id: string
    postId: string
    tagId: string
    _count: BlogPostTagArrowCountAggregateOutputType | null
    _min: BlogPostTagArrowMinAggregateOutputType | null
    _max: BlogPostTagArrowMaxAggregateOutputType | null
  }

  type GetBlogPostTagArrowGroupByPayload<T extends BlogPostTagArrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostTagArrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostTagArrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostTagArrowGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostTagArrowGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostTagArrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    tagId?: boolean
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | BlogPostTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostTagArrow"]>

  export type BlogPostTagArrowSelectScalar = {
    id?: boolean
    postId?: boolean
    tagId?: boolean
  }


  export type BlogPostTagArrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | BlogPostDefaultArgs<ExtArgs>
    tag?: boolean | BlogPostTagDefaultArgs<ExtArgs>
  }


  export type $BlogPostTagArrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPostTagArrow"
    objects: {
      post: Prisma.$BlogPostPayload<ExtArgs>
      tag: Prisma.$BlogPostTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      tagId: string
    }, ExtArgs["result"]["blogPostTagArrow"]>
    composites: {}
  }


  type BlogPostTagArrowGetPayload<S extends boolean | null | undefined | BlogPostTagArrowDefaultArgs> = $Result.GetResult<Prisma.$BlogPostTagArrowPayload, S>

  type BlogPostTagArrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostTagArrowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostTagArrowCountAggregateInputType | true
    }

  export interface BlogPostTagArrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPostTagArrow'], meta: { name: 'BlogPostTagArrow' } }
    /**
     * Find zero or one BlogPostTagArrow that matches the filter.
     * @param {BlogPostTagArrowFindUniqueArgs} args - Arguments to find a BlogPostTagArrow
     * @example
     * // Get one BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogPostTagArrowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BlogPostTagArrow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogPostTagArrowFindUniqueOrThrowArgs} args - Arguments to find a BlogPostTagArrow
     * @example
     * // Get one BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogPostTagArrowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BlogPostTagArrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowFindFirstArgs} args - Arguments to find a BlogPostTagArrow
     * @example
     * // Get one BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogPostTagArrowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowFindFirstArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BlogPostTagArrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowFindFirstOrThrowArgs} args - Arguments to find a BlogPostTagArrow
     * @example
     * // Get one BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogPostTagArrowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BlogPostTagArrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPostTagArrows
     * const blogPostTagArrows = await prisma.blogPostTagArrow.findMany()
     * 
     * // Get first 10 BlogPostTagArrows
     * const blogPostTagArrows = await prisma.blogPostTagArrow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostTagArrowWithIdOnly = await prisma.blogPostTagArrow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogPostTagArrowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BlogPostTagArrow.
     * @param {BlogPostTagArrowCreateArgs} args - Arguments to create a BlogPostTagArrow.
     * @example
     * // Create one BlogPostTagArrow
     * const BlogPostTagArrow = await prisma.blogPostTagArrow.create({
     *   data: {
     *     // ... data to create a BlogPostTagArrow
     *   }
     * })
     * 
    **/
    create<T extends BlogPostTagArrowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowCreateArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BlogPostTagArrows.
     *     @param {BlogPostTagArrowCreateManyArgs} args - Arguments to create many BlogPostTagArrows.
     *     @example
     *     // Create many BlogPostTagArrows
     *     const blogPostTagArrow = await prisma.blogPostTagArrow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogPostTagArrowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogPostTagArrow.
     * @param {BlogPostTagArrowDeleteArgs} args - Arguments to delete one BlogPostTagArrow.
     * @example
     * // Delete one BlogPostTagArrow
     * const BlogPostTagArrow = await prisma.blogPostTagArrow.delete({
     *   where: {
     *     // ... filter to delete one BlogPostTagArrow
     *   }
     * })
     * 
    **/
    delete<T extends BlogPostTagArrowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowDeleteArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BlogPostTagArrow.
     * @param {BlogPostTagArrowUpdateArgs} args - Arguments to update one BlogPostTagArrow.
     * @example
     * // Update one BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogPostTagArrowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowUpdateArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BlogPostTagArrows.
     * @param {BlogPostTagArrowDeleteManyArgs} args - Arguments to filter BlogPostTagArrows to delete.
     * @example
     * // Delete a few BlogPostTagArrows
     * const { count } = await prisma.blogPostTagArrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogPostTagArrowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostTagArrowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostTagArrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPostTagArrows
     * const blogPostTagArrow = await prisma.blogPostTagArrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogPostTagArrowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPostTagArrow.
     * @param {BlogPostTagArrowUpsertArgs} args - Arguments to update or create a BlogPostTagArrow.
     * @example
     * // Update or create a BlogPostTagArrow
     * const blogPostTagArrow = await prisma.blogPostTagArrow.upsert({
     *   create: {
     *     // ... data to create a BlogPostTagArrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPostTagArrow we want to update
     *   }
     * })
    **/
    upsert<T extends BlogPostTagArrowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostTagArrowUpsertArgs<ExtArgs>>
    ): Prisma__BlogPostTagArrowClient<$Result.GetResult<Prisma.$BlogPostTagArrowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BlogPostTagArrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowCountArgs} args - Arguments to filter BlogPostTagArrows to count.
     * @example
     * // Count the number of BlogPostTagArrows
     * const count = await prisma.blogPostTagArrow.count({
     *   where: {
     *     // ... the filter for the BlogPostTagArrows we want to count
     *   }
     * })
    **/
    count<T extends BlogPostTagArrowCountArgs>(
      args?: Subset<T, BlogPostTagArrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostTagArrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPostTagArrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostTagArrowAggregateArgs>(args: Subset<T, BlogPostTagArrowAggregateArgs>): Prisma.PrismaPromise<GetBlogPostTagArrowAggregateType<T>>

    /**
     * Group by BlogPostTagArrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagArrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostTagArrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostTagArrowGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostTagArrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostTagArrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostTagArrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPostTagArrow model
   */
  readonly fields: BlogPostTagArrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPostTagArrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostTagArrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tag<T extends BlogPostTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostTagDefaultArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BlogPostTagArrow model
   */ 
  interface BlogPostTagArrowFieldRefs {
    readonly id: FieldRef<"BlogPostTagArrow", 'String'>
    readonly postId: FieldRef<"BlogPostTagArrow", 'String'>
    readonly tagId: FieldRef<"BlogPostTagArrow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPostTagArrow findUnique
   */
  export type BlogPostTagArrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTagArrow to fetch.
     */
    where: BlogPostTagArrowWhereUniqueInput
  }

  /**
   * BlogPostTagArrow findUniqueOrThrow
   */
  export type BlogPostTagArrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTagArrow to fetch.
     */
    where: BlogPostTagArrowWhereUniqueInput
  }

  /**
   * BlogPostTagArrow findFirst
   */
  export type BlogPostTagArrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTagArrow to fetch.
     */
    where?: BlogPostTagArrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTagArrows to fetch.
     */
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTagArrows.
     */
    cursor?: BlogPostTagArrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTagArrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTagArrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTagArrows.
     */
    distinct?: BlogPostTagArrowScalarFieldEnum | BlogPostTagArrowScalarFieldEnum[]
  }

  /**
   * BlogPostTagArrow findFirstOrThrow
   */
  export type BlogPostTagArrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTagArrow to fetch.
     */
    where?: BlogPostTagArrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTagArrows to fetch.
     */
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTagArrows.
     */
    cursor?: BlogPostTagArrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTagArrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTagArrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTagArrows.
     */
    distinct?: BlogPostTagArrowScalarFieldEnum | BlogPostTagArrowScalarFieldEnum[]
  }

  /**
   * BlogPostTagArrow findMany
   */
  export type BlogPostTagArrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTagArrows to fetch.
     */
    where?: BlogPostTagArrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTagArrows to fetch.
     */
    orderBy?: BlogPostTagArrowOrderByWithRelationInput | BlogPostTagArrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPostTagArrows.
     */
    cursor?: BlogPostTagArrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTagArrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTagArrows.
     */
    skip?: number
    distinct?: BlogPostTagArrowScalarFieldEnum | BlogPostTagArrowScalarFieldEnum[]
  }

  /**
   * BlogPostTagArrow create
   */
  export type BlogPostTagArrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPostTagArrow.
     */
    data: XOR<BlogPostTagArrowCreateInput, BlogPostTagArrowUncheckedCreateInput>
  }

  /**
   * BlogPostTagArrow createMany
   */
  export type BlogPostTagArrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPostTagArrows.
     */
    data: BlogPostTagArrowCreateManyInput | BlogPostTagArrowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPostTagArrow update
   */
  export type BlogPostTagArrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPostTagArrow.
     */
    data: XOR<BlogPostTagArrowUpdateInput, BlogPostTagArrowUncheckedUpdateInput>
    /**
     * Choose, which BlogPostTagArrow to update.
     */
    where: BlogPostTagArrowWhereUniqueInput
  }

  /**
   * BlogPostTagArrow updateMany
   */
  export type BlogPostTagArrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPostTagArrows.
     */
    data: XOR<BlogPostTagArrowUpdateManyMutationInput, BlogPostTagArrowUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostTagArrows to update
     */
    where?: BlogPostTagArrowWhereInput
  }

  /**
   * BlogPostTagArrow upsert
   */
  export type BlogPostTagArrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPostTagArrow to update in case it exists.
     */
    where: BlogPostTagArrowWhereUniqueInput
    /**
     * In case the BlogPostTagArrow found by the `where` argument doesn't exist, create a new BlogPostTagArrow with this data.
     */
    create: XOR<BlogPostTagArrowCreateInput, BlogPostTagArrowUncheckedCreateInput>
    /**
     * In case the BlogPostTagArrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostTagArrowUpdateInput, BlogPostTagArrowUncheckedUpdateInput>
  }

  /**
   * BlogPostTagArrow delete
   */
  export type BlogPostTagArrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
    /**
     * Filter which BlogPostTagArrow to delete.
     */
    where: BlogPostTagArrowWhereUniqueInput
  }

  /**
   * BlogPostTagArrow deleteMany
   */
  export type BlogPostTagArrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTagArrows to delete
     */
    where?: BlogPostTagArrowWhereInput
  }

  /**
   * BlogPostTagArrow without action
   */
  export type BlogPostTagArrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTagArrow
     */
    select?: BlogPostTagArrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagArrowInclude<ExtArgs> | null
  }


  /**
   * Model BlogPostAuthor
   */

  export type AggregateBlogPostAuthor = {
    _count: BlogPostAuthorCountAggregateOutputType | null
    _min: BlogPostAuthorMinAggregateOutputType | null
    _max: BlogPostAuthorMaxAggregateOutputType | null
  }

  export type BlogPostAuthorMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BlogPostAuthorMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BlogPostAuthorCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BlogPostAuthorMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BlogPostAuthorMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BlogPostAuthorCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BlogPostAuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostAuthor to aggregate.
     */
    where?: BlogPostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostAuthors to fetch.
     */
    orderBy?: BlogPostAuthorOrderByWithRelationInput | BlogPostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPostAuthors
    **/
    _count?: true | BlogPostAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostAuthorMaxAggregateInputType
  }

  export type GetBlogPostAuthorAggregateType<T extends BlogPostAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPostAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPostAuthor[P]>
      : GetScalarType<T[P], AggregateBlogPostAuthor[P]>
  }




  export type BlogPostAuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostAuthorWhereInput
    orderBy?: BlogPostAuthorOrderByWithAggregationInput | BlogPostAuthorOrderByWithAggregationInput[]
    by: BlogPostAuthorScalarFieldEnum[] | BlogPostAuthorScalarFieldEnum
    having?: BlogPostAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostAuthorCountAggregateInputType | true
    _min?: BlogPostAuthorMinAggregateInputType
    _max?: BlogPostAuthorMaxAggregateInputType
  }

  export type BlogPostAuthorGroupByOutputType = {
    id: string
    name: string
    _count: BlogPostAuthorCountAggregateOutputType | null
    _min: BlogPostAuthorMinAggregateOutputType | null
    _max: BlogPostAuthorMaxAggregateOutputType | null
  }

  type GetBlogPostAuthorGroupByPayload<T extends BlogPostAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostAuthorGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostAuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    blogPostList?: boolean | BlogPostAuthor$blogPostListArgs<ExtArgs>
    _count?: boolean | BlogPostAuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostAuthor"]>

  export type BlogPostAuthorSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type BlogPostAuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPostList?: boolean | BlogPostAuthor$blogPostListArgs<ExtArgs>
    _count?: boolean | BlogPostAuthorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BlogPostAuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPostAuthor"
    objects: {
      blogPostList: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["blogPostAuthor"]>
    composites: {}
  }


  type BlogPostAuthorGetPayload<S extends boolean | null | undefined | BlogPostAuthorDefaultArgs> = $Result.GetResult<Prisma.$BlogPostAuthorPayload, S>

  type BlogPostAuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostAuthorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostAuthorCountAggregateInputType | true
    }

  export interface BlogPostAuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPostAuthor'], meta: { name: 'BlogPostAuthor' } }
    /**
     * Find zero or one BlogPostAuthor that matches the filter.
     * @param {BlogPostAuthorFindUniqueArgs} args - Arguments to find a BlogPostAuthor
     * @example
     * // Get one BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogPostAuthorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BlogPostAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogPostAuthorFindUniqueOrThrowArgs} args - Arguments to find a BlogPostAuthor
     * @example
     * // Get one BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogPostAuthorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BlogPostAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorFindFirstArgs} args - Arguments to find a BlogPostAuthor
     * @example
     * // Get one BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogPostAuthorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorFindFirstArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BlogPostAuthor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorFindFirstOrThrowArgs} args - Arguments to find a BlogPostAuthor
     * @example
     * // Get one BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogPostAuthorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BlogPostAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPostAuthors
     * const blogPostAuthors = await prisma.blogPostAuthor.findMany()
     * 
     * // Get first 10 BlogPostAuthors
     * const blogPostAuthors = await prisma.blogPostAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostAuthorWithIdOnly = await prisma.blogPostAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogPostAuthorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BlogPostAuthor.
     * @param {BlogPostAuthorCreateArgs} args - Arguments to create a BlogPostAuthor.
     * @example
     * // Create one BlogPostAuthor
     * const BlogPostAuthor = await prisma.blogPostAuthor.create({
     *   data: {
     *     // ... data to create a BlogPostAuthor
     *   }
     * })
     * 
    **/
    create<T extends BlogPostAuthorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorCreateArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BlogPostAuthors.
     *     @param {BlogPostAuthorCreateManyArgs} args - Arguments to create many BlogPostAuthors.
     *     @example
     *     // Create many BlogPostAuthors
     *     const blogPostAuthor = await prisma.blogPostAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogPostAuthorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogPostAuthor.
     * @param {BlogPostAuthorDeleteArgs} args - Arguments to delete one BlogPostAuthor.
     * @example
     * // Delete one BlogPostAuthor
     * const BlogPostAuthor = await prisma.blogPostAuthor.delete({
     *   where: {
     *     // ... filter to delete one BlogPostAuthor
     *   }
     * })
     * 
    **/
    delete<T extends BlogPostAuthorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorDeleteArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BlogPostAuthor.
     * @param {BlogPostAuthorUpdateArgs} args - Arguments to update one BlogPostAuthor.
     * @example
     * // Update one BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogPostAuthorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorUpdateArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BlogPostAuthors.
     * @param {BlogPostAuthorDeleteManyArgs} args - Arguments to filter BlogPostAuthors to delete.
     * @example
     * // Delete a few BlogPostAuthors
     * const { count } = await prisma.blogPostAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogPostAuthorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogPostAuthorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPostAuthors
     * const blogPostAuthor = await prisma.blogPostAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogPostAuthorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPostAuthor.
     * @param {BlogPostAuthorUpsertArgs} args - Arguments to update or create a BlogPostAuthor.
     * @example
     * // Update or create a BlogPostAuthor
     * const blogPostAuthor = await prisma.blogPostAuthor.upsert({
     *   create: {
     *     // ... data to create a BlogPostAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPostAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends BlogPostAuthorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogPostAuthorUpsertArgs<ExtArgs>>
    ): Prisma__BlogPostAuthorClient<$Result.GetResult<Prisma.$BlogPostAuthorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BlogPostAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorCountArgs} args - Arguments to filter BlogPostAuthors to count.
     * @example
     * // Count the number of BlogPostAuthors
     * const count = await prisma.blogPostAuthor.count({
     *   where: {
     *     // ... the filter for the BlogPostAuthors we want to count
     *   }
     * })
    **/
    count<T extends BlogPostAuthorCountArgs>(
      args?: Subset<T, BlogPostAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPostAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAuthorAggregateArgs>(args: Subset<T, BlogPostAuthorAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAuthorAggregateType<T>>

    /**
     * Group by BlogPostAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostAuthorGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPostAuthor model
   */
  readonly fields: BlogPostAuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPostAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostAuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    blogPostList<T extends BlogPostAuthor$blogPostListArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostAuthor$blogPostListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BlogPostAuthor model
   */ 
  interface BlogPostAuthorFieldRefs {
    readonly id: FieldRef<"BlogPostAuthor", 'String'>
    readonly name: FieldRef<"BlogPostAuthor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlogPostAuthor findUnique
   */
  export type BlogPostAuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostAuthor to fetch.
     */
    where: BlogPostAuthorWhereUniqueInput
  }

  /**
   * BlogPostAuthor findUniqueOrThrow
   */
  export type BlogPostAuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostAuthor to fetch.
     */
    where: BlogPostAuthorWhereUniqueInput
  }

  /**
   * BlogPostAuthor findFirst
   */
  export type BlogPostAuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostAuthor to fetch.
     */
    where?: BlogPostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostAuthors to fetch.
     */
    orderBy?: BlogPostAuthorOrderByWithRelationInput | BlogPostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostAuthors.
     */
    cursor?: BlogPostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostAuthors.
     */
    distinct?: BlogPostAuthorScalarFieldEnum | BlogPostAuthorScalarFieldEnum[]
  }

  /**
   * BlogPostAuthor findFirstOrThrow
   */
  export type BlogPostAuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostAuthor to fetch.
     */
    where?: BlogPostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostAuthors to fetch.
     */
    orderBy?: BlogPostAuthorOrderByWithRelationInput | BlogPostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostAuthors.
     */
    cursor?: BlogPostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostAuthors.
     */
    distinct?: BlogPostAuthorScalarFieldEnum | BlogPostAuthorScalarFieldEnum[]
  }

  /**
   * BlogPostAuthor findMany
   */
  export type BlogPostAuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostAuthors to fetch.
     */
    where?: BlogPostAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostAuthors to fetch.
     */
    orderBy?: BlogPostAuthorOrderByWithRelationInput | BlogPostAuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPostAuthors.
     */
    cursor?: BlogPostAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostAuthors.
     */
    skip?: number
    distinct?: BlogPostAuthorScalarFieldEnum | BlogPostAuthorScalarFieldEnum[]
  }

  /**
   * BlogPostAuthor create
   */
  export type BlogPostAuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPostAuthor.
     */
    data: XOR<BlogPostAuthorCreateInput, BlogPostAuthorUncheckedCreateInput>
  }

  /**
   * BlogPostAuthor createMany
   */
  export type BlogPostAuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPostAuthors.
     */
    data: BlogPostAuthorCreateManyInput | BlogPostAuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPostAuthor update
   */
  export type BlogPostAuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPostAuthor.
     */
    data: XOR<BlogPostAuthorUpdateInput, BlogPostAuthorUncheckedUpdateInput>
    /**
     * Choose, which BlogPostAuthor to update.
     */
    where: BlogPostAuthorWhereUniqueInput
  }

  /**
   * BlogPostAuthor updateMany
   */
  export type BlogPostAuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPostAuthors.
     */
    data: XOR<BlogPostAuthorUpdateManyMutationInput, BlogPostAuthorUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostAuthors to update
     */
    where?: BlogPostAuthorWhereInput
  }

  /**
   * BlogPostAuthor upsert
   */
  export type BlogPostAuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPostAuthor to update in case it exists.
     */
    where: BlogPostAuthorWhereUniqueInput
    /**
     * In case the BlogPostAuthor found by the `where` argument doesn't exist, create a new BlogPostAuthor with this data.
     */
    create: XOR<BlogPostAuthorCreateInput, BlogPostAuthorUncheckedCreateInput>
    /**
     * In case the BlogPostAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostAuthorUpdateInput, BlogPostAuthorUncheckedUpdateInput>
  }

  /**
   * BlogPostAuthor delete
   */
  export type BlogPostAuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
    /**
     * Filter which BlogPostAuthor to delete.
     */
    where: BlogPostAuthorWhereUniqueInput
  }

  /**
   * BlogPostAuthor deleteMany
   */
  export type BlogPostAuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostAuthors to delete
     */
    where?: BlogPostAuthorWhereInput
  }

  /**
   * BlogPostAuthor.blogPostList
   */
  export type BlogPostAuthor$blogPostListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPostAuthor without action
   */
  export type BlogPostAuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostAuthor
     */
    select?: BlogPostAuthorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostAuthorInclude<ExtArgs> | null
  }


  /**
   * Model SpaceTimeCoordinates
   */

  export type AggregateSpaceTimeCoordinates = {
    _count: SpaceTimeCoordinatesCountAggregateOutputType | null
    _avg: SpaceTimeCoordinatesAvgAggregateOutputType | null
    _sum: SpaceTimeCoordinatesSumAggregateOutputType | null
    _min: SpaceTimeCoordinatesMinAggregateOutputType | null
    _max: SpaceTimeCoordinatesMaxAggregateOutputType | null
  }

  export type SpaceTimeCoordinatesAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    startTime: number | null
    pauseTime: number | null
    stopTime: number | null
  }

  export type SpaceTimeCoordinatesSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    startTime: number | null
    pauseTime: number | null
    stopTime: number | null
  }

  export type SpaceTimeCoordinatesMinAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    startTime: number | null
    pauseTime: number | null
    stopTime: number | null
    timezone: string | null
    blogPostId: string | null
  }

  export type SpaceTimeCoordinatesMaxAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    startTime: number | null
    pauseTime: number | null
    stopTime: number | null
    timezone: string | null
    blogPostId: string | null
  }

  export type SpaceTimeCoordinatesCountAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
    startTime: number
    pauseTime: number
    stopTime: number
    timezone: number
    blogPostId: number
    _all: number
  }


  export type SpaceTimeCoordinatesAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    startTime?: true
    pauseTime?: true
    stopTime?: true
  }

  export type SpaceTimeCoordinatesSumAggregateInputType = {
    latitude?: true
    longitude?: true
    startTime?: true
    pauseTime?: true
    stopTime?: true
  }

  export type SpaceTimeCoordinatesMinAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    startTime?: true
    pauseTime?: true
    stopTime?: true
    timezone?: true
    blogPostId?: true
  }

  export type SpaceTimeCoordinatesMaxAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    startTime?: true
    pauseTime?: true
    stopTime?: true
    timezone?: true
    blogPostId?: true
  }

  export type SpaceTimeCoordinatesCountAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    startTime?: true
    pauseTime?: true
    stopTime?: true
    timezone?: true
    blogPostId?: true
    _all?: true
  }

  export type SpaceTimeCoordinatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceTimeCoordinates to aggregate.
     */
    where?: SpaceTimeCoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceTimeCoordinates to fetch.
     */
    orderBy?: SpaceTimeCoordinatesOrderByWithRelationInput | SpaceTimeCoordinatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceTimeCoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceTimeCoordinates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceTimeCoordinates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaceTimeCoordinates
    **/
    _count?: true | SpaceTimeCoordinatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaceTimeCoordinatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaceTimeCoordinatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceTimeCoordinatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceTimeCoordinatesMaxAggregateInputType
  }

  export type GetSpaceTimeCoordinatesAggregateType<T extends SpaceTimeCoordinatesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaceTimeCoordinates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaceTimeCoordinates[P]>
      : GetScalarType<T[P], AggregateSpaceTimeCoordinates[P]>
  }




  export type SpaceTimeCoordinatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceTimeCoordinatesWhereInput
    orderBy?: SpaceTimeCoordinatesOrderByWithAggregationInput | SpaceTimeCoordinatesOrderByWithAggregationInput[]
    by: SpaceTimeCoordinatesScalarFieldEnum[] | SpaceTimeCoordinatesScalarFieldEnum
    having?: SpaceTimeCoordinatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceTimeCoordinatesCountAggregateInputType | true
    _avg?: SpaceTimeCoordinatesAvgAggregateInputType
    _sum?: SpaceTimeCoordinatesSumAggregateInputType
    _min?: SpaceTimeCoordinatesMinAggregateInputType
    _max?: SpaceTimeCoordinatesMaxAggregateInputType
  }

  export type SpaceTimeCoordinatesGroupByOutputType = {
    id: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime: number | null
    stopTime: number
    timezone: string
    blogPostId: string
    _count: SpaceTimeCoordinatesCountAggregateOutputType | null
    _avg: SpaceTimeCoordinatesAvgAggregateOutputType | null
    _sum: SpaceTimeCoordinatesSumAggregateOutputType | null
    _min: SpaceTimeCoordinatesMinAggregateOutputType | null
    _max: SpaceTimeCoordinatesMaxAggregateOutputType | null
  }

  type GetSpaceTimeCoordinatesGroupByPayload<T extends SpaceTimeCoordinatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceTimeCoordinatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceTimeCoordinatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceTimeCoordinatesGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceTimeCoordinatesGroupByOutputType[P]>
        }
      >
    >


  export type SpaceTimeCoordinatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    startTime?: boolean
    pauseTime?: boolean
    stopTime?: boolean
    timezone?: boolean
    blogPostId?: boolean
    BlogPost?: boolean | SpaceTimeCoordinates$BlogPostArgs<ExtArgs>
  }, ExtArgs["result"]["spaceTimeCoordinates"]>

  export type SpaceTimeCoordinatesSelectScalar = {
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    startTime?: boolean
    pauseTime?: boolean
    stopTime?: boolean
    timezone?: boolean
    blogPostId?: boolean
  }


  export type SpaceTimeCoordinatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogPost?: boolean | SpaceTimeCoordinates$BlogPostArgs<ExtArgs>
  }


  export type $SpaceTimeCoordinatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaceTimeCoordinates"
    objects: {
      BlogPost: Prisma.$BlogPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      latitude: number
      longitude: number
      startTime: number
      pauseTime: number | null
      stopTime: number
      timezone: string
      blogPostId: string
    }, ExtArgs["result"]["spaceTimeCoordinates"]>
    composites: {}
  }


  type SpaceTimeCoordinatesGetPayload<S extends boolean | null | undefined | SpaceTimeCoordinatesDefaultArgs> = $Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload, S>

  type SpaceTimeCoordinatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpaceTimeCoordinatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpaceTimeCoordinatesCountAggregateInputType | true
    }

  export interface SpaceTimeCoordinatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaceTimeCoordinates'], meta: { name: 'SpaceTimeCoordinates' } }
    /**
     * Find zero or one SpaceTimeCoordinates that matches the filter.
     * @param {SpaceTimeCoordinatesFindUniqueArgs} args - Arguments to find a SpaceTimeCoordinates
     * @example
     * // Get one SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpaceTimeCoordinatesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesFindUniqueArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpaceTimeCoordinates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpaceTimeCoordinatesFindUniqueOrThrowArgs} args - Arguments to find a SpaceTimeCoordinates
     * @example
     * // Get one SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpaceTimeCoordinatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpaceTimeCoordinates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesFindFirstArgs} args - Arguments to find a SpaceTimeCoordinates
     * @example
     * // Get one SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpaceTimeCoordinatesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesFindFirstArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpaceTimeCoordinates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesFindFirstOrThrowArgs} args - Arguments to find a SpaceTimeCoordinates
     * @example
     * // Get one SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpaceTimeCoordinatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpaceTimeCoordinates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findMany()
     * 
     * // Get first 10 SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceTimeCoordinatesWithIdOnly = await prisma.spaceTimeCoordinates.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpaceTimeCoordinatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpaceTimeCoordinates.
     * @param {SpaceTimeCoordinatesCreateArgs} args - Arguments to create a SpaceTimeCoordinates.
     * @example
     * // Create one SpaceTimeCoordinates
     * const SpaceTimeCoordinates = await prisma.spaceTimeCoordinates.create({
     *   data: {
     *     // ... data to create a SpaceTimeCoordinates
     *   }
     * })
     * 
    **/
    create<T extends SpaceTimeCoordinatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesCreateArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpaceTimeCoordinates.
     *     @param {SpaceTimeCoordinatesCreateManyArgs} args - Arguments to create many SpaceTimeCoordinates.
     *     @example
     *     // Create many SpaceTimeCoordinates
     *     const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpaceTimeCoordinatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpaceTimeCoordinates.
     * @param {SpaceTimeCoordinatesDeleteArgs} args - Arguments to delete one SpaceTimeCoordinates.
     * @example
     * // Delete one SpaceTimeCoordinates
     * const SpaceTimeCoordinates = await prisma.spaceTimeCoordinates.delete({
     *   where: {
     *     // ... filter to delete one SpaceTimeCoordinates
     *   }
     * })
     * 
    **/
    delete<T extends SpaceTimeCoordinatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesDeleteArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpaceTimeCoordinates.
     * @param {SpaceTimeCoordinatesUpdateArgs} args - Arguments to update one SpaceTimeCoordinates.
     * @example
     * // Update one SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpaceTimeCoordinatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesUpdateArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpaceTimeCoordinates.
     * @param {SpaceTimeCoordinatesDeleteManyArgs} args - Arguments to filter SpaceTimeCoordinates to delete.
     * @example
     * // Delete a few SpaceTimeCoordinates
     * const { count } = await prisma.spaceTimeCoordinates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpaceTimeCoordinatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpaceTimeCoordinatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceTimeCoordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpaceTimeCoordinatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpaceTimeCoordinates.
     * @param {SpaceTimeCoordinatesUpsertArgs} args - Arguments to update or create a SpaceTimeCoordinates.
     * @example
     * // Update or create a SpaceTimeCoordinates
     * const spaceTimeCoordinates = await prisma.spaceTimeCoordinates.upsert({
     *   create: {
     *     // ... data to create a SpaceTimeCoordinates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaceTimeCoordinates we want to update
     *   }
     * })
    **/
    upsert<T extends SpaceTimeCoordinatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpaceTimeCoordinatesUpsertArgs<ExtArgs>>
    ): Prisma__SpaceTimeCoordinatesClient<$Result.GetResult<Prisma.$SpaceTimeCoordinatesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpaceTimeCoordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesCountArgs} args - Arguments to filter SpaceTimeCoordinates to count.
     * @example
     * // Count the number of SpaceTimeCoordinates
     * const count = await prisma.spaceTimeCoordinates.count({
     *   where: {
     *     // ... the filter for the SpaceTimeCoordinates we want to count
     *   }
     * })
    **/
    count<T extends SpaceTimeCoordinatesCountArgs>(
      args?: Subset<T, SpaceTimeCoordinatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceTimeCoordinatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaceTimeCoordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceTimeCoordinatesAggregateArgs>(args: Subset<T, SpaceTimeCoordinatesAggregateArgs>): Prisma.PrismaPromise<GetSpaceTimeCoordinatesAggregateType<T>>

    /**
     * Group by SpaceTimeCoordinates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceTimeCoordinatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceTimeCoordinatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceTimeCoordinatesGroupByArgs['orderBy'] }
        : { orderBy?: SpaceTimeCoordinatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceTimeCoordinatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceTimeCoordinatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaceTimeCoordinates model
   */
  readonly fields: SpaceTimeCoordinatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceTimeCoordinates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceTimeCoordinatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    BlogPost<T extends SpaceTimeCoordinates$BlogPostArgs<ExtArgs> = {}>(args?: Subset<T, SpaceTimeCoordinates$BlogPostArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpaceTimeCoordinates model
   */ 
  interface SpaceTimeCoordinatesFieldRefs {
    readonly id: FieldRef<"SpaceTimeCoordinates", 'String'>
    readonly latitude: FieldRef<"SpaceTimeCoordinates", 'Float'>
    readonly longitude: FieldRef<"SpaceTimeCoordinates", 'Float'>
    readonly startTime: FieldRef<"SpaceTimeCoordinates", 'Float'>
    readonly pauseTime: FieldRef<"SpaceTimeCoordinates", 'Float'>
    readonly stopTime: FieldRef<"SpaceTimeCoordinates", 'Float'>
    readonly timezone: FieldRef<"SpaceTimeCoordinates", 'String'>
    readonly blogPostId: FieldRef<"SpaceTimeCoordinates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpaceTimeCoordinates findUnique
   */
  export type SpaceTimeCoordinatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter, which SpaceTimeCoordinates to fetch.
     */
    where: SpaceTimeCoordinatesWhereUniqueInput
  }

  /**
   * SpaceTimeCoordinates findUniqueOrThrow
   */
  export type SpaceTimeCoordinatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter, which SpaceTimeCoordinates to fetch.
     */
    where: SpaceTimeCoordinatesWhereUniqueInput
  }

  /**
   * SpaceTimeCoordinates findFirst
   */
  export type SpaceTimeCoordinatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter, which SpaceTimeCoordinates to fetch.
     */
    where?: SpaceTimeCoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceTimeCoordinates to fetch.
     */
    orderBy?: SpaceTimeCoordinatesOrderByWithRelationInput | SpaceTimeCoordinatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceTimeCoordinates.
     */
    cursor?: SpaceTimeCoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceTimeCoordinates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceTimeCoordinates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceTimeCoordinates.
     */
    distinct?: SpaceTimeCoordinatesScalarFieldEnum | SpaceTimeCoordinatesScalarFieldEnum[]
  }

  /**
   * SpaceTimeCoordinates findFirstOrThrow
   */
  export type SpaceTimeCoordinatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter, which SpaceTimeCoordinates to fetch.
     */
    where?: SpaceTimeCoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceTimeCoordinates to fetch.
     */
    orderBy?: SpaceTimeCoordinatesOrderByWithRelationInput | SpaceTimeCoordinatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceTimeCoordinates.
     */
    cursor?: SpaceTimeCoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceTimeCoordinates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceTimeCoordinates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceTimeCoordinates.
     */
    distinct?: SpaceTimeCoordinatesScalarFieldEnum | SpaceTimeCoordinatesScalarFieldEnum[]
  }

  /**
   * SpaceTimeCoordinates findMany
   */
  export type SpaceTimeCoordinatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter, which SpaceTimeCoordinates to fetch.
     */
    where?: SpaceTimeCoordinatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceTimeCoordinates to fetch.
     */
    orderBy?: SpaceTimeCoordinatesOrderByWithRelationInput | SpaceTimeCoordinatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaceTimeCoordinates.
     */
    cursor?: SpaceTimeCoordinatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceTimeCoordinates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceTimeCoordinates.
     */
    skip?: number
    distinct?: SpaceTimeCoordinatesScalarFieldEnum | SpaceTimeCoordinatesScalarFieldEnum[]
  }

  /**
   * SpaceTimeCoordinates create
   */
  export type SpaceTimeCoordinatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaceTimeCoordinates.
     */
    data: XOR<SpaceTimeCoordinatesCreateInput, SpaceTimeCoordinatesUncheckedCreateInput>
  }

  /**
   * SpaceTimeCoordinates createMany
   */
  export type SpaceTimeCoordinatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaceTimeCoordinates.
     */
    data: SpaceTimeCoordinatesCreateManyInput | SpaceTimeCoordinatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpaceTimeCoordinates update
   */
  export type SpaceTimeCoordinatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaceTimeCoordinates.
     */
    data: XOR<SpaceTimeCoordinatesUpdateInput, SpaceTimeCoordinatesUncheckedUpdateInput>
    /**
     * Choose, which SpaceTimeCoordinates to update.
     */
    where: SpaceTimeCoordinatesWhereUniqueInput
  }

  /**
   * SpaceTimeCoordinates updateMany
   */
  export type SpaceTimeCoordinatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaceTimeCoordinates.
     */
    data: XOR<SpaceTimeCoordinatesUpdateManyMutationInput, SpaceTimeCoordinatesUncheckedUpdateManyInput>
    /**
     * Filter which SpaceTimeCoordinates to update
     */
    where?: SpaceTimeCoordinatesWhereInput
  }

  /**
   * SpaceTimeCoordinates upsert
   */
  export type SpaceTimeCoordinatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaceTimeCoordinates to update in case it exists.
     */
    where: SpaceTimeCoordinatesWhereUniqueInput
    /**
     * In case the SpaceTimeCoordinates found by the `where` argument doesn't exist, create a new SpaceTimeCoordinates with this data.
     */
    create: XOR<SpaceTimeCoordinatesCreateInput, SpaceTimeCoordinatesUncheckedCreateInput>
    /**
     * In case the SpaceTimeCoordinates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceTimeCoordinatesUpdateInput, SpaceTimeCoordinatesUncheckedUpdateInput>
  }

  /**
   * SpaceTimeCoordinates delete
   */
  export type SpaceTimeCoordinatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
    /**
     * Filter which SpaceTimeCoordinates to delete.
     */
    where: SpaceTimeCoordinatesWhereUniqueInput
  }

  /**
   * SpaceTimeCoordinates deleteMany
   */
  export type SpaceTimeCoordinatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceTimeCoordinates to delete
     */
    where?: SpaceTimeCoordinatesWhereInput
  }

  /**
   * SpaceTimeCoordinates.BlogPost
   */
  export type SpaceTimeCoordinates$BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
  }

  /**
   * SpaceTimeCoordinates without action
   */
  export type SpaceTimeCoordinatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceTimeCoordinates
     */
    select?: SpaceTimeCoordinatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceTimeCoordinatesInclude<ExtArgs> | null
  }


  /**
   * Model BudgetEntry
   */

  export type AggregateBudgetEntry = {
    _count: BudgetEntryCountAggregateOutputType | null
    _avg: BudgetEntryAvgAggregateOutputType | null
    _sum: BudgetEntrySumAggregateOutputType | null
    _min: BudgetEntryMinAggregateOutputType | null
    _max: BudgetEntryMaxAggregateOutputType | null
  }

  export type BudgetEntryAvgAggregateOutputType = {
    cost: number | null
    discount: number | null
    promotion: number | null
    subtotal: number | null
    percentChange: number | null
  }

  export type BudgetEntrySumAggregateOutputType = {
    cost: number | null
    discount: number | null
    promotion: number | null
    subtotal: number | null
    percentChange: number | null
  }

  export type BudgetEntryMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    cost: number | null
    discount: number | null
    promotion: number | null
    subtotal: number | null
    percentChange: number | null
    createdAt: Date | null
    updatedAt: Date | null
    budgetId: string | null
  }

  export type BudgetEntryMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    cost: number | null
    discount: number | null
    promotion: number | null
    subtotal: number | null
    percentChange: number | null
    createdAt: Date | null
    updatedAt: Date | null
    budgetId: string | null
  }

  export type BudgetEntryCountAggregateOutputType = {
    id: number
    serviceId: number
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt: number
    updatedAt: number
    budgetId: number
    _all: number
  }


  export type BudgetEntryAvgAggregateInputType = {
    cost?: true
    discount?: true
    promotion?: true
    subtotal?: true
    percentChange?: true
  }

  export type BudgetEntrySumAggregateInputType = {
    cost?: true
    discount?: true
    promotion?: true
    subtotal?: true
    percentChange?: true
  }

  export type BudgetEntryMinAggregateInputType = {
    id?: true
    serviceId?: true
    cost?: true
    discount?: true
    promotion?: true
    subtotal?: true
    percentChange?: true
    createdAt?: true
    updatedAt?: true
    budgetId?: true
  }

  export type BudgetEntryMaxAggregateInputType = {
    id?: true
    serviceId?: true
    cost?: true
    discount?: true
    promotion?: true
    subtotal?: true
    percentChange?: true
    createdAt?: true
    updatedAt?: true
    budgetId?: true
  }

  export type BudgetEntryCountAggregateInputType = {
    id?: true
    serviceId?: true
    cost?: true
    discount?: true
    promotion?: true
    subtotal?: true
    percentChange?: true
    createdAt?: true
    updatedAt?: true
    budgetId?: true
    _all?: true
  }

  export type BudgetEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetEntry to aggregate.
     */
    where?: BudgetEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetEntries to fetch.
     */
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetEntries
    **/
    _count?: true | BudgetEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetEntryMaxAggregateInputType
  }

  export type GetBudgetEntryAggregateType<T extends BudgetEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetEntry[P]>
      : GetScalarType<T[P], AggregateBudgetEntry[P]>
  }




  export type BudgetEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetEntryWhereInput
    orderBy?: BudgetEntryOrderByWithAggregationInput | BudgetEntryOrderByWithAggregationInput[]
    by: BudgetEntryScalarFieldEnum[] | BudgetEntryScalarFieldEnum
    having?: BudgetEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetEntryCountAggregateInputType | true
    _avg?: BudgetEntryAvgAggregateInputType
    _sum?: BudgetEntrySumAggregateInputType
    _min?: BudgetEntryMinAggregateInputType
    _max?: BudgetEntryMaxAggregateInputType
  }

  export type BudgetEntryGroupByOutputType = {
    id: string
    serviceId: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt: Date
    updatedAt: Date
    budgetId: string
    _count: BudgetEntryCountAggregateOutputType | null
    _avg: BudgetEntryAvgAggregateOutputType | null
    _sum: BudgetEntrySumAggregateOutputType | null
    _min: BudgetEntryMinAggregateOutputType | null
    _max: BudgetEntryMaxAggregateOutputType | null
  }

  type GetBudgetEntryGroupByPayload<T extends BudgetEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetEntryGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetEntryGroupByOutputType[P]>
        }
      >
    >


  export type BudgetEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    cost?: boolean
    discount?: boolean
    promotion?: boolean
    subtotal?: boolean
    percentChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budgetId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetEntry"]>

  export type BudgetEntrySelectScalar = {
    id?: boolean
    serviceId?: boolean
    cost?: boolean
    discount?: boolean
    promotion?: boolean
    subtotal?: boolean
    percentChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budgetId?: boolean
  }


  export type BudgetEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }


  export type $BudgetEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetEntry"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      cost: number
      discount: number
      promotion: number
      subtotal: number
      percentChange: number
      createdAt: Date
      updatedAt: Date
      budgetId: string
    }, ExtArgs["result"]["budgetEntry"]>
    composites: {}
  }


  type BudgetEntryGetPayload<S extends boolean | null | undefined | BudgetEntryDefaultArgs> = $Result.GetResult<Prisma.$BudgetEntryPayload, S>

  type BudgetEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetEntryCountAggregateInputType | true
    }

  export interface BudgetEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetEntry'], meta: { name: 'BudgetEntry' } }
    /**
     * Find zero or one BudgetEntry that matches the filter.
     * @param {BudgetEntryFindUniqueArgs} args - Arguments to find a BudgetEntry
     * @example
     * // Get one BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BudgetEntryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryFindUniqueArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BudgetEntry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BudgetEntryFindUniqueOrThrowArgs} args - Arguments to find a BudgetEntry
     * @example
     * // Get one BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BudgetEntryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BudgetEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryFindFirstArgs} args - Arguments to find a BudgetEntry
     * @example
     * // Get one BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BudgetEntryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryFindFirstArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BudgetEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryFindFirstOrThrowArgs} args - Arguments to find a BudgetEntry
     * @example
     * // Get one BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BudgetEntryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BudgetEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetEntries
     * const budgetEntries = await prisma.budgetEntry.findMany()
     * 
     * // Get first 10 BudgetEntries
     * const budgetEntries = await prisma.budgetEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetEntryWithIdOnly = await prisma.budgetEntry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BudgetEntryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BudgetEntry.
     * @param {BudgetEntryCreateArgs} args - Arguments to create a BudgetEntry.
     * @example
     * // Create one BudgetEntry
     * const BudgetEntry = await prisma.budgetEntry.create({
     *   data: {
     *     // ... data to create a BudgetEntry
     *   }
     * })
     * 
    **/
    create<T extends BudgetEntryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryCreateArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BudgetEntries.
     *     @param {BudgetEntryCreateManyArgs} args - Arguments to create many BudgetEntries.
     *     @example
     *     // Create many BudgetEntries
     *     const budgetEntry = await prisma.budgetEntry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BudgetEntryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BudgetEntry.
     * @param {BudgetEntryDeleteArgs} args - Arguments to delete one BudgetEntry.
     * @example
     * // Delete one BudgetEntry
     * const BudgetEntry = await prisma.budgetEntry.delete({
     *   where: {
     *     // ... filter to delete one BudgetEntry
     *   }
     * })
     * 
    **/
    delete<T extends BudgetEntryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryDeleteArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BudgetEntry.
     * @param {BudgetEntryUpdateArgs} args - Arguments to update one BudgetEntry.
     * @example
     * // Update one BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BudgetEntryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryUpdateArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BudgetEntries.
     * @param {BudgetEntryDeleteManyArgs} args - Arguments to filter BudgetEntries to delete.
     * @example
     * // Delete a few BudgetEntries
     * const { count } = await prisma.budgetEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BudgetEntryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetEntryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetEntries
     * const budgetEntry = await prisma.budgetEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BudgetEntryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetEntry.
     * @param {BudgetEntryUpsertArgs} args - Arguments to update or create a BudgetEntry.
     * @example
     * // Update or create a BudgetEntry
     * const budgetEntry = await prisma.budgetEntry.upsert({
     *   create: {
     *     // ... data to create a BudgetEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetEntry we want to update
     *   }
     * })
    **/
    upsert<T extends BudgetEntryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetEntryUpsertArgs<ExtArgs>>
    ): Prisma__BudgetEntryClient<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BudgetEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryCountArgs} args - Arguments to filter BudgetEntries to count.
     * @example
     * // Count the number of BudgetEntries
     * const count = await prisma.budgetEntry.count({
     *   where: {
     *     // ... the filter for the BudgetEntries we want to count
     *   }
     * })
    **/
    count<T extends BudgetEntryCountArgs>(
      args?: Subset<T, BudgetEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetEntryAggregateArgs>(args: Subset<T, BudgetEntryAggregateArgs>): Prisma.PrismaPromise<GetBudgetEntryAggregateType<T>>

    /**
     * Group by BudgetEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetEntryGroupByArgs['orderBy'] }
        : { orderBy?: BudgetEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetEntry model
   */
  readonly fields: BudgetEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BudgetEntry model
   */ 
  interface BudgetEntryFieldRefs {
    readonly id: FieldRef<"BudgetEntry", 'String'>
    readonly serviceId: FieldRef<"BudgetEntry", 'String'>
    readonly cost: FieldRef<"BudgetEntry", 'Float'>
    readonly discount: FieldRef<"BudgetEntry", 'Float'>
    readonly promotion: FieldRef<"BudgetEntry", 'Float'>
    readonly subtotal: FieldRef<"BudgetEntry", 'Float'>
    readonly percentChange: FieldRef<"BudgetEntry", 'Float'>
    readonly createdAt: FieldRef<"BudgetEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"BudgetEntry", 'DateTime'>
    readonly budgetId: FieldRef<"BudgetEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BudgetEntry findUnique
   */
  export type BudgetEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetEntry to fetch.
     */
    where: BudgetEntryWhereUniqueInput
  }

  /**
   * BudgetEntry findUniqueOrThrow
   */
  export type BudgetEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetEntry to fetch.
     */
    where: BudgetEntryWhereUniqueInput
  }

  /**
   * BudgetEntry findFirst
   */
  export type BudgetEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetEntry to fetch.
     */
    where?: BudgetEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetEntries to fetch.
     */
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetEntries.
     */
    cursor?: BudgetEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetEntries.
     */
    distinct?: BudgetEntryScalarFieldEnum | BudgetEntryScalarFieldEnum[]
  }

  /**
   * BudgetEntry findFirstOrThrow
   */
  export type BudgetEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetEntry to fetch.
     */
    where?: BudgetEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetEntries to fetch.
     */
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetEntries.
     */
    cursor?: BudgetEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetEntries.
     */
    distinct?: BudgetEntryScalarFieldEnum | BudgetEntryScalarFieldEnum[]
  }

  /**
   * BudgetEntry findMany
   */
  export type BudgetEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetEntries to fetch.
     */
    where?: BudgetEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetEntries to fetch.
     */
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetEntries.
     */
    cursor?: BudgetEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetEntries.
     */
    skip?: number
    distinct?: BudgetEntryScalarFieldEnum | BudgetEntryScalarFieldEnum[]
  }

  /**
   * BudgetEntry create
   */
  export type BudgetEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetEntry.
     */
    data: XOR<BudgetEntryCreateInput, BudgetEntryUncheckedCreateInput>
  }

  /**
   * BudgetEntry createMany
   */
  export type BudgetEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetEntries.
     */
    data: BudgetEntryCreateManyInput | BudgetEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetEntry update
   */
  export type BudgetEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetEntry.
     */
    data: XOR<BudgetEntryUpdateInput, BudgetEntryUncheckedUpdateInput>
    /**
     * Choose, which BudgetEntry to update.
     */
    where: BudgetEntryWhereUniqueInput
  }

  /**
   * BudgetEntry updateMany
   */
  export type BudgetEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetEntries.
     */
    data: XOR<BudgetEntryUpdateManyMutationInput, BudgetEntryUncheckedUpdateManyInput>
    /**
     * Filter which BudgetEntries to update
     */
    where?: BudgetEntryWhereInput
  }

  /**
   * BudgetEntry upsert
   */
  export type BudgetEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetEntry to update in case it exists.
     */
    where: BudgetEntryWhereUniqueInput
    /**
     * In case the BudgetEntry found by the `where` argument doesn't exist, create a new BudgetEntry with this data.
     */
    create: XOR<BudgetEntryCreateInput, BudgetEntryUncheckedCreateInput>
    /**
     * In case the BudgetEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetEntryUpdateInput, BudgetEntryUncheckedUpdateInput>
  }

  /**
   * BudgetEntry delete
   */
  export type BudgetEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    /**
     * Filter which BudgetEntry to delete.
     */
    where: BudgetEntryWhereUniqueInput
  }

  /**
   * BudgetEntry deleteMany
   */
  export type BudgetEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetEntries to delete
     */
    where?: BudgetEntryWhereInput
  }

  /**
   * BudgetEntry without action
   */
  export type BudgetEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    description: number
    category: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    description?: true
    category?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    description: string
    category: string
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entryList?: boolean | Service$entryListArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    description?: boolean
    category?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entryList?: boolean | Service$entryListArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      entryList: Prisma.$BudgetEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      category: string
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entryList<T extends Service$entryListArgs<ExtArgs> = {}>(args?: Subset<T, Service$entryListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'String'>
    readonly metadata: FieldRef<"Service", 'Json'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.entryList
   */
  export type Service$entryListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    where?: BudgetEntryWhereInput
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    cursor?: BudgetEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetEntryScalarFieldEnum | BudgetEntryScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    fiscalYear: number | null
  }

  export type BudgetSumAggregateOutputType = {
    fiscalYear: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fiscalYear: number | null
    reportId: string | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fiscalYear: number | null
    reportId: string | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fiscalYear: number
    reportId: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    fiscalYear?: true
  }

  export type BudgetSumAggregateInputType = {
    fiscalYear?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fiscalYear?: true
    reportId?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fiscalYear?: true
    reportId?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fiscalYear?: true
    reportId?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    fiscalYear: number
    reportId: string | null
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean
    reportId?: boolean
    entryList?: boolean | Budget$entryListArgs<ExtArgs>
    report?: boolean | Budget$reportArgs<ExtArgs>
    userList?: boolean | Budget$userListArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean
    reportId?: boolean
  }


  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entryList?: boolean | Budget$entryListArgs<ExtArgs>
    report?: boolean | Budget$reportArgs<ExtArgs>
    userList?: boolean | Budget$userListArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      entryList: Prisma.$BudgetEntryPayload<ExtArgs>[]
      report: Prisma.$ReportPayload<ExtArgs> | null
      userList: Prisma.$BudgetBudUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      fiscalYear: number
      reportId: string | null
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }


  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BudgetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BudgetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BudgetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
    **/
    create<T extends BudgetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Budgets.
     *     @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     *     @example
     *     // Create many Budgets
     *     const budget = await prisma.budget.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BudgetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
    **/
    delete<T extends BudgetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BudgetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BudgetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BudgetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
    **/
    upsert<T extends BudgetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>
    ): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entryList<T extends Budget$entryListArgs<ExtArgs> = {}>(args?: Subset<T, Budget$entryListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetEntryPayload<ExtArgs>, T, 'findMany'> | Null>;

    report<T extends Budget$reportArgs<ExtArgs> = {}>(args?: Subset<T, Budget$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userList<T extends Budget$userListArgs<ExtArgs> = {}>(args?: Subset<T, Budget$userListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
    readonly fiscalYear: FieldRef<"Budget", 'Int'>
    readonly reportId: FieldRef<"Budget", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget.entryList
   */
  export type Budget$entryListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetEntry
     */
    select?: BudgetEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetEntryInclude<ExtArgs> | null
    where?: BudgetEntryWhereInput
    orderBy?: BudgetEntryOrderByWithRelationInput | BudgetEntryOrderByWithRelationInput[]
    cursor?: BudgetEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetEntryScalarFieldEnum | BudgetEntryScalarFieldEnum[]
  }

  /**
   * Budget.report
   */
  export type Budget$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Budget.userList
   */
  export type Budget$userListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    where?: BudgetBudUserWhereInput
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    cursor?: BudgetBudUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetBudUserScalarFieldEnum | BudgetBudUserScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    totalCost: number | null
    totalDiscount: number | null
    totalPromotion: number | null
    totalSubtotal: number | null
  }

  export type ReportSumAggregateOutputType = {
    totalCost: number | null
    totalDiscount: number | null
    totalPromotion: number | null
    totalSubtotal: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    totalCost: number | null
    totalDiscount: number | null
    totalPromotion: number | null
    totalSubtotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    totalCost: number | null
    totalDiscount: number | null
    totalPromotion: number | null
    totalSubtotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    budgetId: number
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    totalCost?: true
    totalDiscount?: true
    totalPromotion?: true
    totalSubtotal?: true
  }

  export type ReportSumAggregateInputType = {
    totalCost?: true
    totalDiscount?: true
    totalPromotion?: true
    totalSubtotal?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    budgetId?: true
    totalCost?: true
    totalDiscount?: true
    totalPromotion?: true
    totalSubtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    budgetId?: true
    totalCost?: true
    totalDiscount?: true
    totalPromotion?: true
    totalSubtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    budgetId?: true
    totalCost?: true
    totalDiscount?: true
    totalPromotion?: true
    totalSubtotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    budgetId: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    totalCost?: boolean
    totalDiscount?: boolean
    totalPromotion?: boolean
    totalSubtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    budgetId?: boolean
    totalCost?: boolean
    totalDiscount?: boolean
    totalPromotion?: boolean
    totalSubtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      totalCost: number
      totalDiscount: number
      totalPromotion: number
      totalSubtotal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly budgetId: FieldRef<"Report", 'String'>
    readonly totalCost: FieldRef<"Report", 'Float'>
    readonly totalDiscount: FieldRef<"Report", 'Float'>
    readonly totalPromotion: FieldRef<"Report", 'Float'>
    readonly totalSubtotal: FieldRef<"Report", 'Float'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model BudUser
   */

  export type AggregateBudUser = {
    _count: BudUserCountAggregateOutputType | null
    _min: BudUserMinAggregateOutputType | null
    _max: BudUserMaxAggregateOutputType | null
  }

  export type BudUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudUser to aggregate.
     */
    where?: BudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudUsers to fetch.
     */
    orderBy?: BudUserOrderByWithRelationInput | BudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudUsers
    **/
    _count?: true | BudUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudUserMaxAggregateInputType
  }

  export type GetBudUserAggregateType<T extends BudUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBudUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudUser[P]>
      : GetScalarType<T[P], AggregateBudUser[P]>
  }




  export type BudUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudUserWhereInput
    orderBy?: BudUserOrderByWithAggregationInput | BudUserOrderByWithAggregationInput[]
    by: BudUserScalarFieldEnum[] | BudUserScalarFieldEnum
    having?: BudUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudUserCountAggregateInputType | true
    _min?: BudUserMinAggregateInputType
    _max?: BudUserMaxAggregateInputType
  }

  export type BudUserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: BudUserCountAggregateOutputType | null
    _min: BudUserMinAggregateOutputType | null
    _max: BudUserMaxAggregateOutputType | null
  }

  type GetBudUserGroupByPayload<T extends BudUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudUserGroupByOutputType[P]>
            : GetScalarType<T[P], BudUserGroupByOutputType[P]>
        }
      >
    >


  export type BudUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budgetList?: boolean | BudUser$budgetListArgs<ExtArgs>
    eventList?: boolean | BudUser$eventListArgs<ExtArgs>
    _count?: boolean | BudUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budUser"]>

  export type BudUserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type BudUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetList?: boolean | BudUser$budgetListArgs<ExtArgs>
    eventList?: boolean | BudUser$eventListArgs<ExtArgs>
    _count?: boolean | BudUserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BudUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudUser"
    objects: {
      budgetList: Prisma.$BudgetBudUserPayload<ExtArgs>[]
      eventList: Prisma.$BudEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budUser"]>
    composites: {}
  }


  type BudUserGetPayload<S extends boolean | null | undefined | BudUserDefaultArgs> = $Result.GetResult<Prisma.$BudUserPayload, S>

  type BudUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudUserCountAggregateInputType | true
    }

  export interface BudUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudUser'], meta: { name: 'BudUser' } }
    /**
     * Find zero or one BudUser that matches the filter.
     * @param {BudUserFindUniqueArgs} args - Arguments to find a BudUser
     * @example
     * // Get one BudUser
     * const budUser = await prisma.budUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BudUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserFindUniqueArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BudUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BudUserFindUniqueOrThrowArgs} args - Arguments to find a BudUser
     * @example
     * // Get one BudUser
     * const budUser = await prisma.budUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BudUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BudUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserFindFirstArgs} args - Arguments to find a BudUser
     * @example
     * // Get one BudUser
     * const budUser = await prisma.budUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BudUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserFindFirstArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BudUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserFindFirstOrThrowArgs} args - Arguments to find a BudUser
     * @example
     * // Get one BudUser
     * const budUser = await prisma.budUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BudUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BudUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudUsers
     * const budUsers = await prisma.budUser.findMany()
     * 
     * // Get first 10 BudUsers
     * const budUsers = await prisma.budUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budUserWithIdOnly = await prisma.budUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BudUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BudUser.
     * @param {BudUserCreateArgs} args - Arguments to create a BudUser.
     * @example
     * // Create one BudUser
     * const BudUser = await prisma.budUser.create({
     *   data: {
     *     // ... data to create a BudUser
     *   }
     * })
     * 
    **/
    create<T extends BudUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserCreateArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BudUsers.
     *     @param {BudUserCreateManyArgs} args - Arguments to create many BudUsers.
     *     @example
     *     // Create many BudUsers
     *     const budUser = await prisma.budUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BudUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BudUser.
     * @param {BudUserDeleteArgs} args - Arguments to delete one BudUser.
     * @example
     * // Delete one BudUser
     * const BudUser = await prisma.budUser.delete({
     *   where: {
     *     // ... filter to delete one BudUser
     *   }
     * })
     * 
    **/
    delete<T extends BudUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserDeleteArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BudUser.
     * @param {BudUserUpdateArgs} args - Arguments to update one BudUser.
     * @example
     * // Update one BudUser
     * const budUser = await prisma.budUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BudUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserUpdateArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BudUsers.
     * @param {BudUserDeleteManyArgs} args - Arguments to filter BudUsers to delete.
     * @example
     * // Delete a few BudUsers
     * const { count } = await prisma.budUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BudUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudUsers
     * const budUser = await prisma.budUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BudUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudUser.
     * @param {BudUserUpsertArgs} args - Arguments to update or create a BudUser.
     * @example
     * // Update or create a BudUser
     * const budUser = await prisma.budUser.upsert({
     *   create: {
     *     // ... data to create a BudUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudUser we want to update
     *   }
     * })
    **/
    upsert<T extends BudUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BudUserUpsertArgs<ExtArgs>>
    ): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BudUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserCountArgs} args - Arguments to filter BudUsers to count.
     * @example
     * // Count the number of BudUsers
     * const count = await prisma.budUser.count({
     *   where: {
     *     // ... the filter for the BudUsers we want to count
     *   }
     * })
    **/
    count<T extends BudUserCountArgs>(
      args?: Subset<T, BudUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudUserAggregateArgs>(args: Subset<T, BudUserAggregateArgs>): Prisma.PrismaPromise<GetBudUserAggregateType<T>>

    /**
     * Group by BudUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudUserGroupByArgs['orderBy'] }
        : { orderBy?: BudUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudUser model
   */
  readonly fields: BudUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    budgetList<T extends BudUser$budgetListArgs<ExtArgs> = {}>(args?: Subset<T, BudUser$budgetListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    eventList<T extends BudUser$eventListArgs<ExtArgs> = {}>(args?: Subset<T, BudUser$eventListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BudUser model
   */ 
  interface BudUserFieldRefs {
    readonly id: FieldRef<"BudUser", 'String'>
    readonly name: FieldRef<"BudUser", 'String'>
    readonly email: FieldRef<"BudUser", 'String'>
    readonly password: FieldRef<"BudUser", 'String'>
    readonly createdAt: FieldRef<"BudUser", 'DateTime'>
    readonly updatedAt: FieldRef<"BudUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudUser findUnique
   */
  export type BudUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudUser to fetch.
     */
    where: BudUserWhereUniqueInput
  }

  /**
   * BudUser findUniqueOrThrow
   */
  export type BudUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudUser to fetch.
     */
    where: BudUserWhereUniqueInput
  }

  /**
   * BudUser findFirst
   */
  export type BudUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudUser to fetch.
     */
    where?: BudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudUsers to fetch.
     */
    orderBy?: BudUserOrderByWithRelationInput | BudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudUsers.
     */
    cursor?: BudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudUsers.
     */
    distinct?: BudUserScalarFieldEnum | BudUserScalarFieldEnum[]
  }

  /**
   * BudUser findFirstOrThrow
   */
  export type BudUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudUser to fetch.
     */
    where?: BudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudUsers to fetch.
     */
    orderBy?: BudUserOrderByWithRelationInput | BudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudUsers.
     */
    cursor?: BudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudUsers.
     */
    distinct?: BudUserScalarFieldEnum | BudUserScalarFieldEnum[]
  }

  /**
   * BudUser findMany
   */
  export type BudUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudUsers to fetch.
     */
    where?: BudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudUsers to fetch.
     */
    orderBy?: BudUserOrderByWithRelationInput | BudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudUsers.
     */
    cursor?: BudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudUsers.
     */
    skip?: number
    distinct?: BudUserScalarFieldEnum | BudUserScalarFieldEnum[]
  }

  /**
   * BudUser create
   */
  export type BudUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BudUser.
     */
    data: XOR<BudUserCreateInput, BudUserUncheckedCreateInput>
  }

  /**
   * BudUser createMany
   */
  export type BudUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudUsers.
     */
    data: BudUserCreateManyInput | BudUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudUser update
   */
  export type BudUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BudUser.
     */
    data: XOR<BudUserUpdateInput, BudUserUncheckedUpdateInput>
    /**
     * Choose, which BudUser to update.
     */
    where: BudUserWhereUniqueInput
  }

  /**
   * BudUser updateMany
   */
  export type BudUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudUsers.
     */
    data: XOR<BudUserUpdateManyMutationInput, BudUserUncheckedUpdateManyInput>
    /**
     * Filter which BudUsers to update
     */
    where?: BudUserWhereInput
  }

  /**
   * BudUser upsert
   */
  export type BudUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BudUser to update in case it exists.
     */
    where: BudUserWhereUniqueInput
    /**
     * In case the BudUser found by the `where` argument doesn't exist, create a new BudUser with this data.
     */
    create: XOR<BudUserCreateInput, BudUserUncheckedCreateInput>
    /**
     * In case the BudUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudUserUpdateInput, BudUserUncheckedUpdateInput>
  }

  /**
   * BudUser delete
   */
  export type BudUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
    /**
     * Filter which BudUser to delete.
     */
    where: BudUserWhereUniqueInput
  }

  /**
   * BudUser deleteMany
   */
  export type BudUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudUsers to delete
     */
    where?: BudUserWhereInput
  }

  /**
   * BudUser.budgetList
   */
  export type BudUser$budgetListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    where?: BudgetBudUserWhereInput
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    cursor?: BudgetBudUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetBudUserScalarFieldEnum | BudgetBudUserScalarFieldEnum[]
  }

  /**
   * BudUser.eventList
   */
  export type BudUser$eventListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    where?: BudEventWhereInput
    orderBy?: BudEventOrderByWithRelationInput | BudEventOrderByWithRelationInput[]
    cursor?: BudEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudEventScalarFieldEnum | BudEventScalarFieldEnum[]
  }

  /**
   * BudUser without action
   */
  export type BudUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudUser
     */
    select?: BudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudUserInclude<ExtArgs> | null
  }


  /**
   * Model BudgetBudUser
   */

  export type AggregateBudgetBudUser = {
    _count: BudgetBudUserCountAggregateOutputType | null
    _min: BudgetBudUserMinAggregateOutputType | null
    _max: BudgetBudUserMaxAggregateOutputType | null
  }

  export type BudgetBudUserMinAggregateOutputType = {
    userId: string | null
    budgetId: string | null
    role: string | null
    ability: string | null
    category: string | null
  }

  export type BudgetBudUserMaxAggregateOutputType = {
    userId: string | null
    budgetId: string | null
    role: string | null
    ability: string | null
    category: string | null
  }

  export type BudgetBudUserCountAggregateOutputType = {
    userId: number
    budgetId: number
    role: number
    ability: number
    category: number
    _all: number
  }


  export type BudgetBudUserMinAggregateInputType = {
    userId?: true
    budgetId?: true
    role?: true
    ability?: true
    category?: true
  }

  export type BudgetBudUserMaxAggregateInputType = {
    userId?: true
    budgetId?: true
    role?: true
    ability?: true
    category?: true
  }

  export type BudgetBudUserCountAggregateInputType = {
    userId?: true
    budgetId?: true
    role?: true
    ability?: true
    category?: true
    _all?: true
  }

  export type BudgetBudUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetBudUser to aggregate.
     */
    where?: BudgetBudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetBudUsers to fetch.
     */
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetBudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetBudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetBudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetBudUsers
    **/
    _count?: true | BudgetBudUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetBudUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetBudUserMaxAggregateInputType
  }

  export type GetBudgetBudUserAggregateType<T extends BudgetBudUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetBudUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetBudUser[P]>
      : GetScalarType<T[P], AggregateBudgetBudUser[P]>
  }




  export type BudgetBudUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetBudUserWhereInput
    orderBy?: BudgetBudUserOrderByWithAggregationInput | BudgetBudUserOrderByWithAggregationInput[]
    by: BudgetBudUserScalarFieldEnum[] | BudgetBudUserScalarFieldEnum
    having?: BudgetBudUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetBudUserCountAggregateInputType | true
    _min?: BudgetBudUserMinAggregateInputType
    _max?: BudgetBudUserMaxAggregateInputType
  }

  export type BudgetBudUserGroupByOutputType = {
    userId: string
    budgetId: string
    role: string
    ability: string
    category: string
    _count: BudgetBudUserCountAggregateOutputType | null
    _min: BudgetBudUserMinAggregateOutputType | null
    _max: BudgetBudUserMaxAggregateOutputType | null
  }

  type GetBudgetBudUserGroupByPayload<T extends BudgetBudUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetBudUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetBudUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetBudUserGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetBudUserGroupByOutputType[P]>
        }
      >
    >


  export type BudgetBudUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    budgetId?: boolean
    role?: boolean
    ability?: boolean
    category?: boolean
    user?: boolean | BudUserDefaultArgs<ExtArgs>
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetBudUser"]>

  export type BudgetBudUserSelectScalar = {
    userId?: boolean
    budgetId?: boolean
    role?: boolean
    ability?: boolean
    category?: boolean
  }


  export type BudgetBudUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BudUserDefaultArgs<ExtArgs>
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }


  export type $BudgetBudUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetBudUser"
    objects: {
      user: Prisma.$BudUserPayload<ExtArgs>
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      budgetId: string
      role: string
      ability: string
      category: string
    }, ExtArgs["result"]["budgetBudUser"]>
    composites: {}
  }


  type BudgetBudUserGetPayload<S extends boolean | null | undefined | BudgetBudUserDefaultArgs> = $Result.GetResult<Prisma.$BudgetBudUserPayload, S>

  type BudgetBudUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetBudUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetBudUserCountAggregateInputType | true
    }

  export interface BudgetBudUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetBudUser'], meta: { name: 'BudgetBudUser' } }
    /**
     * Find zero or one BudgetBudUser that matches the filter.
     * @param {BudgetBudUserFindUniqueArgs} args - Arguments to find a BudgetBudUser
     * @example
     * // Get one BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BudgetBudUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserFindUniqueArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BudgetBudUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BudgetBudUserFindUniqueOrThrowArgs} args - Arguments to find a BudgetBudUser
     * @example
     * // Get one BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BudgetBudUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BudgetBudUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserFindFirstArgs} args - Arguments to find a BudgetBudUser
     * @example
     * // Get one BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BudgetBudUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserFindFirstArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BudgetBudUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserFindFirstOrThrowArgs} args - Arguments to find a BudgetBudUser
     * @example
     * // Get one BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BudgetBudUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BudgetBudUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetBudUsers
     * const budgetBudUsers = await prisma.budgetBudUser.findMany()
     * 
     * // Get first 10 BudgetBudUsers
     * const budgetBudUsers = await prisma.budgetBudUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const budgetBudUserWithUserIdOnly = await prisma.budgetBudUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends BudgetBudUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BudgetBudUser.
     * @param {BudgetBudUserCreateArgs} args - Arguments to create a BudgetBudUser.
     * @example
     * // Create one BudgetBudUser
     * const BudgetBudUser = await prisma.budgetBudUser.create({
     *   data: {
     *     // ... data to create a BudgetBudUser
     *   }
     * })
     * 
    **/
    create<T extends BudgetBudUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserCreateArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BudgetBudUsers.
     *     @param {BudgetBudUserCreateManyArgs} args - Arguments to create many BudgetBudUsers.
     *     @example
     *     // Create many BudgetBudUsers
     *     const budgetBudUser = await prisma.budgetBudUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BudgetBudUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BudgetBudUser.
     * @param {BudgetBudUserDeleteArgs} args - Arguments to delete one BudgetBudUser.
     * @example
     * // Delete one BudgetBudUser
     * const BudgetBudUser = await prisma.budgetBudUser.delete({
     *   where: {
     *     // ... filter to delete one BudgetBudUser
     *   }
     * })
     * 
    **/
    delete<T extends BudgetBudUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserDeleteArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BudgetBudUser.
     * @param {BudgetBudUserUpdateArgs} args - Arguments to update one BudgetBudUser.
     * @example
     * // Update one BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BudgetBudUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserUpdateArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BudgetBudUsers.
     * @param {BudgetBudUserDeleteManyArgs} args - Arguments to filter BudgetBudUsers to delete.
     * @example
     * // Delete a few BudgetBudUsers
     * const { count } = await prisma.budgetBudUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BudgetBudUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudgetBudUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetBudUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetBudUsers
     * const budgetBudUser = await prisma.budgetBudUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BudgetBudUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetBudUser.
     * @param {BudgetBudUserUpsertArgs} args - Arguments to update or create a BudgetBudUser.
     * @example
     * // Update or create a BudgetBudUser
     * const budgetBudUser = await prisma.budgetBudUser.upsert({
     *   create: {
     *     // ... data to create a BudgetBudUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetBudUser we want to update
     *   }
     * })
    **/
    upsert<T extends BudgetBudUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BudgetBudUserUpsertArgs<ExtArgs>>
    ): Prisma__BudgetBudUserClient<$Result.GetResult<Prisma.$BudgetBudUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BudgetBudUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserCountArgs} args - Arguments to filter BudgetBudUsers to count.
     * @example
     * // Count the number of BudgetBudUsers
     * const count = await prisma.budgetBudUser.count({
     *   where: {
     *     // ... the filter for the BudgetBudUsers we want to count
     *   }
     * })
    **/
    count<T extends BudgetBudUserCountArgs>(
      args?: Subset<T, BudgetBudUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetBudUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetBudUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetBudUserAggregateArgs>(args: Subset<T, BudgetBudUserAggregateArgs>): Prisma.PrismaPromise<GetBudgetBudUserAggregateType<T>>

    /**
     * Group by BudgetBudUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetBudUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetBudUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetBudUserGroupByArgs['orderBy'] }
        : { orderBy?: BudgetBudUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetBudUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetBudUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetBudUser model
   */
  readonly fields: BudgetBudUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetBudUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetBudUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends BudUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudUserDefaultArgs<ExtArgs>>): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BudgetBudUser model
   */ 
  interface BudgetBudUserFieldRefs {
    readonly userId: FieldRef<"BudgetBudUser", 'String'>
    readonly budgetId: FieldRef<"BudgetBudUser", 'String'>
    readonly role: FieldRef<"BudgetBudUser", 'String'>
    readonly ability: FieldRef<"BudgetBudUser", 'String'>
    readonly category: FieldRef<"BudgetBudUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BudgetBudUser findUnique
   */
  export type BudgetBudUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudgetBudUser to fetch.
     */
    where: BudgetBudUserWhereUniqueInput
  }

  /**
   * BudgetBudUser findUniqueOrThrow
   */
  export type BudgetBudUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudgetBudUser to fetch.
     */
    where: BudgetBudUserWhereUniqueInput
  }

  /**
   * BudgetBudUser findFirst
   */
  export type BudgetBudUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudgetBudUser to fetch.
     */
    where?: BudgetBudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetBudUsers to fetch.
     */
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetBudUsers.
     */
    cursor?: BudgetBudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetBudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetBudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetBudUsers.
     */
    distinct?: BudgetBudUserScalarFieldEnum | BudgetBudUserScalarFieldEnum[]
  }

  /**
   * BudgetBudUser findFirstOrThrow
   */
  export type BudgetBudUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudgetBudUser to fetch.
     */
    where?: BudgetBudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetBudUsers to fetch.
     */
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetBudUsers.
     */
    cursor?: BudgetBudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetBudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetBudUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetBudUsers.
     */
    distinct?: BudgetBudUserScalarFieldEnum | BudgetBudUserScalarFieldEnum[]
  }

  /**
   * BudgetBudUser findMany
   */
  export type BudgetBudUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter, which BudgetBudUsers to fetch.
     */
    where?: BudgetBudUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetBudUsers to fetch.
     */
    orderBy?: BudgetBudUserOrderByWithRelationInput | BudgetBudUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetBudUsers.
     */
    cursor?: BudgetBudUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetBudUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetBudUsers.
     */
    skip?: number
    distinct?: BudgetBudUserScalarFieldEnum | BudgetBudUserScalarFieldEnum[]
  }

  /**
   * BudgetBudUser create
   */
  export type BudgetBudUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetBudUser.
     */
    data: XOR<BudgetBudUserCreateInput, BudgetBudUserUncheckedCreateInput>
  }

  /**
   * BudgetBudUser createMany
   */
  export type BudgetBudUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetBudUsers.
     */
    data: BudgetBudUserCreateManyInput | BudgetBudUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetBudUser update
   */
  export type BudgetBudUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetBudUser.
     */
    data: XOR<BudgetBudUserUpdateInput, BudgetBudUserUncheckedUpdateInput>
    /**
     * Choose, which BudgetBudUser to update.
     */
    where: BudgetBudUserWhereUniqueInput
  }

  /**
   * BudgetBudUser updateMany
   */
  export type BudgetBudUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetBudUsers.
     */
    data: XOR<BudgetBudUserUpdateManyMutationInput, BudgetBudUserUncheckedUpdateManyInput>
    /**
     * Filter which BudgetBudUsers to update
     */
    where?: BudgetBudUserWhereInput
  }

  /**
   * BudgetBudUser upsert
   */
  export type BudgetBudUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetBudUser to update in case it exists.
     */
    where: BudgetBudUserWhereUniqueInput
    /**
     * In case the BudgetBudUser found by the `where` argument doesn't exist, create a new BudgetBudUser with this data.
     */
    create: XOR<BudgetBudUserCreateInput, BudgetBudUserUncheckedCreateInput>
    /**
     * In case the BudgetBudUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetBudUserUpdateInput, BudgetBudUserUncheckedUpdateInput>
  }

  /**
   * BudgetBudUser delete
   */
  export type BudgetBudUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
    /**
     * Filter which BudgetBudUser to delete.
     */
    where: BudgetBudUserWhereUniqueInput
  }

  /**
   * BudgetBudUser deleteMany
   */
  export type BudgetBudUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetBudUsers to delete
     */
    where?: BudgetBudUserWhereInput
  }

  /**
   * BudgetBudUser without action
   */
  export type BudgetBudUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetBudUser
     */
    select?: BudgetBudUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetBudUserInclude<ExtArgs> | null
  }


  /**
   * Model BudEvent
   */

  export type AggregateBudEvent = {
    _count: BudEventCountAggregateOutputType | null
    _min: BudEventMinAggregateOutputType | null
    _max: BudEventMaxAggregateOutputType | null
  }

  export type BudEventMinAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    budUserId: string | null
    createdAt: Date | null
  }

  export type BudEventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    budUserId: string | null
    createdAt: Date | null
  }

  export type BudEventCountAggregateOutputType = {
    id: number
    type: number
    description: number
    categoryList: number
    metadata: number
    budUserId: number
    createdAt: number
    _all: number
  }


  export type BudEventMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    budUserId?: true
    createdAt?: true
  }

  export type BudEventMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    budUserId?: true
    createdAt?: true
  }

  export type BudEventCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    categoryList?: true
    metadata?: true
    budUserId?: true
    createdAt?: true
    _all?: true
  }

  export type BudEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudEvent to aggregate.
     */
    where?: BudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudEvents to fetch.
     */
    orderBy?: BudEventOrderByWithRelationInput | BudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudEvents
    **/
    _count?: true | BudEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudEventMaxAggregateInputType
  }

  export type GetBudEventAggregateType<T extends BudEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBudEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudEvent[P]>
      : GetScalarType<T[P], AggregateBudEvent[P]>
  }




  export type BudEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudEventWhereInput
    orderBy?: BudEventOrderByWithAggregationInput | BudEventOrderByWithAggregationInput[]
    by: BudEventScalarFieldEnum[] | BudEventScalarFieldEnum
    having?: BudEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudEventCountAggregateInputType | true
    _min?: BudEventMinAggregateInputType
    _max?: BudEventMaxAggregateInputType
  }

  export type BudEventGroupByOutputType = {
    id: string
    type: string
    description: string
    categoryList: string[]
    metadata: JsonValue
    budUserId: string
    createdAt: Date
    _count: BudEventCountAggregateOutputType | null
    _min: BudEventMinAggregateOutputType | null
    _max: BudEventMaxAggregateOutputType | null
  }

  type GetBudEventGroupByPayload<T extends BudEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudEventGroupByOutputType[P]>
            : GetScalarType<T[P], BudEventGroupByOutputType[P]>
        }
      >
    >


  export type BudEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    categoryList?: boolean
    metadata?: boolean
    budUserId?: boolean
    createdAt?: boolean
    budUser?: boolean | BudUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budEvent"]>

  export type BudEventSelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    categoryList?: boolean
    metadata?: boolean
    budUserId?: boolean
    createdAt?: boolean
  }


  export type BudEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budUser?: boolean | BudUserDefaultArgs<ExtArgs>
  }


  export type $BudEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudEvent"
    objects: {
      budUser: Prisma.$BudUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      description: string
      categoryList: string[]
      metadata: Prisma.JsonValue
      budUserId: string
      createdAt: Date
    }, ExtArgs["result"]["budEvent"]>
    composites: {}
  }


  type BudEventGetPayload<S extends boolean | null | undefined | BudEventDefaultArgs> = $Result.GetResult<Prisma.$BudEventPayload, S>

  type BudEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudEventCountAggregateInputType | true
    }

  export interface BudEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudEvent'], meta: { name: 'BudEvent' } }
    /**
     * Find zero or one BudEvent that matches the filter.
     * @param {BudEventFindUniqueArgs} args - Arguments to find a BudEvent
     * @example
     * // Get one BudEvent
     * const budEvent = await prisma.budEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BudEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventFindUniqueArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BudEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BudEventFindUniqueOrThrowArgs} args - Arguments to find a BudEvent
     * @example
     * // Get one BudEvent
     * const budEvent = await prisma.budEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BudEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BudEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventFindFirstArgs} args - Arguments to find a BudEvent
     * @example
     * // Get one BudEvent
     * const budEvent = await prisma.budEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BudEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventFindFirstArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BudEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventFindFirstOrThrowArgs} args - Arguments to find a BudEvent
     * @example
     * // Get one BudEvent
     * const budEvent = await prisma.budEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BudEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BudEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudEvents
     * const budEvents = await prisma.budEvent.findMany()
     * 
     * // Get first 10 BudEvents
     * const budEvents = await prisma.budEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budEventWithIdOnly = await prisma.budEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BudEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BudEvent.
     * @param {BudEventCreateArgs} args - Arguments to create a BudEvent.
     * @example
     * // Create one BudEvent
     * const BudEvent = await prisma.budEvent.create({
     *   data: {
     *     // ... data to create a BudEvent
     *   }
     * })
     * 
    **/
    create<T extends BudEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventCreateArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BudEvents.
     *     @param {BudEventCreateManyArgs} args - Arguments to create many BudEvents.
     *     @example
     *     // Create many BudEvents
     *     const budEvent = await prisma.budEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BudEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BudEvent.
     * @param {BudEventDeleteArgs} args - Arguments to delete one BudEvent.
     * @example
     * // Delete one BudEvent
     * const BudEvent = await prisma.budEvent.delete({
     *   where: {
     *     // ... filter to delete one BudEvent
     *   }
     * })
     * 
    **/
    delete<T extends BudEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventDeleteArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BudEvent.
     * @param {BudEventUpdateArgs} args - Arguments to update one BudEvent.
     * @example
     * // Update one BudEvent
     * const budEvent = await prisma.budEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BudEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventUpdateArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BudEvents.
     * @param {BudEventDeleteManyArgs} args - Arguments to filter BudEvents to delete.
     * @example
     * // Delete a few BudEvents
     * const { count } = await prisma.budEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BudEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BudEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudEvents
     * const budEvent = await prisma.budEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BudEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudEvent.
     * @param {BudEventUpsertArgs} args - Arguments to update or create a BudEvent.
     * @example
     * // Update or create a BudEvent
     * const budEvent = await prisma.budEvent.upsert({
     *   create: {
     *     // ... data to create a BudEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudEvent we want to update
     *   }
     * })
    **/
    upsert<T extends BudEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BudEventUpsertArgs<ExtArgs>>
    ): Prisma__BudEventClient<$Result.GetResult<Prisma.$BudEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BudEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventCountArgs} args - Arguments to filter BudEvents to count.
     * @example
     * // Count the number of BudEvents
     * const count = await prisma.budEvent.count({
     *   where: {
     *     // ... the filter for the BudEvents we want to count
     *   }
     * })
    **/
    count<T extends BudEventCountArgs>(
      args?: Subset<T, BudEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudEventAggregateArgs>(args: Subset<T, BudEventAggregateArgs>): Prisma.PrismaPromise<GetBudEventAggregateType<T>>

    /**
     * Group by BudEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudEventGroupByArgs['orderBy'] }
        : { orderBy?: BudEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudEvent model
   */
  readonly fields: BudEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    budUser<T extends BudUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudUserDefaultArgs<ExtArgs>>): Prisma__BudUserClient<$Result.GetResult<Prisma.$BudUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BudEvent model
   */ 
  interface BudEventFieldRefs {
    readonly id: FieldRef<"BudEvent", 'String'>
    readonly type: FieldRef<"BudEvent", 'String'>
    readonly description: FieldRef<"BudEvent", 'String'>
    readonly categoryList: FieldRef<"BudEvent", 'String[]'>
    readonly metadata: FieldRef<"BudEvent", 'Json'>
    readonly budUserId: FieldRef<"BudEvent", 'String'>
    readonly createdAt: FieldRef<"BudEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudEvent findUnique
   */
  export type BudEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter, which BudEvent to fetch.
     */
    where: BudEventWhereUniqueInput
  }

  /**
   * BudEvent findUniqueOrThrow
   */
  export type BudEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter, which BudEvent to fetch.
     */
    where: BudEventWhereUniqueInput
  }

  /**
   * BudEvent findFirst
   */
  export type BudEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter, which BudEvent to fetch.
     */
    where?: BudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudEvents to fetch.
     */
    orderBy?: BudEventOrderByWithRelationInput | BudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudEvents.
     */
    cursor?: BudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudEvents.
     */
    distinct?: BudEventScalarFieldEnum | BudEventScalarFieldEnum[]
  }

  /**
   * BudEvent findFirstOrThrow
   */
  export type BudEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter, which BudEvent to fetch.
     */
    where?: BudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudEvents to fetch.
     */
    orderBy?: BudEventOrderByWithRelationInput | BudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudEvents.
     */
    cursor?: BudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudEvents.
     */
    distinct?: BudEventScalarFieldEnum | BudEventScalarFieldEnum[]
  }

  /**
   * BudEvent findMany
   */
  export type BudEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter, which BudEvents to fetch.
     */
    where?: BudEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudEvents to fetch.
     */
    orderBy?: BudEventOrderByWithRelationInput | BudEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudEvents.
     */
    cursor?: BudEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudEvents.
     */
    skip?: number
    distinct?: BudEventScalarFieldEnum | BudEventScalarFieldEnum[]
  }

  /**
   * BudEvent create
   */
  export type BudEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * The data needed to create a BudEvent.
     */
    data: XOR<BudEventCreateInput, BudEventUncheckedCreateInput>
  }

  /**
   * BudEvent createMany
   */
  export type BudEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudEvents.
     */
    data: BudEventCreateManyInput | BudEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudEvent update
   */
  export type BudEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * The data needed to update a BudEvent.
     */
    data: XOR<BudEventUpdateInput, BudEventUncheckedUpdateInput>
    /**
     * Choose, which BudEvent to update.
     */
    where: BudEventWhereUniqueInput
  }

  /**
   * BudEvent updateMany
   */
  export type BudEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudEvents.
     */
    data: XOR<BudEventUpdateManyMutationInput, BudEventUncheckedUpdateManyInput>
    /**
     * Filter which BudEvents to update
     */
    where?: BudEventWhereInput
  }

  /**
   * BudEvent upsert
   */
  export type BudEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * The filter to search for the BudEvent to update in case it exists.
     */
    where: BudEventWhereUniqueInput
    /**
     * In case the BudEvent found by the `where` argument doesn't exist, create a new BudEvent with this data.
     */
    create: XOR<BudEventCreateInput, BudEventUncheckedCreateInput>
    /**
     * In case the BudEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudEventUpdateInput, BudEventUncheckedUpdateInput>
  }

  /**
   * BudEvent delete
   */
  export type BudEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
    /**
     * Filter which BudEvent to delete.
     */
    where: BudEventWhereUniqueInput
  }

  /**
   * BudEvent deleteMany
   */
  export type BudEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudEvents to delete
     */
    where?: BudEventWhereInput
  }

  /**
   * BudEvent without action
   */
  export type BudEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudEvent
     */
    select?: BudEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    appointmentTypeId: 'appointmentTypeId',
    patientId: 'patientId',
    locationId: 'locationId',
    providerId: 'providerId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    voided: 'voided',
    voidedBy: 'voidedBy',
    dateVoided: 'dateVoided',
    voidReason: 'voidReason',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AppointmentTypeScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    duration: 'duration',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type AppointmentTypeScalarFieldEnum = (typeof AppointmentTypeScalarFieldEnum)[keyof typeof AppointmentTypeScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    address1: 'address1',
    address2: 'address2',
    city: 'city',
    stateProvince: 'stateProvince',
    country: 'country',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    givenName: 'givenName',
    middleName: 'middleName',
    familyName: 'familyName',
    gender: 'gender',
    birthdate: 'birthdate',
    dead: 'dead',
    deathDate: 'deathDate',
    causeOfDeath: 'causeOfDeath',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    identifier: 'identifier',
    description: 'description',
    voided: 'voided',
    voidedBy: 'voidedBy',
    dateVoided: 'dateVoided',
    voidReason: 'voidReason',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    version: 'version',
    retired: 'retired',
    retiredBy: 'retiredBy',
    dateRetired: 'dateRetired',
    retiredReason: 'retiredReason',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate',
    fieldId: 'fieldId'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormEncounterScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    formId: 'formId',
    encounterId: 'encounterId',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FormEncounterScalarFieldEnum = (typeof FormEncounterScalarFieldEnum)[keyof typeof FormEncounterScalarFieldEnum]


  export const FormResourceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    formId: 'formId',
    resourceId: 'resourceId',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FormResourceScalarFieldEnum = (typeof FormResourceScalarFieldEnum)[keyof typeof FormResourceScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    formId: 'formId',
    encounterId: 'encounterId',
    submissionDate: 'submissionDate',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const FieldScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    fieldType: 'fieldType',
    conceptId: 'conceptId',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export const FieldAnswerScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    formSubmissionId: 'formSubmissionId',
    fieldId: 'fieldId',
    value: 'value',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FieldAnswerScalarFieldEnum = (typeof FieldAnswerScalarFieldEnum)[keyof typeof FieldAnswerScalarFieldEnum]


  export const FieldOptionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    fieldId: 'fieldId',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type FieldOptionScalarFieldEnum = (typeof FieldOptionScalarFieldEnum)[keyof typeof FieldOptionScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    encounterTypeId: 'encounterTypeId',
    patientId: 'patientId',
    locationId: 'locationId',
    formId: 'formId',
    providerId: 'providerId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    voided: 'voided',
    voidedBy: 'voidedBy',
    dateVoided: 'dateVoided',
    voidReason: 'voidReason',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const EncounterTypeScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type EncounterTypeScalarFieldEnum = (typeof EncounterTypeScalarFieldEnum)[keyof typeof EncounterTypeScalarFieldEnum]


  export const ObsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    encounterId: 'encounterId',
    obsDatetime: 'obsDatetime',
    valueDatetime: 'valueDatetime',
    valueNumeric: 'valueNumeric',
    valueText: 'valueText',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ObsScalarFieldEnum = (typeof ObsScalarFieldEnum)[keyof typeof ObsScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    encounterId: 'encounterId',
    orderDatetime: 'orderDatetime',
    instructions: 'instructions',
    dosage: 'dosage',
    route: 'route',
    frequency: 'frequency',
    asNeeded: 'asNeeded',
    prn: 'prn',
    quantity: 'quantity',
    units: 'units',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate',
    orderFrequencyId: 'orderFrequencyId',
    orderRouteId: 'orderRouteId',
    orderTypeId: 'orderTypeId',
    orderUnitId: 'orderUnitId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderFrequencyScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type OrderFrequencyScalarFieldEnum = (typeof OrderFrequencyScalarFieldEnum)[keyof typeof OrderFrequencyScalarFieldEnum]


  export const OrderRouteScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type OrderRouteScalarFieldEnum = (typeof OrderRouteScalarFieldEnum)[keyof typeof OrderRouteScalarFieldEnum]


  export const OrderTypeScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type OrderTypeScalarFieldEnum = (typeof OrderTypeScalarFieldEnum)[keyof typeof OrderTypeScalarFieldEnum]


  export const OrderUnitScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type OrderUnitScalarFieldEnum = (typeof OrderUnitScalarFieldEnum)[keyof typeof OrderUnitScalarFieldEnum]


  export const ConceptScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    dataType: 'dataType',
    class: 'class',
    isRetired: 'isRetired',
    retiredBy: 'retiredBy',
    dateRetired: 'dateRetired',
    retiredReason: 'retiredReason',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate',
    conceptClassId: 'conceptClassId',
    conceptDatatypeId: 'conceptDatatypeId',
    conceptMapId: 'conceptMapId',
    conceptSetId: 'conceptSetId',
    conceptSourceId: 'conceptSourceId'
  };

  export type ConceptScalarFieldEnum = (typeof ConceptScalarFieldEnum)[keyof typeof ConceptScalarFieldEnum]


  export const ConceptAnswerScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    answerConceptId: 'answerConceptId',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptAnswerScalarFieldEnum = (typeof ConceptAnswerScalarFieldEnum)[keyof typeof ConceptAnswerScalarFieldEnum]


  export const ConceptClassScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptClassScalarFieldEnum = (typeof ConceptClassScalarFieldEnum)[keyof typeof ConceptClassScalarFieldEnum]


  export const ConceptDatatypeScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptDatatypeScalarFieldEnum = (typeof ConceptDatatypeScalarFieldEnum)[keyof typeof ConceptDatatypeScalarFieldEnum]


  export const ConceptMapScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptMapScalarFieldEnum = (typeof ConceptMapScalarFieldEnum)[keyof typeof ConceptMapScalarFieldEnum]


  export const ConceptNameScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    name: 'name',
    locale: 'locale',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptNameScalarFieldEnum = (typeof ConceptNameScalarFieldEnum)[keyof typeof ConceptNameScalarFieldEnum]


  export const ConceptNumericScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    hiAbsolute: 'hiAbsolute',
    hiCritical: 'hiCritical',
    hiNormal: 'hiNormal',
    lowAbsolute: 'lowAbsolute',
    lowCritical: 'lowCritical',
    lowNormal: 'lowNormal',
    units: 'units',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptNumericScalarFieldEnum = (typeof ConceptNumericScalarFieldEnum)[keyof typeof ConceptNumericScalarFieldEnum]


  export const ConceptProposalScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptProposalScalarFieldEnum = (typeof ConceptProposalScalarFieldEnum)[keyof typeof ConceptProposalScalarFieldEnum]


  export const ConceptSetScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptSetScalarFieldEnum = (typeof ConceptSetScalarFieldEnum)[keyof typeof ConceptSetScalarFieldEnum]


  export const ConceptSourceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptSourceScalarFieldEnum = (typeof ConceptSourceScalarFieldEnum)[keyof typeof ConceptSourceScalarFieldEnum]


  export const ConceptWordScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    conceptId: 'conceptId',
    word: 'word',
    locale: 'locale',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ConceptWordScalarFieldEnum = (typeof ConceptWordScalarFieldEnum)[keyof typeof ConceptWordScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    creator: 'creator',
    dateCreated: 'dateCreated',
    lastChangedBy: 'lastChangedBy',
    lastChangedDate: 'lastChangedDate'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    context: 'context',
    authorId: 'authorId',
    spaceTimeCoordinatesId: 'spaceTimeCoordinatesId'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const BlogPostTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    descriptor: 'descriptor'
  };

  export type BlogPostTagScalarFieldEnum = (typeof BlogPostTagScalarFieldEnum)[keyof typeof BlogPostTagScalarFieldEnum]


  export const BlogPostTagArrowScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    tagId: 'tagId'
  };

  export type BlogPostTagArrowScalarFieldEnum = (typeof BlogPostTagArrowScalarFieldEnum)[keyof typeof BlogPostTagArrowScalarFieldEnum]


  export const BlogPostAuthorScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BlogPostAuthorScalarFieldEnum = (typeof BlogPostAuthorScalarFieldEnum)[keyof typeof BlogPostAuthorScalarFieldEnum]


  export const SpaceTimeCoordinatesScalarFieldEnum: {
    id: 'id',
    latitude: 'latitude',
    longitude: 'longitude',
    startTime: 'startTime',
    pauseTime: 'pauseTime',
    stopTime: 'stopTime',
    timezone: 'timezone',
    blogPostId: 'blogPostId'
  };

  export type SpaceTimeCoordinatesScalarFieldEnum = (typeof SpaceTimeCoordinatesScalarFieldEnum)[keyof typeof SpaceTimeCoordinatesScalarFieldEnum]


  export const BudgetEntryScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    cost: 'cost',
    discount: 'discount',
    promotion: 'promotion',
    subtotal: 'subtotal',
    percentChange: 'percentChange',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    budgetId: 'budgetId'
  };

  export type BudgetEntryScalarFieldEnum = (typeof BudgetEntryScalarFieldEnum)[keyof typeof BudgetEntryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    description: 'description',
    category: 'category',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fiscalYear: 'fiscalYear',
    reportId: 'reportId'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    totalCost: 'totalCost',
    totalDiscount: 'totalDiscount',
    totalPromotion: 'totalPromotion',
    totalSubtotal: 'totalSubtotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const BudUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudUserScalarFieldEnum = (typeof BudUserScalarFieldEnum)[keyof typeof BudUserScalarFieldEnum]


  export const BudgetBudUserScalarFieldEnum: {
    userId: 'userId',
    budgetId: 'budgetId',
    role: 'role',
    ability: 'ability',
    category: 'category'
  };

  export type BudgetBudUserScalarFieldEnum = (typeof BudgetBudUserScalarFieldEnum)[keyof typeof BudgetBudUserScalarFieldEnum]


  export const BudEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    categoryList: 'categoryList',
    metadata: 'metadata',
    budUserId: 'budUserId',
    createdAt: 'createdAt'
  };

  export type BudEventScalarFieldEnum = (typeof BudEventScalarFieldEnum)[keyof typeof BudEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    uuid?: StringFilter<"Appointment"> | string
    appointmentTypeId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    locationId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startDatetime?: DateTimeFilter<"Appointment"> | Date | string
    endDatetime?: DateTimeFilter<"Appointment"> | Date | string
    voided?: BoolFilter<"Appointment"> | boolean
    voidedBy?: StringFilter<"Appointment"> | string
    dateVoided?: DateTimeFilter<"Appointment"> | Date | string
    voidReason?: StringFilter<"Appointment"> | string
    creator?: StringFilter<"Appointment"> | string
    dateCreated?: DateTimeFilter<"Appointment"> | Date | string
    lastChangedBy?: StringFilter<"Appointment"> | string
    lastChangedDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentType?: XOR<AppointmentTypeRelationFilter, AppointmentTypeWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    appointmentType?: AppointmentTypeOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    patientId_locationId_providerId?: AppointmentPatientIdLocationIdProviderIdCompoundUniqueInput
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    appointmentTypeId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    locationId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startDatetime?: DateTimeFilter<"Appointment"> | Date | string
    endDatetime?: DateTimeFilter<"Appointment"> | Date | string
    voided?: BoolFilter<"Appointment"> | boolean
    voidedBy?: StringFilter<"Appointment"> | string
    dateVoided?: DateTimeFilter<"Appointment"> | Date | string
    voidReason?: StringFilter<"Appointment"> | string
    creator?: StringFilter<"Appointment"> | string
    dateCreated?: DateTimeFilter<"Appointment"> | Date | string
    lastChangedBy?: StringFilter<"Appointment"> | string
    lastChangedDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentType?: XOR<AppointmentTypeRelationFilter, AppointmentTypeWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
  }, "id" | "uuid" | "patientId_locationId_providerId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    uuid?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentTypeId?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    locationId?: StringWithAggregatesFilter<"Appointment"> | string
    providerId?: StringWithAggregatesFilter<"Appointment"> | string
    startDatetime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    voided?: BoolWithAggregatesFilter<"Appointment"> | boolean
    voidedBy?: StringWithAggregatesFilter<"Appointment"> | string
    dateVoided?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    voidReason?: StringWithAggregatesFilter<"Appointment"> | string
    creator?: StringWithAggregatesFilter<"Appointment"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Appointment"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type AppointmentTypeWhereInput = {
    AND?: AppointmentTypeWhereInput | AppointmentTypeWhereInput[]
    OR?: AppointmentTypeWhereInput[]
    NOT?: AppointmentTypeWhereInput | AppointmentTypeWhereInput[]
    id?: StringFilter<"AppointmentType"> | string
    uuid?: StringFilter<"AppointmentType"> | string
    name?: StringFilter<"AppointmentType"> | string
    description?: StringFilter<"AppointmentType"> | string
    duration?: IntFilter<"AppointmentType"> | number
    creator?: StringFilter<"AppointmentType"> | string
    dateCreated?: DateTimeFilter<"AppointmentType"> | Date | string
    lastChangedBy?: StringFilter<"AppointmentType"> | string
    lastChangedDate?: DateTimeFilter<"AppointmentType"> | Date | string
    appointmentList?: AppointmentListRelationFilter
  }

  export type AppointmentTypeOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    appointmentList?: AppointmentOrderByRelationAggregateInput
  }

  export type AppointmentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: AppointmentTypeWhereInput | AppointmentTypeWhereInput[]
    OR?: AppointmentTypeWhereInput[]
    NOT?: AppointmentTypeWhereInput | AppointmentTypeWhereInput[]
    name?: StringFilter<"AppointmentType"> | string
    description?: StringFilter<"AppointmentType"> | string
    duration?: IntFilter<"AppointmentType"> | number
    creator?: StringFilter<"AppointmentType"> | string
    dateCreated?: DateTimeFilter<"AppointmentType"> | Date | string
    lastChangedBy?: StringFilter<"AppointmentType"> | string
    lastChangedDate?: DateTimeFilter<"AppointmentType"> | Date | string
    appointmentList?: AppointmentListRelationFilter
  }, "id" | "uuid">

  export type AppointmentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: AppointmentTypeCountOrderByAggregateInput
    _avg?: AppointmentTypeAvgOrderByAggregateInput
    _max?: AppointmentTypeMaxOrderByAggregateInput
    _min?: AppointmentTypeMinOrderByAggregateInput
    _sum?: AppointmentTypeSumOrderByAggregateInput
  }

  export type AppointmentTypeScalarWhereWithAggregatesInput = {
    AND?: AppointmentTypeScalarWhereWithAggregatesInput | AppointmentTypeScalarWhereWithAggregatesInput[]
    OR?: AppointmentTypeScalarWhereWithAggregatesInput[]
    NOT?: AppointmentTypeScalarWhereWithAggregatesInput | AppointmentTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppointmentType"> | string
    uuid?: StringWithAggregatesFilter<"AppointmentType"> | string
    name?: StringWithAggregatesFilter<"AppointmentType"> | string
    description?: StringWithAggregatesFilter<"AppointmentType"> | string
    duration?: IntWithAggregatesFilter<"AppointmentType"> | number
    creator?: StringWithAggregatesFilter<"AppointmentType"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"AppointmentType"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"AppointmentType"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"AppointmentType"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    uuid?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    description?: StringFilter<"Location"> | string
    address1?: StringFilter<"Location"> | string
    address2?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    stateProvince?: StringFilter<"Location"> | string
    country?: StringFilter<"Location"> | string
    postalCode?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    creator?: StringFilter<"Location"> | string
    dateCreated?: DateTimeFilter<"Location"> | Date | string
    lastChangedBy?: StringFilter<"Location"> | string
    lastChangedDate?: DateTimeFilter<"Location"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    appointmentList?: AppointmentOrderByRelationAggregateInput
    encounterList?: EncounterOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    description?: StringFilter<"Location"> | string
    address1?: StringFilter<"Location"> | string
    address2?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    stateProvince?: StringFilter<"Location"> | string
    country?: StringFilter<"Location"> | string
    postalCode?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    creator?: StringFilter<"Location"> | string
    dateCreated?: DateTimeFilter<"Location"> | Date | string
    lastChangedBy?: StringFilter<"Location"> | string
    lastChangedDate?: DateTimeFilter<"Location"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }, "id" | "uuid">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    uuid?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    description?: StringWithAggregatesFilter<"Location"> | string
    address1?: StringWithAggregatesFilter<"Location"> | string
    address2?: StringWithAggregatesFilter<"Location"> | string
    city?: StringWithAggregatesFilter<"Location"> | string
    stateProvince?: StringWithAggregatesFilter<"Location"> | string
    country?: StringWithAggregatesFilter<"Location"> | string
    postalCode?: StringWithAggregatesFilter<"Location"> | string
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    longitude?: FloatWithAggregatesFilter<"Location"> | number
    creator?: StringWithAggregatesFilter<"Location"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Location"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    uuid?: StringFilter<"Patient"> | string
    givenName?: StringFilter<"Patient"> | string
    middleName?: StringFilter<"Patient"> | string
    familyName?: StringFilter<"Patient"> | string
    gender?: StringFilter<"Patient"> | string
    birthdate?: DateTimeFilter<"Patient"> | Date | string
    dead?: BoolFilter<"Patient"> | boolean
    deathDate?: DateTimeFilter<"Patient"> | Date | string
    causeOfDeath?: StringFilter<"Patient"> | string
    creator?: StringFilter<"Patient"> | string
    dateCreated?: DateTimeFilter<"Patient"> | Date | string
    lastChangedBy?: StringFilter<"Patient"> | string
    lastChangedDate?: DateTimeFilter<"Patient"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    givenName?: SortOrder
    middleName?: SortOrder
    familyName?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    dead?: SortOrder
    deathDate?: SortOrder
    causeOfDeath?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    appointmentList?: AppointmentOrderByRelationAggregateInput
    encounterList?: EncounterOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    givenName?: StringFilter<"Patient"> | string
    middleName?: StringFilter<"Patient"> | string
    familyName?: StringFilter<"Patient"> | string
    gender?: StringFilter<"Patient"> | string
    birthdate?: DateTimeFilter<"Patient"> | Date | string
    dead?: BoolFilter<"Patient"> | boolean
    deathDate?: DateTimeFilter<"Patient"> | Date | string
    causeOfDeath?: StringFilter<"Patient"> | string
    creator?: StringFilter<"Patient"> | string
    dateCreated?: DateTimeFilter<"Patient"> | Date | string
    lastChangedBy?: StringFilter<"Patient"> | string
    lastChangedDate?: DateTimeFilter<"Patient"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }, "id" | "uuid">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    givenName?: SortOrder
    middleName?: SortOrder
    familyName?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    dead?: SortOrder
    deathDate?: SortOrder
    causeOfDeath?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    uuid?: StringWithAggregatesFilter<"Patient"> | string
    givenName?: StringWithAggregatesFilter<"Patient"> | string
    middleName?: StringWithAggregatesFilter<"Patient"> | string
    familyName?: StringWithAggregatesFilter<"Patient"> | string
    gender?: StringWithAggregatesFilter<"Patient"> | string
    birthdate?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    dead?: BoolWithAggregatesFilter<"Patient"> | boolean
    deathDate?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    causeOfDeath?: StringWithAggregatesFilter<"Patient"> | string
    creator?: StringWithAggregatesFilter<"Patient"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Patient"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    uuid?: StringFilter<"Provider"> | string
    name?: StringFilter<"Provider"> | string
    identifier?: StringFilter<"Provider"> | string
    description?: StringFilter<"Provider"> | string
    voided?: BoolFilter<"Provider"> | boolean
    voidedBy?: StringFilter<"Provider"> | string
    dateVoided?: DateTimeFilter<"Provider"> | Date | string
    voidReason?: StringFilter<"Provider"> | string
    creator?: StringFilter<"Provider"> | string
    dateCreated?: DateTimeFilter<"Provider"> | Date | string
    lastChangedBy?: StringFilter<"Provider"> | string
    lastChangedDate?: DateTimeFilter<"Provider"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    appointmentList?: AppointmentOrderByRelationAggregateInput
    encounterList?: EncounterOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    name?: StringFilter<"Provider"> | string
    identifier?: StringFilter<"Provider"> | string
    description?: StringFilter<"Provider"> | string
    voided?: BoolFilter<"Provider"> | boolean
    voidedBy?: StringFilter<"Provider"> | string
    dateVoided?: DateTimeFilter<"Provider"> | Date | string
    voidReason?: StringFilter<"Provider"> | string
    creator?: StringFilter<"Provider"> | string
    dateCreated?: DateTimeFilter<"Provider"> | Date | string
    lastChangedBy?: StringFilter<"Provider"> | string
    lastChangedDate?: DateTimeFilter<"Provider"> | Date | string
    appointmentList?: AppointmentListRelationFilter
    encounterList?: EncounterListRelationFilter
  }, "id" | "uuid">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    uuid?: StringWithAggregatesFilter<"Provider"> | string
    name?: StringWithAggregatesFilter<"Provider"> | string
    identifier?: StringWithAggregatesFilter<"Provider"> | string
    description?: StringWithAggregatesFilter<"Provider"> | string
    voided?: BoolWithAggregatesFilter<"Provider"> | boolean
    voidedBy?: StringWithAggregatesFilter<"Provider"> | string
    dateVoided?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
    voidReason?: StringWithAggregatesFilter<"Provider"> | string
    creator?: StringWithAggregatesFilter<"Provider"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Provider"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: StringFilter<"Form"> | string
    uuid?: StringFilter<"Form"> | string
    name?: StringFilter<"Form"> | string
    description?: StringFilter<"Form"> | string
    version?: StringFilter<"Form"> | string
    retired?: BoolFilter<"Form"> | boolean
    retiredBy?: StringFilter<"Form"> | string
    dateRetired?: DateTimeFilter<"Form"> | Date | string
    retiredReason?: StringFilter<"Form"> | string
    creator?: StringFilter<"Form"> | string
    dateCreated?: DateTimeFilter<"Form"> | Date | string
    lastChangedBy?: StringFilter<"Form"> | string
    lastChangedDate?: DateTimeFilter<"Form"> | Date | string
    fieldId?: StringNullableFilter<"Form"> | string | null
    formEncounterList?: FormEncounterListRelationFilter
    formResourceList?: FormResourceListRelationFilter
    formSubmissionList?: FormSubmissionListRelationFilter
    dield?: XOR<FieldNullableRelationFilter, FieldWhereInput> | null
    encounterList?: EncounterListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    retired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    fieldId?: SortOrderInput | SortOrder
    formEncounterList?: FormEncounterOrderByRelationAggregateInput
    formResourceList?: FormResourceOrderByRelationAggregateInput
    formSubmissionList?: FormSubmissionOrderByRelationAggregateInput
    dield?: FieldOrderByWithRelationInput
    encounterList?: EncounterOrderByRelationAggregateInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    name?: StringFilter<"Form"> | string
    description?: StringFilter<"Form"> | string
    version?: StringFilter<"Form"> | string
    retired?: BoolFilter<"Form"> | boolean
    retiredBy?: StringFilter<"Form"> | string
    dateRetired?: DateTimeFilter<"Form"> | Date | string
    retiredReason?: StringFilter<"Form"> | string
    creator?: StringFilter<"Form"> | string
    dateCreated?: DateTimeFilter<"Form"> | Date | string
    lastChangedBy?: StringFilter<"Form"> | string
    lastChangedDate?: DateTimeFilter<"Form"> | Date | string
    fieldId?: StringNullableFilter<"Form"> | string | null
    formEncounterList?: FormEncounterListRelationFilter
    formResourceList?: FormResourceListRelationFilter
    formSubmissionList?: FormSubmissionListRelationFilter
    dield?: XOR<FieldNullableRelationFilter, FieldWhereInput> | null
    encounterList?: EncounterListRelationFilter
  }, "id" | "uuid">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    retired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    fieldId?: SortOrderInput | SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form"> | string
    uuid?: StringWithAggregatesFilter<"Form"> | string
    name?: StringWithAggregatesFilter<"Form"> | string
    description?: StringWithAggregatesFilter<"Form"> | string
    version?: StringWithAggregatesFilter<"Form"> | string
    retired?: BoolWithAggregatesFilter<"Form"> | boolean
    retiredBy?: StringWithAggregatesFilter<"Form"> | string
    dateRetired?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    retiredReason?: StringWithAggregatesFilter<"Form"> | string
    creator?: StringWithAggregatesFilter<"Form"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Form"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    fieldId?: StringNullableWithAggregatesFilter<"Form"> | string | null
  }

  export type FormEncounterWhereInput = {
    AND?: FormEncounterWhereInput | FormEncounterWhereInput[]
    OR?: FormEncounterWhereInput[]
    NOT?: FormEncounterWhereInput | FormEncounterWhereInput[]
    id?: StringFilter<"FormEncounter"> | string
    uuid?: StringFilter<"FormEncounter"> | string
    formId?: StringFilter<"FormEncounter"> | string
    encounterId?: StringFilter<"FormEncounter"> | string
    creator?: StringFilter<"FormEncounter"> | string
    dateCreated?: DateTimeFilter<"FormEncounter"> | Date | string
    lastChangedBy?: StringFilter<"FormEncounter"> | string
    lastChangedDate?: DateTimeFilter<"FormEncounter"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type FormEncounterOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    form?: FormOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
  }

  export type FormEncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FormEncounterWhereInput | FormEncounterWhereInput[]
    OR?: FormEncounterWhereInput[]
    NOT?: FormEncounterWhereInput | FormEncounterWhereInput[]
    formId?: StringFilter<"FormEncounter"> | string
    encounterId?: StringFilter<"FormEncounter"> | string
    creator?: StringFilter<"FormEncounter"> | string
    dateCreated?: DateTimeFilter<"FormEncounter"> | Date | string
    lastChangedBy?: StringFilter<"FormEncounter"> | string
    lastChangedDate?: DateTimeFilter<"FormEncounter"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id" | "uuid">

  export type FormEncounterOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FormEncounterCountOrderByAggregateInput
    _max?: FormEncounterMaxOrderByAggregateInput
    _min?: FormEncounterMinOrderByAggregateInput
  }

  export type FormEncounterScalarWhereWithAggregatesInput = {
    AND?: FormEncounterScalarWhereWithAggregatesInput | FormEncounterScalarWhereWithAggregatesInput[]
    OR?: FormEncounterScalarWhereWithAggregatesInput[]
    NOT?: FormEncounterScalarWhereWithAggregatesInput | FormEncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormEncounter"> | string
    uuid?: StringWithAggregatesFilter<"FormEncounter"> | string
    formId?: StringWithAggregatesFilter<"FormEncounter"> | string
    encounterId?: StringWithAggregatesFilter<"FormEncounter"> | string
    creator?: StringWithAggregatesFilter<"FormEncounter"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"FormEncounter"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"FormEncounter"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"FormEncounter"> | Date | string
  }

  export type FormResourceWhereInput = {
    AND?: FormResourceWhereInput | FormResourceWhereInput[]
    OR?: FormResourceWhereInput[]
    NOT?: FormResourceWhereInput | FormResourceWhereInput[]
    id?: StringFilter<"FormResource"> | string
    uuid?: StringFilter<"FormResource"> | string
    formId?: StringFilter<"FormResource"> | string
    resourceId?: StringFilter<"FormResource"> | string
    creator?: StringFilter<"FormResource"> | string
    dateCreated?: DateTimeFilter<"FormResource"> | Date | string
    lastChangedBy?: StringFilter<"FormResource"> | string
    lastChangedDate?: DateTimeFilter<"FormResource"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }

  export type FormResourceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    resourceId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    form?: FormOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type FormResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FormResourceWhereInput | FormResourceWhereInput[]
    OR?: FormResourceWhereInput[]
    NOT?: FormResourceWhereInput | FormResourceWhereInput[]
    formId?: StringFilter<"FormResource"> | string
    resourceId?: StringFilter<"FormResource"> | string
    creator?: StringFilter<"FormResource"> | string
    dateCreated?: DateTimeFilter<"FormResource"> | Date | string
    lastChangedBy?: StringFilter<"FormResource"> | string
    lastChangedDate?: DateTimeFilter<"FormResource"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }, "id" | "uuid">

  export type FormResourceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    resourceId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FormResourceCountOrderByAggregateInput
    _max?: FormResourceMaxOrderByAggregateInput
    _min?: FormResourceMinOrderByAggregateInput
  }

  export type FormResourceScalarWhereWithAggregatesInput = {
    AND?: FormResourceScalarWhereWithAggregatesInput | FormResourceScalarWhereWithAggregatesInput[]
    OR?: FormResourceScalarWhereWithAggregatesInput[]
    NOT?: FormResourceScalarWhereWithAggregatesInput | FormResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormResource"> | string
    uuid?: StringWithAggregatesFilter<"FormResource"> | string
    formId?: StringWithAggregatesFilter<"FormResource"> | string
    resourceId?: StringWithAggregatesFilter<"FormResource"> | string
    creator?: StringWithAggregatesFilter<"FormResource"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"FormResource"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"FormResource"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"FormResource"> | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    uuid?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    encounterId?: StringFilter<"FormSubmission"> | string
    submissionDate?: DateTimeFilter<"FormSubmission"> | Date | string
    creator?: StringFilter<"FormSubmission"> | string
    dateCreated?: DateTimeFilter<"FormSubmission"> | Date | string
    lastChangedBy?: StringFilter<"FormSubmission"> | string
    lastChangedDate?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    fieldAnswerList?: FieldAnswerListRelationFilter
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    submissionDate?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    form?: FormOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    fieldAnswerList?: FieldAnswerOrderByRelationAggregateInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    formId?: StringFilter<"FormSubmission"> | string
    encounterId?: StringFilter<"FormSubmission"> | string
    submissionDate?: DateTimeFilter<"FormSubmission"> | Date | string
    creator?: StringFilter<"FormSubmission"> | string
    dateCreated?: DateTimeFilter<"FormSubmission"> | Date | string
    lastChangedBy?: StringFilter<"FormSubmission"> | string
    lastChangedDate?: DateTimeFilter<"FormSubmission"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    fieldAnswerList?: FieldAnswerListRelationFilter
  }, "id" | "uuid">

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    submissionDate?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormSubmission"> | string
    uuid?: StringWithAggregatesFilter<"FormSubmission"> | string
    formId?: StringWithAggregatesFilter<"FormSubmission"> | string
    encounterId?: StringWithAggregatesFilter<"FormSubmission"> | string
    submissionDate?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    creator?: StringWithAggregatesFilter<"FormSubmission"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"FormSubmission"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
  }

  export type FieldWhereInput = {
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    id?: StringFilter<"Field"> | string
    uuid?: StringFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    description?: StringFilter<"Field"> | string
    fieldType?: StringFilter<"Field"> | string
    conceptId?: StringFilter<"Field"> | string
    creator?: StringFilter<"Field"> | string
    dateCreated?: DateTimeFilter<"Field"> | Date | string
    lastChangedBy?: StringFilter<"Field"> | string
    lastChangedDate?: DateTimeFilter<"Field"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    formList?: FormListRelationFilter
    fieldAnswerList?: FieldAnswerListRelationFilter
    fieldOptionList?: FieldOptionListRelationFilter
  }

  export type FieldOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fieldType?: SortOrder
    conceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
    formList?: FormOrderByRelationAggregateInput
    fieldAnswerList?: FieldAnswerOrderByRelationAggregateInput
    fieldOptionList?: FieldOptionOrderByRelationAggregateInput
  }

  export type FieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    name?: StringFilter<"Field"> | string
    description?: StringFilter<"Field"> | string
    fieldType?: StringFilter<"Field"> | string
    conceptId?: StringFilter<"Field"> | string
    creator?: StringFilter<"Field"> | string
    dateCreated?: DateTimeFilter<"Field"> | Date | string
    lastChangedBy?: StringFilter<"Field"> | string
    lastChangedDate?: DateTimeFilter<"Field"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    formList?: FormListRelationFilter
    fieldAnswerList?: FieldAnswerListRelationFilter
    fieldOptionList?: FieldOptionListRelationFilter
  }, "id" | "uuid">

  export type FieldOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fieldType?: SortOrder
    conceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FieldCountOrderByAggregateInput
    _max?: FieldMaxOrderByAggregateInput
    _min?: FieldMinOrderByAggregateInput
  }

  export type FieldScalarWhereWithAggregatesInput = {
    AND?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    OR?: FieldScalarWhereWithAggregatesInput[]
    NOT?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Field"> | string
    uuid?: StringWithAggregatesFilter<"Field"> | string
    name?: StringWithAggregatesFilter<"Field"> | string
    description?: StringWithAggregatesFilter<"Field"> | string
    fieldType?: StringWithAggregatesFilter<"Field"> | string
    conceptId?: StringWithAggregatesFilter<"Field"> | string
    creator?: StringWithAggregatesFilter<"Field"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Field"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Field"> | Date | string
  }

  export type FieldAnswerWhereInput = {
    AND?: FieldAnswerWhereInput | FieldAnswerWhereInput[]
    OR?: FieldAnswerWhereInput[]
    NOT?: FieldAnswerWhereInput | FieldAnswerWhereInput[]
    id?: StringFilter<"FieldAnswer"> | string
    uuid?: StringFilter<"FieldAnswer"> | string
    formSubmissionId?: StringFilter<"FieldAnswer"> | string
    fieldId?: StringFilter<"FieldAnswer"> | string
    value?: StringFilter<"FieldAnswer"> | string
    creator?: StringFilter<"FieldAnswer"> | string
    dateCreated?: DateTimeFilter<"FieldAnswer"> | Date | string
    lastChangedBy?: StringFilter<"FieldAnswer"> | string
    lastChangedDate?: DateTimeFilter<"FieldAnswer"> | Date | string
    formSubmission?: XOR<FormSubmissionRelationFilter, FormSubmissionWhereInput>
    field?: XOR<FieldRelationFilter, FieldWhereInput>
  }

  export type FieldAnswerOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formSubmissionId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    formSubmission?: FormSubmissionOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
  }

  export type FieldAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FieldAnswerWhereInput | FieldAnswerWhereInput[]
    OR?: FieldAnswerWhereInput[]
    NOT?: FieldAnswerWhereInput | FieldAnswerWhereInput[]
    formSubmissionId?: StringFilter<"FieldAnswer"> | string
    fieldId?: StringFilter<"FieldAnswer"> | string
    value?: StringFilter<"FieldAnswer"> | string
    creator?: StringFilter<"FieldAnswer"> | string
    dateCreated?: DateTimeFilter<"FieldAnswer"> | Date | string
    lastChangedBy?: StringFilter<"FieldAnswer"> | string
    lastChangedDate?: DateTimeFilter<"FieldAnswer"> | Date | string
    formSubmission?: XOR<FormSubmissionRelationFilter, FormSubmissionWhereInput>
    field?: XOR<FieldRelationFilter, FieldWhereInput>
  }, "id" | "uuid">

  export type FieldAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    formSubmissionId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FieldAnswerCountOrderByAggregateInput
    _max?: FieldAnswerMaxOrderByAggregateInput
    _min?: FieldAnswerMinOrderByAggregateInput
  }

  export type FieldAnswerScalarWhereWithAggregatesInput = {
    AND?: FieldAnswerScalarWhereWithAggregatesInput | FieldAnswerScalarWhereWithAggregatesInput[]
    OR?: FieldAnswerScalarWhereWithAggregatesInput[]
    NOT?: FieldAnswerScalarWhereWithAggregatesInput | FieldAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldAnswer"> | string
    uuid?: StringWithAggregatesFilter<"FieldAnswer"> | string
    formSubmissionId?: StringWithAggregatesFilter<"FieldAnswer"> | string
    fieldId?: StringWithAggregatesFilter<"FieldAnswer"> | string
    value?: StringWithAggregatesFilter<"FieldAnswer"> | string
    creator?: StringWithAggregatesFilter<"FieldAnswer"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"FieldAnswer"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"FieldAnswer"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"FieldAnswer"> | Date | string
  }

  export type FieldOptionWhereInput = {
    AND?: FieldOptionWhereInput | FieldOptionWhereInput[]
    OR?: FieldOptionWhereInput[]
    NOT?: FieldOptionWhereInput | FieldOptionWhereInput[]
    id?: StringFilter<"FieldOption"> | string
    uuid?: StringFilter<"FieldOption"> | string
    fieldId?: StringFilter<"FieldOption"> | string
    name?: StringFilter<"FieldOption"> | string
    description?: StringFilter<"FieldOption"> | string
    creator?: StringFilter<"FieldOption"> | string
    dateCreated?: DateTimeFilter<"FieldOption"> | Date | string
    lastChangedBy?: StringFilter<"FieldOption"> | string
    lastChangedDate?: DateTimeFilter<"FieldOption"> | Date | string
    field?: XOR<FieldRelationFilter, FieldWhereInput>
  }

  export type FieldOptionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    fieldId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    field?: FieldOrderByWithRelationInput
  }

  export type FieldOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: FieldOptionWhereInput | FieldOptionWhereInput[]
    OR?: FieldOptionWhereInput[]
    NOT?: FieldOptionWhereInput | FieldOptionWhereInput[]
    fieldId?: StringFilter<"FieldOption"> | string
    name?: StringFilter<"FieldOption"> | string
    description?: StringFilter<"FieldOption"> | string
    creator?: StringFilter<"FieldOption"> | string
    dateCreated?: DateTimeFilter<"FieldOption"> | Date | string
    lastChangedBy?: StringFilter<"FieldOption"> | string
    lastChangedDate?: DateTimeFilter<"FieldOption"> | Date | string
    field?: XOR<FieldRelationFilter, FieldWhereInput>
  }, "id" | "uuid">

  export type FieldOptionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    fieldId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: FieldOptionCountOrderByAggregateInput
    _max?: FieldOptionMaxOrderByAggregateInput
    _min?: FieldOptionMinOrderByAggregateInput
  }

  export type FieldOptionScalarWhereWithAggregatesInput = {
    AND?: FieldOptionScalarWhereWithAggregatesInput | FieldOptionScalarWhereWithAggregatesInput[]
    OR?: FieldOptionScalarWhereWithAggregatesInput[]
    NOT?: FieldOptionScalarWhereWithAggregatesInput | FieldOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldOption"> | string
    uuid?: StringWithAggregatesFilter<"FieldOption"> | string
    fieldId?: StringWithAggregatesFilter<"FieldOption"> | string
    name?: StringWithAggregatesFilter<"FieldOption"> | string
    description?: StringWithAggregatesFilter<"FieldOption"> | string
    creator?: StringWithAggregatesFilter<"FieldOption"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"FieldOption"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"FieldOption"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"FieldOption"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    uuid?: StringFilter<"Encounter"> | string
    encounterTypeId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    locationId?: StringFilter<"Encounter"> | string
    formId?: StringFilter<"Encounter"> | string
    providerId?: StringFilter<"Encounter"> | string
    startDatetime?: DateTimeFilter<"Encounter"> | Date | string
    endDatetime?: DateTimeFilter<"Encounter"> | Date | string
    voided?: BoolFilter<"Encounter"> | boolean
    voidedBy?: StringFilter<"Encounter"> | string
    dateVoided?: DateTimeFilter<"Encounter"> | Date | string
    voidReason?: StringFilter<"Encounter"> | string
    creator?: StringFilter<"Encounter"> | string
    dateCreated?: DateTimeFilter<"Encounter"> | Date | string
    lastChangedBy?: StringFilter<"Encounter"> | string
    lastChangedDate?: DateTimeFilter<"Encounter"> | Date | string
    encounterType?: XOR<EncounterTypeRelationFilter, EncounterTypeWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    form?: XOR<FormRelationFilter, FormWhereInput>
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    formEncounterList?: FormEncounterListRelationFilter
    formSubmissionList?: FormSubmissionListRelationFilter
    obsList?: ObsListRelationFilter
    orderList?: OrderListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    encounterTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    formId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    encounterType?: EncounterTypeOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    form?: FormOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
    formEncounterList?: FormEncounterOrderByRelationAggregateInput
    formSubmissionList?: FormSubmissionOrderByRelationAggregateInput
    obsList?: ObsOrderByRelationAggregateInput
    orderList?: OrderOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    encounterTypeId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    locationId?: StringFilter<"Encounter"> | string
    formId?: StringFilter<"Encounter"> | string
    providerId?: StringFilter<"Encounter"> | string
    startDatetime?: DateTimeFilter<"Encounter"> | Date | string
    endDatetime?: DateTimeFilter<"Encounter"> | Date | string
    voided?: BoolFilter<"Encounter"> | boolean
    voidedBy?: StringFilter<"Encounter"> | string
    dateVoided?: DateTimeFilter<"Encounter"> | Date | string
    voidReason?: StringFilter<"Encounter"> | string
    creator?: StringFilter<"Encounter"> | string
    dateCreated?: DateTimeFilter<"Encounter"> | Date | string
    lastChangedBy?: StringFilter<"Encounter"> | string
    lastChangedDate?: DateTimeFilter<"Encounter"> | Date | string
    encounterType?: XOR<EncounterTypeRelationFilter, EncounterTypeWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    form?: XOR<FormRelationFilter, FormWhereInput>
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    formEncounterList?: FormEncounterListRelationFilter
    formSubmissionList?: FormSubmissionListRelationFilter
    obsList?: ObsListRelationFilter
    orderList?: OrderListRelationFilter
  }, "id" | "uuid">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    encounterTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    formId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    uuid?: StringWithAggregatesFilter<"Encounter"> | string
    encounterTypeId?: StringWithAggregatesFilter<"Encounter"> | string
    patientId?: StringWithAggregatesFilter<"Encounter"> | string
    locationId?: StringWithAggregatesFilter<"Encounter"> | string
    formId?: StringWithAggregatesFilter<"Encounter"> | string
    providerId?: StringWithAggregatesFilter<"Encounter"> | string
    startDatetime?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    voided?: BoolWithAggregatesFilter<"Encounter"> | boolean
    voidedBy?: StringWithAggregatesFilter<"Encounter"> | string
    dateVoided?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    voidReason?: StringWithAggregatesFilter<"Encounter"> | string
    creator?: StringWithAggregatesFilter<"Encounter"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Encounter"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type EncounterTypeWhereInput = {
    AND?: EncounterTypeWhereInput | EncounterTypeWhereInput[]
    OR?: EncounterTypeWhereInput[]
    NOT?: EncounterTypeWhereInput | EncounterTypeWhereInput[]
    id?: StringFilter<"EncounterType"> | string
    uuid?: StringFilter<"EncounterType"> | string
    name?: StringFilter<"EncounterType"> | string
    description?: StringFilter<"EncounterType"> | string
    creator?: StringFilter<"EncounterType"> | string
    dateCreated?: DateTimeFilter<"EncounterType"> | Date | string
    lastChangedBy?: StringFilter<"EncounterType"> | string
    lastChangedDate?: DateTimeFilter<"EncounterType"> | Date | string
    encounterList?: EncounterListRelationFilter
  }

  export type EncounterTypeOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    encounterList?: EncounterOrderByRelationAggregateInput
  }

  export type EncounterTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: EncounterTypeWhereInput | EncounterTypeWhereInput[]
    OR?: EncounterTypeWhereInput[]
    NOT?: EncounterTypeWhereInput | EncounterTypeWhereInput[]
    name?: StringFilter<"EncounterType"> | string
    description?: StringFilter<"EncounterType"> | string
    creator?: StringFilter<"EncounterType"> | string
    dateCreated?: DateTimeFilter<"EncounterType"> | Date | string
    lastChangedBy?: StringFilter<"EncounterType"> | string
    lastChangedDate?: DateTimeFilter<"EncounterType"> | Date | string
    encounterList?: EncounterListRelationFilter
  }, "id" | "uuid">

  export type EncounterTypeOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: EncounterTypeCountOrderByAggregateInput
    _max?: EncounterTypeMaxOrderByAggregateInput
    _min?: EncounterTypeMinOrderByAggregateInput
  }

  export type EncounterTypeScalarWhereWithAggregatesInput = {
    AND?: EncounterTypeScalarWhereWithAggregatesInput | EncounterTypeScalarWhereWithAggregatesInput[]
    OR?: EncounterTypeScalarWhereWithAggregatesInput[]
    NOT?: EncounterTypeScalarWhereWithAggregatesInput | EncounterTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EncounterType"> | string
    uuid?: StringWithAggregatesFilter<"EncounterType"> | string
    name?: StringWithAggregatesFilter<"EncounterType"> | string
    description?: StringWithAggregatesFilter<"EncounterType"> | string
    creator?: StringWithAggregatesFilter<"EncounterType"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"EncounterType"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"EncounterType"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"EncounterType"> | Date | string
  }

  export type ObsWhereInput = {
    AND?: ObsWhereInput | ObsWhereInput[]
    OR?: ObsWhereInput[]
    NOT?: ObsWhereInput | ObsWhereInput[]
    id?: StringFilter<"Obs"> | string
    uuid?: StringFilter<"Obs"> | string
    conceptId?: StringFilter<"Obs"> | string
    encounterId?: StringFilter<"Obs"> | string
    obsDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueNumeric?: FloatFilter<"Obs"> | number
    valueText?: StringFilter<"Obs"> | string
    creator?: StringFilter<"Obs"> | string
    dateCreated?: DateTimeFilter<"Obs"> | Date | string
    lastChangedBy?: StringFilter<"Obs"> | string
    lastChangedDate?: DateTimeFilter<"Obs"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type ObsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    obsDatetime?: SortOrder
    valueDatetime?: SortOrder
    valueNumeric?: SortOrder
    valueText?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
  }

  export type ObsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ObsWhereInput | ObsWhereInput[]
    OR?: ObsWhereInput[]
    NOT?: ObsWhereInput | ObsWhereInput[]
    conceptId?: StringFilter<"Obs"> | string
    encounterId?: StringFilter<"Obs"> | string
    obsDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueNumeric?: FloatFilter<"Obs"> | number
    valueText?: StringFilter<"Obs"> | string
    creator?: StringFilter<"Obs"> | string
    dateCreated?: DateTimeFilter<"Obs"> | Date | string
    lastChangedBy?: StringFilter<"Obs"> | string
    lastChangedDate?: DateTimeFilter<"Obs"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id" | "uuid">

  export type ObsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    obsDatetime?: SortOrder
    valueDatetime?: SortOrder
    valueNumeric?: SortOrder
    valueText?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ObsCountOrderByAggregateInput
    _avg?: ObsAvgOrderByAggregateInput
    _max?: ObsMaxOrderByAggregateInput
    _min?: ObsMinOrderByAggregateInput
    _sum?: ObsSumOrderByAggregateInput
  }

  export type ObsScalarWhereWithAggregatesInput = {
    AND?: ObsScalarWhereWithAggregatesInput | ObsScalarWhereWithAggregatesInput[]
    OR?: ObsScalarWhereWithAggregatesInput[]
    NOT?: ObsScalarWhereWithAggregatesInput | ObsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Obs"> | string
    uuid?: StringWithAggregatesFilter<"Obs"> | string
    conceptId?: StringWithAggregatesFilter<"Obs"> | string
    encounterId?: StringWithAggregatesFilter<"Obs"> | string
    obsDatetime?: DateTimeWithAggregatesFilter<"Obs"> | Date | string
    valueDatetime?: DateTimeWithAggregatesFilter<"Obs"> | Date | string
    valueNumeric?: FloatWithAggregatesFilter<"Obs"> | number
    valueText?: StringWithAggregatesFilter<"Obs"> | string
    creator?: StringWithAggregatesFilter<"Obs"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Obs"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Obs"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Obs"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    uuid?: StringFilter<"Order"> | string
    conceptId?: StringFilter<"Order"> | string
    encounterId?: StringFilter<"Order"> | string
    orderDatetime?: DateTimeFilter<"Order"> | Date | string
    instructions?: StringFilter<"Order"> | string
    dosage?: StringFilter<"Order"> | string
    route?: StringFilter<"Order"> | string
    frequency?: StringFilter<"Order"> | string
    asNeeded?: BoolFilter<"Order"> | boolean
    prn?: BoolFilter<"Order"> | boolean
    quantity?: IntFilter<"Order"> | number
    units?: StringFilter<"Order"> | string
    creator?: StringFilter<"Order"> | string
    dateCreated?: DateTimeFilter<"Order"> | Date | string
    lastChangedBy?: StringFilter<"Order"> | string
    lastChangedDate?: DateTimeFilter<"Order"> | Date | string
    orderFrequencyId?: StringNullableFilter<"Order"> | string | null
    orderRouteId?: StringNullableFilter<"Order"> | string | null
    orderTypeId?: StringNullableFilter<"Order"> | string | null
    orderUnitId?: StringNullableFilter<"Order"> | string | null
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    OrderFrequency?: XOR<OrderFrequencyNullableRelationFilter, OrderFrequencyWhereInput> | null
    OrderRoute?: XOR<OrderRouteNullableRelationFilter, OrderRouteWhereInput> | null
    OrderType?: XOR<OrderTypeNullableRelationFilter, OrderTypeWhereInput> | null
    OrderUnit?: XOR<OrderUnitNullableRelationFilter, OrderUnitWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    orderDatetime?: SortOrder
    instructions?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    asNeeded?: SortOrder
    prn?: SortOrder
    quantity?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderFrequencyId?: SortOrderInput | SortOrder
    orderRouteId?: SortOrderInput | SortOrder
    orderTypeId?: SortOrderInput | SortOrder
    orderUnitId?: SortOrderInput | SortOrder
    concept?: ConceptOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    OrderFrequency?: OrderFrequencyOrderByWithRelationInput
    OrderRoute?: OrderRouteOrderByWithRelationInput
    OrderType?: OrderTypeOrderByWithRelationInput
    OrderUnit?: OrderUnitOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    conceptId?: StringFilter<"Order"> | string
    encounterId?: StringFilter<"Order"> | string
    orderDatetime?: DateTimeFilter<"Order"> | Date | string
    instructions?: StringFilter<"Order"> | string
    dosage?: StringFilter<"Order"> | string
    route?: StringFilter<"Order"> | string
    frequency?: StringFilter<"Order"> | string
    asNeeded?: BoolFilter<"Order"> | boolean
    prn?: BoolFilter<"Order"> | boolean
    quantity?: IntFilter<"Order"> | number
    units?: StringFilter<"Order"> | string
    creator?: StringFilter<"Order"> | string
    dateCreated?: DateTimeFilter<"Order"> | Date | string
    lastChangedBy?: StringFilter<"Order"> | string
    lastChangedDate?: DateTimeFilter<"Order"> | Date | string
    orderFrequencyId?: StringNullableFilter<"Order"> | string | null
    orderRouteId?: StringNullableFilter<"Order"> | string | null
    orderTypeId?: StringNullableFilter<"Order"> | string | null
    orderUnitId?: StringNullableFilter<"Order"> | string | null
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    OrderFrequency?: XOR<OrderFrequencyNullableRelationFilter, OrderFrequencyWhereInput> | null
    OrderRoute?: XOR<OrderRouteNullableRelationFilter, OrderRouteWhereInput> | null
    OrderType?: XOR<OrderTypeNullableRelationFilter, OrderTypeWhereInput> | null
    OrderUnit?: XOR<OrderUnitNullableRelationFilter, OrderUnitWhereInput> | null
  }, "id" | "uuid">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    orderDatetime?: SortOrder
    instructions?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    asNeeded?: SortOrder
    prn?: SortOrder
    quantity?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderFrequencyId?: SortOrderInput | SortOrder
    orderRouteId?: SortOrderInput | SortOrder
    orderTypeId?: SortOrderInput | SortOrder
    orderUnitId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    uuid?: StringWithAggregatesFilter<"Order"> | string
    conceptId?: StringWithAggregatesFilter<"Order"> | string
    encounterId?: StringWithAggregatesFilter<"Order"> | string
    orderDatetime?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    instructions?: StringWithAggregatesFilter<"Order"> | string
    dosage?: StringWithAggregatesFilter<"Order"> | string
    route?: StringWithAggregatesFilter<"Order"> | string
    frequency?: StringWithAggregatesFilter<"Order"> | string
    asNeeded?: BoolWithAggregatesFilter<"Order"> | boolean
    prn?: BoolWithAggregatesFilter<"Order"> | boolean
    quantity?: IntWithAggregatesFilter<"Order"> | number
    units?: StringWithAggregatesFilter<"Order"> | string
    creator?: StringWithAggregatesFilter<"Order"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Order"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    orderFrequencyId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    orderRouteId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    orderTypeId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    orderUnitId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderFrequencyWhereInput = {
    AND?: OrderFrequencyWhereInput | OrderFrequencyWhereInput[]
    OR?: OrderFrequencyWhereInput[]
    NOT?: OrderFrequencyWhereInput | OrderFrequencyWhereInput[]
    id?: StringFilter<"OrderFrequency"> | string
    uuid?: StringFilter<"OrderFrequency"> | string
    name?: StringFilter<"OrderFrequency"> | string
    description?: StringFilter<"OrderFrequency"> | string
    creator?: StringFilter<"OrderFrequency"> | string
    dateCreated?: DateTimeFilter<"OrderFrequency"> | Date | string
    lastChangedBy?: StringFilter<"OrderFrequency"> | string
    lastChangedDate?: DateTimeFilter<"OrderFrequency"> | Date | string
    orderList?: OrderListRelationFilter
  }

  export type OrderFrequencyOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderList?: OrderOrderByRelationAggregateInput
  }

  export type OrderFrequencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: OrderFrequencyWhereInput | OrderFrequencyWhereInput[]
    OR?: OrderFrequencyWhereInput[]
    NOT?: OrderFrequencyWhereInput | OrderFrequencyWhereInput[]
    name?: StringFilter<"OrderFrequency"> | string
    description?: StringFilter<"OrderFrequency"> | string
    creator?: StringFilter<"OrderFrequency"> | string
    dateCreated?: DateTimeFilter<"OrderFrequency"> | Date | string
    lastChangedBy?: StringFilter<"OrderFrequency"> | string
    lastChangedDate?: DateTimeFilter<"OrderFrequency"> | Date | string
    orderList?: OrderListRelationFilter
  }, "id" | "uuid">

  export type OrderFrequencyOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: OrderFrequencyCountOrderByAggregateInput
    _max?: OrderFrequencyMaxOrderByAggregateInput
    _min?: OrderFrequencyMinOrderByAggregateInput
  }

  export type OrderFrequencyScalarWhereWithAggregatesInput = {
    AND?: OrderFrequencyScalarWhereWithAggregatesInput | OrderFrequencyScalarWhereWithAggregatesInput[]
    OR?: OrderFrequencyScalarWhereWithAggregatesInput[]
    NOT?: OrderFrequencyScalarWhereWithAggregatesInput | OrderFrequencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderFrequency"> | string
    uuid?: StringWithAggregatesFilter<"OrderFrequency"> | string
    name?: StringWithAggregatesFilter<"OrderFrequency"> | string
    description?: StringWithAggregatesFilter<"OrderFrequency"> | string
    creator?: StringWithAggregatesFilter<"OrderFrequency"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"OrderFrequency"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"OrderFrequency"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"OrderFrequency"> | Date | string
  }

  export type OrderRouteWhereInput = {
    AND?: OrderRouteWhereInput | OrderRouteWhereInput[]
    OR?: OrderRouteWhereInput[]
    NOT?: OrderRouteWhereInput | OrderRouteWhereInput[]
    id?: StringFilter<"OrderRoute"> | string
    uuid?: StringFilter<"OrderRoute"> | string
    name?: StringFilter<"OrderRoute"> | string
    description?: StringFilter<"OrderRoute"> | string
    creator?: StringFilter<"OrderRoute"> | string
    dateCreated?: DateTimeFilter<"OrderRoute"> | Date | string
    lastChangedBy?: StringFilter<"OrderRoute"> | string
    lastChangedDate?: DateTimeFilter<"OrderRoute"> | Date | string
    orderList?: OrderListRelationFilter
  }

  export type OrderRouteOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderList?: OrderOrderByRelationAggregateInput
  }

  export type OrderRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: OrderRouteWhereInput | OrderRouteWhereInput[]
    OR?: OrderRouteWhereInput[]
    NOT?: OrderRouteWhereInput | OrderRouteWhereInput[]
    name?: StringFilter<"OrderRoute"> | string
    description?: StringFilter<"OrderRoute"> | string
    creator?: StringFilter<"OrderRoute"> | string
    dateCreated?: DateTimeFilter<"OrderRoute"> | Date | string
    lastChangedBy?: StringFilter<"OrderRoute"> | string
    lastChangedDate?: DateTimeFilter<"OrderRoute"> | Date | string
    orderList?: OrderListRelationFilter
  }, "id" | "uuid">

  export type OrderRouteOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: OrderRouteCountOrderByAggregateInput
    _max?: OrderRouteMaxOrderByAggregateInput
    _min?: OrderRouteMinOrderByAggregateInput
  }

  export type OrderRouteScalarWhereWithAggregatesInput = {
    AND?: OrderRouteScalarWhereWithAggregatesInput | OrderRouteScalarWhereWithAggregatesInput[]
    OR?: OrderRouteScalarWhereWithAggregatesInput[]
    NOT?: OrderRouteScalarWhereWithAggregatesInput | OrderRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderRoute"> | string
    uuid?: StringWithAggregatesFilter<"OrderRoute"> | string
    name?: StringWithAggregatesFilter<"OrderRoute"> | string
    description?: StringWithAggregatesFilter<"OrderRoute"> | string
    creator?: StringWithAggregatesFilter<"OrderRoute"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"OrderRoute"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"OrderRoute"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"OrderRoute"> | Date | string
  }

  export type OrderTypeWhereInput = {
    AND?: OrderTypeWhereInput | OrderTypeWhereInput[]
    OR?: OrderTypeWhereInput[]
    NOT?: OrderTypeWhereInput | OrderTypeWhereInput[]
    id?: StringFilter<"OrderType"> | string
    uuid?: StringFilter<"OrderType"> | string
    name?: StringFilter<"OrderType"> | string
    description?: StringFilter<"OrderType"> | string
    creator?: StringFilter<"OrderType"> | string
    dateCreated?: DateTimeFilter<"OrderType"> | Date | string
    lastChangedBy?: StringFilter<"OrderType"> | string
    lastChangedDate?: DateTimeFilter<"OrderType"> | Date | string
    orderList?: OrderListRelationFilter
  }

  export type OrderTypeOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderList?: OrderOrderByRelationAggregateInput
  }

  export type OrderTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: OrderTypeWhereInput | OrderTypeWhereInput[]
    OR?: OrderTypeWhereInput[]
    NOT?: OrderTypeWhereInput | OrderTypeWhereInput[]
    name?: StringFilter<"OrderType"> | string
    description?: StringFilter<"OrderType"> | string
    creator?: StringFilter<"OrderType"> | string
    dateCreated?: DateTimeFilter<"OrderType"> | Date | string
    lastChangedBy?: StringFilter<"OrderType"> | string
    lastChangedDate?: DateTimeFilter<"OrderType"> | Date | string
    orderList?: OrderListRelationFilter
  }, "id" | "uuid">

  export type OrderTypeOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: OrderTypeCountOrderByAggregateInput
    _max?: OrderTypeMaxOrderByAggregateInput
    _min?: OrderTypeMinOrderByAggregateInput
  }

  export type OrderTypeScalarWhereWithAggregatesInput = {
    AND?: OrderTypeScalarWhereWithAggregatesInput | OrderTypeScalarWhereWithAggregatesInput[]
    OR?: OrderTypeScalarWhereWithAggregatesInput[]
    NOT?: OrderTypeScalarWhereWithAggregatesInput | OrderTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderType"> | string
    uuid?: StringWithAggregatesFilter<"OrderType"> | string
    name?: StringWithAggregatesFilter<"OrderType"> | string
    description?: StringWithAggregatesFilter<"OrderType"> | string
    creator?: StringWithAggregatesFilter<"OrderType"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"OrderType"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"OrderType"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"OrderType"> | Date | string
  }

  export type OrderUnitWhereInput = {
    AND?: OrderUnitWhereInput | OrderUnitWhereInput[]
    OR?: OrderUnitWhereInput[]
    NOT?: OrderUnitWhereInput | OrderUnitWhereInput[]
    id?: StringFilter<"OrderUnit"> | string
    uuid?: StringFilter<"OrderUnit"> | string
    name?: StringFilter<"OrderUnit"> | string
    description?: StringFilter<"OrderUnit"> | string
    creator?: StringFilter<"OrderUnit"> | string
    dateCreated?: DateTimeFilter<"OrderUnit"> | Date | string
    lastChangedBy?: StringFilter<"OrderUnit"> | string
    lastChangedDate?: DateTimeFilter<"OrderUnit"> | Date | string
    orderList?: OrderListRelationFilter
  }

  export type OrderUnitOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderList?: OrderOrderByRelationAggregateInput
  }

  export type OrderUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: OrderUnitWhereInput | OrderUnitWhereInput[]
    OR?: OrderUnitWhereInput[]
    NOT?: OrderUnitWhereInput | OrderUnitWhereInput[]
    name?: StringFilter<"OrderUnit"> | string
    description?: StringFilter<"OrderUnit"> | string
    creator?: StringFilter<"OrderUnit"> | string
    dateCreated?: DateTimeFilter<"OrderUnit"> | Date | string
    lastChangedBy?: StringFilter<"OrderUnit"> | string
    lastChangedDate?: DateTimeFilter<"OrderUnit"> | Date | string
    orderList?: OrderListRelationFilter
  }, "id" | "uuid">

  export type OrderUnitOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: OrderUnitCountOrderByAggregateInput
    _max?: OrderUnitMaxOrderByAggregateInput
    _min?: OrderUnitMinOrderByAggregateInput
  }

  export type OrderUnitScalarWhereWithAggregatesInput = {
    AND?: OrderUnitScalarWhereWithAggregatesInput | OrderUnitScalarWhereWithAggregatesInput[]
    OR?: OrderUnitScalarWhereWithAggregatesInput[]
    NOT?: OrderUnitScalarWhereWithAggregatesInput | OrderUnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderUnit"> | string
    uuid?: StringWithAggregatesFilter<"OrderUnit"> | string
    name?: StringWithAggregatesFilter<"OrderUnit"> | string
    description?: StringWithAggregatesFilter<"OrderUnit"> | string
    creator?: StringWithAggregatesFilter<"OrderUnit"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"OrderUnit"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"OrderUnit"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"OrderUnit"> | Date | string
  }

  export type ConceptWhereInput = {
    AND?: ConceptWhereInput | ConceptWhereInput[]
    OR?: ConceptWhereInput[]
    NOT?: ConceptWhereInput | ConceptWhereInput[]
    id?: StringFilter<"Concept"> | string
    uuid?: StringFilter<"Concept"> | string
    name?: StringFilter<"Concept"> | string
    description?: StringFilter<"Concept"> | string
    dataType?: StringFilter<"Concept"> | string
    class?: StringFilter<"Concept"> | string
    isRetired?: BoolFilter<"Concept"> | boolean
    retiredBy?: StringFilter<"Concept"> | string
    dateRetired?: DateTimeFilter<"Concept"> | Date | string
    retiredReason?: StringFilter<"Concept"> | string
    creator?: StringFilter<"Concept"> | string
    dateCreated?: DateTimeFilter<"Concept"> | Date | string
    lastChangedBy?: StringFilter<"Concept"> | string
    lastChangedDate?: DateTimeFilter<"Concept"> | Date | string
    conceptClassId?: StringNullableFilter<"Concept"> | string | null
    conceptDatatypeId?: StringNullableFilter<"Concept"> | string | null
    conceptMapId?: StringNullableFilter<"Concept"> | string | null
    conceptSetId?: StringNullableFilter<"Concept"> | string | null
    conceptSourceId?: StringNullableFilter<"Concept"> | string | null
    metaList?: ConceptAnswerListRelationFilter
    answerList?: ConceptAnswerListRelationFilter
    fieldList?: FieldListRelationFilter
    obsList?: ObsListRelationFilter
    orderList?: OrderListRelationFilter
    ConceptClass?: XOR<ConceptClassNullableRelationFilter, ConceptClassWhereInput> | null
    ConceptDatatype?: XOR<ConceptDatatypeNullableRelationFilter, ConceptDatatypeWhereInput> | null
    conceptMap?: XOR<ConceptMapNullableRelationFilter, ConceptMapWhereInput> | null
    conceptNameList?: ConceptNameListRelationFilter
    conceptNumericList?: ConceptNumericListRelationFilter
    conceptProposalList?: ConceptProposalListRelationFilter
    conceptSet?: XOR<ConceptSetNullableRelationFilter, ConceptSetWhereInput> | null
    conceptSource?: XOR<ConceptSourceNullableRelationFilter, ConceptSourceWhereInput> | null
    conceptWordList?: ConceptWordListRelationFilter
  }

  export type ConceptOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    class?: SortOrder
    isRetired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptClassId?: SortOrderInput | SortOrder
    conceptDatatypeId?: SortOrderInput | SortOrder
    conceptMapId?: SortOrderInput | SortOrder
    conceptSetId?: SortOrderInput | SortOrder
    conceptSourceId?: SortOrderInput | SortOrder
    metaList?: ConceptAnswerOrderByRelationAggregateInput
    answerList?: ConceptAnswerOrderByRelationAggregateInput
    fieldList?: FieldOrderByRelationAggregateInput
    obsList?: ObsOrderByRelationAggregateInput
    orderList?: OrderOrderByRelationAggregateInput
    ConceptClass?: ConceptClassOrderByWithRelationInput
    ConceptDatatype?: ConceptDatatypeOrderByWithRelationInput
    conceptMap?: ConceptMapOrderByWithRelationInput
    conceptNameList?: ConceptNameOrderByRelationAggregateInput
    conceptNumericList?: ConceptNumericOrderByRelationAggregateInput
    conceptProposalList?: ConceptProposalOrderByRelationAggregateInput
    conceptSet?: ConceptSetOrderByWithRelationInput
    conceptSource?: ConceptSourceOrderByWithRelationInput
    conceptWordList?: ConceptWordOrderByRelationAggregateInput
  }

  export type ConceptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptWhereInput | ConceptWhereInput[]
    OR?: ConceptWhereInput[]
    NOT?: ConceptWhereInput | ConceptWhereInput[]
    name?: StringFilter<"Concept"> | string
    description?: StringFilter<"Concept"> | string
    dataType?: StringFilter<"Concept"> | string
    class?: StringFilter<"Concept"> | string
    isRetired?: BoolFilter<"Concept"> | boolean
    retiredBy?: StringFilter<"Concept"> | string
    dateRetired?: DateTimeFilter<"Concept"> | Date | string
    retiredReason?: StringFilter<"Concept"> | string
    creator?: StringFilter<"Concept"> | string
    dateCreated?: DateTimeFilter<"Concept"> | Date | string
    lastChangedBy?: StringFilter<"Concept"> | string
    lastChangedDate?: DateTimeFilter<"Concept"> | Date | string
    conceptClassId?: StringNullableFilter<"Concept"> | string | null
    conceptDatatypeId?: StringNullableFilter<"Concept"> | string | null
    conceptMapId?: StringNullableFilter<"Concept"> | string | null
    conceptSetId?: StringNullableFilter<"Concept"> | string | null
    conceptSourceId?: StringNullableFilter<"Concept"> | string | null
    metaList?: ConceptAnswerListRelationFilter
    answerList?: ConceptAnswerListRelationFilter
    fieldList?: FieldListRelationFilter
    obsList?: ObsListRelationFilter
    orderList?: OrderListRelationFilter
    ConceptClass?: XOR<ConceptClassNullableRelationFilter, ConceptClassWhereInput> | null
    ConceptDatatype?: XOR<ConceptDatatypeNullableRelationFilter, ConceptDatatypeWhereInput> | null
    conceptMap?: XOR<ConceptMapNullableRelationFilter, ConceptMapWhereInput> | null
    conceptNameList?: ConceptNameListRelationFilter
    conceptNumericList?: ConceptNumericListRelationFilter
    conceptProposalList?: ConceptProposalListRelationFilter
    conceptSet?: XOR<ConceptSetNullableRelationFilter, ConceptSetWhereInput> | null
    conceptSource?: XOR<ConceptSourceNullableRelationFilter, ConceptSourceWhereInput> | null
    conceptWordList?: ConceptWordListRelationFilter
  }, "id" | "uuid">

  export type ConceptOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    class?: SortOrder
    isRetired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptClassId?: SortOrderInput | SortOrder
    conceptDatatypeId?: SortOrderInput | SortOrder
    conceptMapId?: SortOrderInput | SortOrder
    conceptSetId?: SortOrderInput | SortOrder
    conceptSourceId?: SortOrderInput | SortOrder
    _count?: ConceptCountOrderByAggregateInput
    _max?: ConceptMaxOrderByAggregateInput
    _min?: ConceptMinOrderByAggregateInput
  }

  export type ConceptScalarWhereWithAggregatesInput = {
    AND?: ConceptScalarWhereWithAggregatesInput | ConceptScalarWhereWithAggregatesInput[]
    OR?: ConceptScalarWhereWithAggregatesInput[]
    NOT?: ConceptScalarWhereWithAggregatesInput | ConceptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Concept"> | string
    uuid?: StringWithAggregatesFilter<"Concept"> | string
    name?: StringWithAggregatesFilter<"Concept"> | string
    description?: StringWithAggregatesFilter<"Concept"> | string
    dataType?: StringWithAggregatesFilter<"Concept"> | string
    class?: StringWithAggregatesFilter<"Concept"> | string
    isRetired?: BoolWithAggregatesFilter<"Concept"> | boolean
    retiredBy?: StringWithAggregatesFilter<"Concept"> | string
    dateRetired?: DateTimeWithAggregatesFilter<"Concept"> | Date | string
    retiredReason?: StringWithAggregatesFilter<"Concept"> | string
    creator?: StringWithAggregatesFilter<"Concept"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Concept"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Concept"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Concept"> | Date | string
    conceptClassId?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    conceptDatatypeId?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    conceptMapId?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    conceptSetId?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    conceptSourceId?: StringNullableWithAggregatesFilter<"Concept"> | string | null
  }

  export type ConceptAnswerWhereInput = {
    AND?: ConceptAnswerWhereInput | ConceptAnswerWhereInput[]
    OR?: ConceptAnswerWhereInput[]
    NOT?: ConceptAnswerWhereInput | ConceptAnswerWhereInput[]
    id?: StringFilter<"ConceptAnswer"> | string
    uuid?: StringFilter<"ConceptAnswer"> | string
    conceptId?: StringFilter<"ConceptAnswer"> | string
    answerConceptId?: StringFilter<"ConceptAnswer"> | string
    creator?: StringFilter<"ConceptAnswer"> | string
    dateCreated?: DateTimeFilter<"ConceptAnswer"> | Date | string
    lastChangedBy?: StringFilter<"ConceptAnswer"> | string
    lastChangedDate?: DateTimeFilter<"ConceptAnswer"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    answerConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptAnswerOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    answerConceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
    answerConcept?: ConceptOrderByWithRelationInput
  }

  export type ConceptAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptAnswerWhereInput | ConceptAnswerWhereInput[]
    OR?: ConceptAnswerWhereInput[]
    NOT?: ConceptAnswerWhereInput | ConceptAnswerWhereInput[]
    conceptId?: StringFilter<"ConceptAnswer"> | string
    answerConceptId?: StringFilter<"ConceptAnswer"> | string
    creator?: StringFilter<"ConceptAnswer"> | string
    dateCreated?: DateTimeFilter<"ConceptAnswer"> | Date | string
    lastChangedBy?: StringFilter<"ConceptAnswer"> | string
    lastChangedDate?: DateTimeFilter<"ConceptAnswer"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    answerConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "uuid">

  export type ConceptAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    answerConceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptAnswerCountOrderByAggregateInput
    _max?: ConceptAnswerMaxOrderByAggregateInput
    _min?: ConceptAnswerMinOrderByAggregateInput
  }

  export type ConceptAnswerScalarWhereWithAggregatesInput = {
    AND?: ConceptAnswerScalarWhereWithAggregatesInput | ConceptAnswerScalarWhereWithAggregatesInput[]
    OR?: ConceptAnswerScalarWhereWithAggregatesInput[]
    NOT?: ConceptAnswerScalarWhereWithAggregatesInput | ConceptAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    uuid?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    conceptId?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    answerConceptId?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    creator?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptAnswer"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptAnswer"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptAnswer"> | Date | string
  }

  export type ConceptClassWhereInput = {
    AND?: ConceptClassWhereInput | ConceptClassWhereInput[]
    OR?: ConceptClassWhereInput[]
    NOT?: ConceptClassWhereInput | ConceptClassWhereInput[]
    id?: StringFilter<"ConceptClass"> | string
    uuid?: StringFilter<"ConceptClass"> | string
    name?: StringFilter<"ConceptClass"> | string
    description?: StringFilter<"ConceptClass"> | string
    creator?: StringFilter<"ConceptClass"> | string
    dateCreated?: DateTimeFilter<"ConceptClass"> | Date | string
    lastChangedBy?: StringFilter<"ConceptClass"> | string
    lastChangedDate?: DateTimeFilter<"ConceptClass"> | Date | string
    conceptList?: ConceptListRelationFilter
  }

  export type ConceptClassOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptList?: ConceptOrderByRelationAggregateInput
  }

  export type ConceptClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptClassWhereInput | ConceptClassWhereInput[]
    OR?: ConceptClassWhereInput[]
    NOT?: ConceptClassWhereInput | ConceptClassWhereInput[]
    name?: StringFilter<"ConceptClass"> | string
    description?: StringFilter<"ConceptClass"> | string
    creator?: StringFilter<"ConceptClass"> | string
    dateCreated?: DateTimeFilter<"ConceptClass"> | Date | string
    lastChangedBy?: StringFilter<"ConceptClass"> | string
    lastChangedDate?: DateTimeFilter<"ConceptClass"> | Date | string
    conceptList?: ConceptListRelationFilter
  }, "id" | "uuid">

  export type ConceptClassOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptClassCountOrderByAggregateInput
    _max?: ConceptClassMaxOrderByAggregateInput
    _min?: ConceptClassMinOrderByAggregateInput
  }

  export type ConceptClassScalarWhereWithAggregatesInput = {
    AND?: ConceptClassScalarWhereWithAggregatesInput | ConceptClassScalarWhereWithAggregatesInput[]
    OR?: ConceptClassScalarWhereWithAggregatesInput[]
    NOT?: ConceptClassScalarWhereWithAggregatesInput | ConceptClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptClass"> | string
    uuid?: StringWithAggregatesFilter<"ConceptClass"> | string
    name?: StringWithAggregatesFilter<"ConceptClass"> | string
    description?: StringWithAggregatesFilter<"ConceptClass"> | string
    creator?: StringWithAggregatesFilter<"ConceptClass"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptClass"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptClass"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptClass"> | Date | string
  }

  export type ConceptDatatypeWhereInput = {
    AND?: ConceptDatatypeWhereInput | ConceptDatatypeWhereInput[]
    OR?: ConceptDatatypeWhereInput[]
    NOT?: ConceptDatatypeWhereInput | ConceptDatatypeWhereInput[]
    id?: StringFilter<"ConceptDatatype"> | string
    uuid?: StringFilter<"ConceptDatatype"> | string
    name?: StringFilter<"ConceptDatatype"> | string
    description?: StringFilter<"ConceptDatatype"> | string
    creator?: StringFilter<"ConceptDatatype"> | string
    dateCreated?: DateTimeFilter<"ConceptDatatype"> | Date | string
    lastChangedBy?: StringFilter<"ConceptDatatype"> | string
    lastChangedDate?: DateTimeFilter<"ConceptDatatype"> | Date | string
    conceptList?: ConceptListRelationFilter
  }

  export type ConceptDatatypeOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptList?: ConceptOrderByRelationAggregateInput
  }

  export type ConceptDatatypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptDatatypeWhereInput | ConceptDatatypeWhereInput[]
    OR?: ConceptDatatypeWhereInput[]
    NOT?: ConceptDatatypeWhereInput | ConceptDatatypeWhereInput[]
    name?: StringFilter<"ConceptDatatype"> | string
    description?: StringFilter<"ConceptDatatype"> | string
    creator?: StringFilter<"ConceptDatatype"> | string
    dateCreated?: DateTimeFilter<"ConceptDatatype"> | Date | string
    lastChangedBy?: StringFilter<"ConceptDatatype"> | string
    lastChangedDate?: DateTimeFilter<"ConceptDatatype"> | Date | string
    conceptList?: ConceptListRelationFilter
  }, "id" | "uuid">

  export type ConceptDatatypeOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptDatatypeCountOrderByAggregateInput
    _max?: ConceptDatatypeMaxOrderByAggregateInput
    _min?: ConceptDatatypeMinOrderByAggregateInput
  }

  export type ConceptDatatypeScalarWhereWithAggregatesInput = {
    AND?: ConceptDatatypeScalarWhereWithAggregatesInput | ConceptDatatypeScalarWhereWithAggregatesInput[]
    OR?: ConceptDatatypeScalarWhereWithAggregatesInput[]
    NOT?: ConceptDatatypeScalarWhereWithAggregatesInput | ConceptDatatypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    uuid?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    name?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    description?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    creator?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptDatatype"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptDatatype"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptDatatype"> | Date | string
  }

  export type ConceptMapWhereInput = {
    AND?: ConceptMapWhereInput | ConceptMapWhereInput[]
    OR?: ConceptMapWhereInput[]
    NOT?: ConceptMapWhereInput | ConceptMapWhereInput[]
    id?: StringFilter<"ConceptMap"> | string
    uuid?: StringFilter<"ConceptMap"> | string
    name?: StringFilter<"ConceptMap"> | string
    description?: StringFilter<"ConceptMap"> | string
    creator?: StringFilter<"ConceptMap"> | string
    dateCreated?: DateTimeFilter<"ConceptMap"> | Date | string
    lastChangedBy?: StringFilter<"ConceptMap"> | string
    lastChangedDate?: DateTimeFilter<"ConceptMap"> | Date | string
    conceptList?: ConceptListRelationFilter
  }

  export type ConceptMapOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptList?: ConceptOrderByRelationAggregateInput
  }

  export type ConceptMapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptMapWhereInput | ConceptMapWhereInput[]
    OR?: ConceptMapWhereInput[]
    NOT?: ConceptMapWhereInput | ConceptMapWhereInput[]
    name?: StringFilter<"ConceptMap"> | string
    description?: StringFilter<"ConceptMap"> | string
    creator?: StringFilter<"ConceptMap"> | string
    dateCreated?: DateTimeFilter<"ConceptMap"> | Date | string
    lastChangedBy?: StringFilter<"ConceptMap"> | string
    lastChangedDate?: DateTimeFilter<"ConceptMap"> | Date | string
    conceptList?: ConceptListRelationFilter
  }, "id" | "uuid">

  export type ConceptMapOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptMapCountOrderByAggregateInput
    _max?: ConceptMapMaxOrderByAggregateInput
    _min?: ConceptMapMinOrderByAggregateInput
  }

  export type ConceptMapScalarWhereWithAggregatesInput = {
    AND?: ConceptMapScalarWhereWithAggregatesInput | ConceptMapScalarWhereWithAggregatesInput[]
    OR?: ConceptMapScalarWhereWithAggregatesInput[]
    NOT?: ConceptMapScalarWhereWithAggregatesInput | ConceptMapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptMap"> | string
    uuid?: StringWithAggregatesFilter<"ConceptMap"> | string
    name?: StringWithAggregatesFilter<"ConceptMap"> | string
    description?: StringWithAggregatesFilter<"ConceptMap"> | string
    creator?: StringWithAggregatesFilter<"ConceptMap"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptMap"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptMap"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptMap"> | Date | string
  }

  export type ConceptNameWhereInput = {
    AND?: ConceptNameWhereInput | ConceptNameWhereInput[]
    OR?: ConceptNameWhereInput[]
    NOT?: ConceptNameWhereInput | ConceptNameWhereInput[]
    id?: StringFilter<"ConceptName"> | string
    uuid?: StringFilter<"ConceptName"> | string
    conceptId?: StringFilter<"ConceptName"> | string
    name?: StringFilter<"ConceptName"> | string
    locale?: StringFilter<"ConceptName"> | string
    creator?: StringFilter<"ConceptName"> | string
    dateCreated?: DateTimeFilter<"ConceptName"> | Date | string
    lastChangedBy?: StringFilter<"ConceptName"> | string
    lastChangedDate?: DateTimeFilter<"ConceptName"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptNameOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
  }

  export type ConceptNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptNameWhereInput | ConceptNameWhereInput[]
    OR?: ConceptNameWhereInput[]
    NOT?: ConceptNameWhereInput | ConceptNameWhereInput[]
    conceptId?: StringFilter<"ConceptName"> | string
    name?: StringFilter<"ConceptName"> | string
    locale?: StringFilter<"ConceptName"> | string
    creator?: StringFilter<"ConceptName"> | string
    dateCreated?: DateTimeFilter<"ConceptName"> | Date | string
    lastChangedBy?: StringFilter<"ConceptName"> | string
    lastChangedDate?: DateTimeFilter<"ConceptName"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "uuid">

  export type ConceptNameOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptNameCountOrderByAggregateInput
    _max?: ConceptNameMaxOrderByAggregateInput
    _min?: ConceptNameMinOrderByAggregateInput
  }

  export type ConceptNameScalarWhereWithAggregatesInput = {
    AND?: ConceptNameScalarWhereWithAggregatesInput | ConceptNameScalarWhereWithAggregatesInput[]
    OR?: ConceptNameScalarWhereWithAggregatesInput[]
    NOT?: ConceptNameScalarWhereWithAggregatesInput | ConceptNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptName"> | string
    uuid?: StringWithAggregatesFilter<"ConceptName"> | string
    conceptId?: StringWithAggregatesFilter<"ConceptName"> | string
    name?: StringWithAggregatesFilter<"ConceptName"> | string
    locale?: StringWithAggregatesFilter<"ConceptName"> | string
    creator?: StringWithAggregatesFilter<"ConceptName"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptName"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptName"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptName"> | Date | string
  }

  export type ConceptNumericWhereInput = {
    AND?: ConceptNumericWhereInput | ConceptNumericWhereInput[]
    OR?: ConceptNumericWhereInput[]
    NOT?: ConceptNumericWhereInput | ConceptNumericWhereInput[]
    id?: StringFilter<"ConceptNumeric"> | string
    uuid?: StringFilter<"ConceptNumeric"> | string
    conceptId?: StringFilter<"ConceptNumeric"> | string
    hiAbsolute?: FloatFilter<"ConceptNumeric"> | number
    hiCritical?: FloatFilter<"ConceptNumeric"> | number
    hiNormal?: FloatFilter<"ConceptNumeric"> | number
    lowAbsolute?: FloatFilter<"ConceptNumeric"> | number
    lowCritical?: FloatFilter<"ConceptNumeric"> | number
    lowNormal?: FloatFilter<"ConceptNumeric"> | number
    units?: StringFilter<"ConceptNumeric"> | string
    creator?: StringFilter<"ConceptNumeric"> | string
    dateCreated?: DateTimeFilter<"ConceptNumeric"> | Date | string
    lastChangedBy?: StringFilter<"ConceptNumeric"> | string
    lastChangedDate?: DateTimeFilter<"ConceptNumeric"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptNumericOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
  }

  export type ConceptNumericWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptNumericWhereInput | ConceptNumericWhereInput[]
    OR?: ConceptNumericWhereInput[]
    NOT?: ConceptNumericWhereInput | ConceptNumericWhereInput[]
    conceptId?: StringFilter<"ConceptNumeric"> | string
    hiAbsolute?: FloatFilter<"ConceptNumeric"> | number
    hiCritical?: FloatFilter<"ConceptNumeric"> | number
    hiNormal?: FloatFilter<"ConceptNumeric"> | number
    lowAbsolute?: FloatFilter<"ConceptNumeric"> | number
    lowCritical?: FloatFilter<"ConceptNumeric"> | number
    lowNormal?: FloatFilter<"ConceptNumeric"> | number
    units?: StringFilter<"ConceptNumeric"> | string
    creator?: StringFilter<"ConceptNumeric"> | string
    dateCreated?: DateTimeFilter<"ConceptNumeric"> | Date | string
    lastChangedBy?: StringFilter<"ConceptNumeric"> | string
    lastChangedDate?: DateTimeFilter<"ConceptNumeric"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "uuid">

  export type ConceptNumericOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptNumericCountOrderByAggregateInput
    _avg?: ConceptNumericAvgOrderByAggregateInput
    _max?: ConceptNumericMaxOrderByAggregateInput
    _min?: ConceptNumericMinOrderByAggregateInput
    _sum?: ConceptNumericSumOrderByAggregateInput
  }

  export type ConceptNumericScalarWhereWithAggregatesInput = {
    AND?: ConceptNumericScalarWhereWithAggregatesInput | ConceptNumericScalarWhereWithAggregatesInput[]
    OR?: ConceptNumericScalarWhereWithAggregatesInput[]
    NOT?: ConceptNumericScalarWhereWithAggregatesInput | ConceptNumericScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    uuid?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    conceptId?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    hiAbsolute?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    hiCritical?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    hiNormal?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    lowAbsolute?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    lowCritical?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    lowNormal?: FloatWithAggregatesFilter<"ConceptNumeric"> | number
    units?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    creator?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptNumeric"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptNumeric"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptNumeric"> | Date | string
  }

  export type ConceptProposalWhereInput = {
    AND?: ConceptProposalWhereInput | ConceptProposalWhereInput[]
    OR?: ConceptProposalWhereInput[]
    NOT?: ConceptProposalWhereInput | ConceptProposalWhereInput[]
    id?: StringFilter<"ConceptProposal"> | string
    uuid?: StringFilter<"ConceptProposal"> | string
    conceptId?: StringFilter<"ConceptProposal"> | string
    name?: StringFilter<"ConceptProposal"> | string
    description?: StringFilter<"ConceptProposal"> | string
    creator?: StringFilter<"ConceptProposal"> | string
    dateCreated?: DateTimeFilter<"ConceptProposal"> | Date | string
    lastChangedBy?: StringFilter<"ConceptProposal"> | string
    lastChangedDate?: DateTimeFilter<"ConceptProposal"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptProposalOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
  }

  export type ConceptProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptProposalWhereInput | ConceptProposalWhereInput[]
    OR?: ConceptProposalWhereInput[]
    NOT?: ConceptProposalWhereInput | ConceptProposalWhereInput[]
    conceptId?: StringFilter<"ConceptProposal"> | string
    name?: StringFilter<"ConceptProposal"> | string
    description?: StringFilter<"ConceptProposal"> | string
    creator?: StringFilter<"ConceptProposal"> | string
    dateCreated?: DateTimeFilter<"ConceptProposal"> | Date | string
    lastChangedBy?: StringFilter<"ConceptProposal"> | string
    lastChangedDate?: DateTimeFilter<"ConceptProposal"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "uuid">

  export type ConceptProposalOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptProposalCountOrderByAggregateInput
    _max?: ConceptProposalMaxOrderByAggregateInput
    _min?: ConceptProposalMinOrderByAggregateInput
  }

  export type ConceptProposalScalarWhereWithAggregatesInput = {
    AND?: ConceptProposalScalarWhereWithAggregatesInput | ConceptProposalScalarWhereWithAggregatesInput[]
    OR?: ConceptProposalScalarWhereWithAggregatesInput[]
    NOT?: ConceptProposalScalarWhereWithAggregatesInput | ConceptProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptProposal"> | string
    uuid?: StringWithAggregatesFilter<"ConceptProposal"> | string
    conceptId?: StringWithAggregatesFilter<"ConceptProposal"> | string
    name?: StringWithAggregatesFilter<"ConceptProposal"> | string
    description?: StringWithAggregatesFilter<"ConceptProposal"> | string
    creator?: StringWithAggregatesFilter<"ConceptProposal"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptProposal"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptProposal"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptProposal"> | Date | string
  }

  export type ConceptSetWhereInput = {
    AND?: ConceptSetWhereInput | ConceptSetWhereInput[]
    OR?: ConceptSetWhereInput[]
    NOT?: ConceptSetWhereInput | ConceptSetWhereInput[]
    id?: StringFilter<"ConceptSet"> | string
    uuid?: StringFilter<"ConceptSet"> | string
    name?: StringFilter<"ConceptSet"> | string
    description?: StringFilter<"ConceptSet"> | string
    creator?: StringFilter<"ConceptSet"> | string
    dateCreated?: DateTimeFilter<"ConceptSet"> | Date | string
    lastChangedBy?: StringFilter<"ConceptSet"> | string
    lastChangedDate?: DateTimeFilter<"ConceptSet"> | Date | string
    conceptList?: ConceptListRelationFilter
  }

  export type ConceptSetOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptList?: ConceptOrderByRelationAggregateInput
  }

  export type ConceptSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptSetWhereInput | ConceptSetWhereInput[]
    OR?: ConceptSetWhereInput[]
    NOT?: ConceptSetWhereInput | ConceptSetWhereInput[]
    name?: StringFilter<"ConceptSet"> | string
    description?: StringFilter<"ConceptSet"> | string
    creator?: StringFilter<"ConceptSet"> | string
    dateCreated?: DateTimeFilter<"ConceptSet"> | Date | string
    lastChangedBy?: StringFilter<"ConceptSet"> | string
    lastChangedDate?: DateTimeFilter<"ConceptSet"> | Date | string
    conceptList?: ConceptListRelationFilter
  }, "id" | "uuid">

  export type ConceptSetOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptSetCountOrderByAggregateInput
    _max?: ConceptSetMaxOrderByAggregateInput
    _min?: ConceptSetMinOrderByAggregateInput
  }

  export type ConceptSetScalarWhereWithAggregatesInput = {
    AND?: ConceptSetScalarWhereWithAggregatesInput | ConceptSetScalarWhereWithAggregatesInput[]
    OR?: ConceptSetScalarWhereWithAggregatesInput[]
    NOT?: ConceptSetScalarWhereWithAggregatesInput | ConceptSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptSet"> | string
    uuid?: StringWithAggregatesFilter<"ConceptSet"> | string
    name?: StringWithAggregatesFilter<"ConceptSet"> | string
    description?: StringWithAggregatesFilter<"ConceptSet"> | string
    creator?: StringWithAggregatesFilter<"ConceptSet"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptSet"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptSet"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptSet"> | Date | string
  }

  export type ConceptSourceWhereInput = {
    AND?: ConceptSourceWhereInput | ConceptSourceWhereInput[]
    OR?: ConceptSourceWhereInput[]
    NOT?: ConceptSourceWhereInput | ConceptSourceWhereInput[]
    id?: StringFilter<"ConceptSource"> | string
    uuid?: StringFilter<"ConceptSource"> | string
    name?: StringFilter<"ConceptSource"> | string
    description?: StringFilter<"ConceptSource"> | string
    creator?: StringFilter<"ConceptSource"> | string
    dateCreated?: DateTimeFilter<"ConceptSource"> | Date | string
    lastChangedBy?: StringFilter<"ConceptSource"> | string
    lastChangedDate?: DateTimeFilter<"ConceptSource"> | Date | string
    conceptList?: ConceptListRelationFilter
  }

  export type ConceptSourceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptList?: ConceptOrderByRelationAggregateInput
  }

  export type ConceptSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptSourceWhereInput | ConceptSourceWhereInput[]
    OR?: ConceptSourceWhereInput[]
    NOT?: ConceptSourceWhereInput | ConceptSourceWhereInput[]
    name?: StringFilter<"ConceptSource"> | string
    description?: StringFilter<"ConceptSource"> | string
    creator?: StringFilter<"ConceptSource"> | string
    dateCreated?: DateTimeFilter<"ConceptSource"> | Date | string
    lastChangedBy?: StringFilter<"ConceptSource"> | string
    lastChangedDate?: DateTimeFilter<"ConceptSource"> | Date | string
    conceptList?: ConceptListRelationFilter
  }, "id" | "uuid">

  export type ConceptSourceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptSourceCountOrderByAggregateInput
    _max?: ConceptSourceMaxOrderByAggregateInput
    _min?: ConceptSourceMinOrderByAggregateInput
  }

  export type ConceptSourceScalarWhereWithAggregatesInput = {
    AND?: ConceptSourceScalarWhereWithAggregatesInput | ConceptSourceScalarWhereWithAggregatesInput[]
    OR?: ConceptSourceScalarWhereWithAggregatesInput[]
    NOT?: ConceptSourceScalarWhereWithAggregatesInput | ConceptSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptSource"> | string
    uuid?: StringWithAggregatesFilter<"ConceptSource"> | string
    name?: StringWithAggregatesFilter<"ConceptSource"> | string
    description?: StringWithAggregatesFilter<"ConceptSource"> | string
    creator?: StringWithAggregatesFilter<"ConceptSource"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptSource"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptSource"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptSource"> | Date | string
  }

  export type ConceptWordWhereInput = {
    AND?: ConceptWordWhereInput | ConceptWordWhereInput[]
    OR?: ConceptWordWhereInput[]
    NOT?: ConceptWordWhereInput | ConceptWordWhereInput[]
    id?: StringFilter<"ConceptWord"> | string
    uuid?: StringFilter<"ConceptWord"> | string
    conceptId?: StringFilter<"ConceptWord"> | string
    word?: StringFilter<"ConceptWord"> | string
    locale?: StringFilter<"ConceptWord"> | string
    creator?: StringFilter<"ConceptWord"> | string
    dateCreated?: DateTimeFilter<"ConceptWord"> | Date | string
    lastChangedBy?: StringFilter<"ConceptWord"> | string
    lastChangedDate?: DateTimeFilter<"ConceptWord"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptWordOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    word?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    concept?: ConceptOrderByWithRelationInput
  }

  export type ConceptWordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ConceptWordWhereInput | ConceptWordWhereInput[]
    OR?: ConceptWordWhereInput[]
    NOT?: ConceptWordWhereInput | ConceptWordWhereInput[]
    conceptId?: StringFilter<"ConceptWord"> | string
    word?: StringFilter<"ConceptWord"> | string
    locale?: StringFilter<"ConceptWord"> | string
    creator?: StringFilter<"ConceptWord"> | string
    dateCreated?: DateTimeFilter<"ConceptWord"> | Date | string
    lastChangedBy?: StringFilter<"ConceptWord"> | string
    lastChangedDate?: DateTimeFilter<"ConceptWord"> | Date | string
    concept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "uuid">

  export type ConceptWordOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    word?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ConceptWordCountOrderByAggregateInput
    _max?: ConceptWordMaxOrderByAggregateInput
    _min?: ConceptWordMinOrderByAggregateInput
  }

  export type ConceptWordScalarWhereWithAggregatesInput = {
    AND?: ConceptWordScalarWhereWithAggregatesInput | ConceptWordScalarWhereWithAggregatesInput[]
    OR?: ConceptWordScalarWhereWithAggregatesInput[]
    NOT?: ConceptWordScalarWhereWithAggregatesInput | ConceptWordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptWord"> | string
    uuid?: StringWithAggregatesFilter<"ConceptWord"> | string
    conceptId?: StringWithAggregatesFilter<"ConceptWord"> | string
    word?: StringWithAggregatesFilter<"ConceptWord"> | string
    locale?: StringWithAggregatesFilter<"ConceptWord"> | string
    creator?: StringWithAggregatesFilter<"ConceptWord"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"ConceptWord"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"ConceptWord"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"ConceptWord"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: StringFilter<"Resource"> | string
    uuid?: StringFilter<"Resource"> | string
    name?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    creator?: StringFilter<"Resource"> | string
    dateCreated?: DateTimeFilter<"Resource"> | Date | string
    lastChangedBy?: StringFilter<"Resource"> | string
    lastChangedDate?: DateTimeFilter<"Resource"> | Date | string
    formResourceList?: FormResourceListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    formResourceList?: FormResourceOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    name?: StringFilter<"Resource"> | string
    description?: StringFilter<"Resource"> | string
    creator?: StringFilter<"Resource"> | string
    dateCreated?: DateTimeFilter<"Resource"> | Date | string
    lastChangedBy?: StringFilter<"Resource"> | string
    lastChangedDate?: DateTimeFilter<"Resource"> | Date | string
    formResourceList?: FormResourceListRelationFilter
  }, "id" | "uuid">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resource"> | string
    uuid?: StringWithAggregatesFilter<"Resource"> | string
    name?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringWithAggregatesFilter<"Resource"> | string
    creator?: StringWithAggregatesFilter<"Resource"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    lastChangedBy?: StringWithAggregatesFilter<"Resource"> | string
    lastChangedDate?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    context?: JsonFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    spaceTimeCoordinatesId?: StringFilter<"BlogPost"> | string
    author?: XOR<BlogPostAuthorRelationFilter, BlogPostAuthorWhereInput>
    spaceTimeCoordinates?: XOR<SpaceTimeCoordinatesRelationFilter, SpaceTimeCoordinatesWhereInput>
    tagArrowList?: BlogPostTagArrowListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    context?: SortOrder
    authorId?: SortOrder
    spaceTimeCoordinatesId?: SortOrder
    author?: BlogPostAuthorOrderByWithRelationInput
    spaceTimeCoordinates?: SpaceTimeCoordinatesOrderByWithRelationInput
    tagArrowList?: BlogPostTagArrowOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    spaceTimeCoordinatesId?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    context?: JsonFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    author?: XOR<BlogPostAuthorRelationFilter, BlogPostAuthorWhereInput>
    spaceTimeCoordinates?: XOR<SpaceTimeCoordinatesRelationFilter, SpaceTimeCoordinatesWhereInput>
    tagArrowList?: BlogPostTagArrowListRelationFilter
  }, "id" | "spaceTimeCoordinatesId">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    context?: SortOrder
    authorId?: SortOrder
    spaceTimeCoordinatesId?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    context?: JsonWithAggregatesFilter<"BlogPost">
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    spaceTimeCoordinatesId?: StringWithAggregatesFilter<"BlogPost"> | string
  }

  export type BlogPostTagWhereInput = {
    AND?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    OR?: BlogPostTagWhereInput[]
    NOT?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    id?: StringFilter<"BlogPostTag"> | string
    name?: StringFilter<"BlogPostTag"> | string
    descriptor?: StringNullableFilter<"BlogPostTag"> | string | null
    postArrowList?: BlogPostTagArrowListRelationFilter
  }

  export type BlogPostTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    descriptor?: SortOrderInput | SortOrder
    postArrowList?: BlogPostTagArrowOrderByRelationAggregateInput
  }

  export type BlogPostTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    OR?: BlogPostTagWhereInput[]
    NOT?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    name?: StringFilter<"BlogPostTag"> | string
    descriptor?: StringNullableFilter<"BlogPostTag"> | string | null
    postArrowList?: BlogPostTagArrowListRelationFilter
  }, "id">

  export type BlogPostTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    descriptor?: SortOrderInput | SortOrder
    _count?: BlogPostTagCountOrderByAggregateInput
    _max?: BlogPostTagMaxOrderByAggregateInput
    _min?: BlogPostTagMinOrderByAggregateInput
  }

  export type BlogPostTagScalarWhereWithAggregatesInput = {
    AND?: BlogPostTagScalarWhereWithAggregatesInput | BlogPostTagScalarWhereWithAggregatesInput[]
    OR?: BlogPostTagScalarWhereWithAggregatesInput[]
    NOT?: BlogPostTagScalarWhereWithAggregatesInput | BlogPostTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPostTag"> | string
    name?: StringWithAggregatesFilter<"BlogPostTag"> | string
    descriptor?: StringNullableWithAggregatesFilter<"BlogPostTag"> | string | null
  }

  export type BlogPostTagArrowWhereInput = {
    AND?: BlogPostTagArrowWhereInput | BlogPostTagArrowWhereInput[]
    OR?: BlogPostTagArrowWhereInput[]
    NOT?: BlogPostTagArrowWhereInput | BlogPostTagArrowWhereInput[]
    id?: StringFilter<"BlogPostTagArrow"> | string
    postId?: StringFilter<"BlogPostTagArrow"> | string
    tagId?: StringFilter<"BlogPostTagArrow"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<BlogPostTagRelationFilter, BlogPostTagWhereInput>
  }

  export type BlogPostTagArrowOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    tagId?: SortOrder
    post?: BlogPostOrderByWithRelationInput
    tag?: BlogPostTagOrderByWithRelationInput
  }

  export type BlogPostTagArrowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_tagId?: BlogPostTagArrowPostIdTagIdCompoundUniqueInput
    AND?: BlogPostTagArrowWhereInput | BlogPostTagArrowWhereInput[]
    OR?: BlogPostTagArrowWhereInput[]
    NOT?: BlogPostTagArrowWhereInput | BlogPostTagArrowWhereInput[]
    postId?: StringFilter<"BlogPostTagArrow"> | string
    tagId?: StringFilter<"BlogPostTagArrow"> | string
    post?: XOR<BlogPostRelationFilter, BlogPostWhereInput>
    tag?: XOR<BlogPostTagRelationFilter, BlogPostTagWhereInput>
  }, "id" | "postId_tagId">

  export type BlogPostTagArrowOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    tagId?: SortOrder
    _count?: BlogPostTagArrowCountOrderByAggregateInput
    _max?: BlogPostTagArrowMaxOrderByAggregateInput
    _min?: BlogPostTagArrowMinOrderByAggregateInput
  }

  export type BlogPostTagArrowScalarWhereWithAggregatesInput = {
    AND?: BlogPostTagArrowScalarWhereWithAggregatesInput | BlogPostTagArrowScalarWhereWithAggregatesInput[]
    OR?: BlogPostTagArrowScalarWhereWithAggregatesInput[]
    NOT?: BlogPostTagArrowScalarWhereWithAggregatesInput | BlogPostTagArrowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPostTagArrow"> | string
    postId?: StringWithAggregatesFilter<"BlogPostTagArrow"> | string
    tagId?: StringWithAggregatesFilter<"BlogPostTagArrow"> | string
  }

  export type BlogPostAuthorWhereInput = {
    AND?: BlogPostAuthorWhereInput | BlogPostAuthorWhereInput[]
    OR?: BlogPostAuthorWhereInput[]
    NOT?: BlogPostAuthorWhereInput | BlogPostAuthorWhereInput[]
    id?: StringFilter<"BlogPostAuthor"> | string
    name?: StringFilter<"BlogPostAuthor"> | string
    blogPostList?: BlogPostListRelationFilter
  }

  export type BlogPostAuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    blogPostList?: BlogPostOrderByRelationAggregateInput
  }

  export type BlogPostAuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogPostAuthorWhereInput | BlogPostAuthorWhereInput[]
    OR?: BlogPostAuthorWhereInput[]
    NOT?: BlogPostAuthorWhereInput | BlogPostAuthorWhereInput[]
    name?: StringFilter<"BlogPostAuthor"> | string
    blogPostList?: BlogPostListRelationFilter
  }, "id">

  export type BlogPostAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BlogPostAuthorCountOrderByAggregateInput
    _max?: BlogPostAuthorMaxOrderByAggregateInput
    _min?: BlogPostAuthorMinOrderByAggregateInput
  }

  export type BlogPostAuthorScalarWhereWithAggregatesInput = {
    AND?: BlogPostAuthorScalarWhereWithAggregatesInput | BlogPostAuthorScalarWhereWithAggregatesInput[]
    OR?: BlogPostAuthorScalarWhereWithAggregatesInput[]
    NOT?: BlogPostAuthorScalarWhereWithAggregatesInput | BlogPostAuthorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPostAuthor"> | string
    name?: StringWithAggregatesFilter<"BlogPostAuthor"> | string
  }

  export type SpaceTimeCoordinatesWhereInput = {
    AND?: SpaceTimeCoordinatesWhereInput | SpaceTimeCoordinatesWhereInput[]
    OR?: SpaceTimeCoordinatesWhereInput[]
    NOT?: SpaceTimeCoordinatesWhereInput | SpaceTimeCoordinatesWhereInput[]
    id?: StringFilter<"SpaceTimeCoordinates"> | string
    latitude?: FloatFilter<"SpaceTimeCoordinates"> | number
    longitude?: FloatFilter<"SpaceTimeCoordinates"> | number
    startTime?: FloatFilter<"SpaceTimeCoordinates"> | number
    pauseTime?: FloatNullableFilter<"SpaceTimeCoordinates"> | number | null
    stopTime?: FloatFilter<"SpaceTimeCoordinates"> | number
    timezone?: StringFilter<"SpaceTimeCoordinates"> | string
    blogPostId?: UuidFilter<"SpaceTimeCoordinates"> | string
    BlogPost?: XOR<BlogPostNullableRelationFilter, BlogPostWhereInput> | null
  }

  export type SpaceTimeCoordinatesOrderByWithRelationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrderInput | SortOrder
    stopTime?: SortOrder
    timezone?: SortOrder
    blogPostId?: SortOrder
    BlogPost?: BlogPostOrderByWithRelationInput
  }

  export type SpaceTimeCoordinatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpaceTimeCoordinatesWhereInput | SpaceTimeCoordinatesWhereInput[]
    OR?: SpaceTimeCoordinatesWhereInput[]
    NOT?: SpaceTimeCoordinatesWhereInput | SpaceTimeCoordinatesWhereInput[]
    latitude?: FloatFilter<"SpaceTimeCoordinates"> | number
    longitude?: FloatFilter<"SpaceTimeCoordinates"> | number
    startTime?: FloatFilter<"SpaceTimeCoordinates"> | number
    pauseTime?: FloatNullableFilter<"SpaceTimeCoordinates"> | number | null
    stopTime?: FloatFilter<"SpaceTimeCoordinates"> | number
    timezone?: StringFilter<"SpaceTimeCoordinates"> | string
    blogPostId?: UuidFilter<"SpaceTimeCoordinates"> | string
    BlogPost?: XOR<BlogPostNullableRelationFilter, BlogPostWhereInput> | null
  }, "id">

  export type SpaceTimeCoordinatesOrderByWithAggregationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrderInput | SortOrder
    stopTime?: SortOrder
    timezone?: SortOrder
    blogPostId?: SortOrder
    _count?: SpaceTimeCoordinatesCountOrderByAggregateInput
    _avg?: SpaceTimeCoordinatesAvgOrderByAggregateInput
    _max?: SpaceTimeCoordinatesMaxOrderByAggregateInput
    _min?: SpaceTimeCoordinatesMinOrderByAggregateInput
    _sum?: SpaceTimeCoordinatesSumOrderByAggregateInput
  }

  export type SpaceTimeCoordinatesScalarWhereWithAggregatesInput = {
    AND?: SpaceTimeCoordinatesScalarWhereWithAggregatesInput | SpaceTimeCoordinatesScalarWhereWithAggregatesInput[]
    OR?: SpaceTimeCoordinatesScalarWhereWithAggregatesInput[]
    NOT?: SpaceTimeCoordinatesScalarWhereWithAggregatesInput | SpaceTimeCoordinatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaceTimeCoordinates"> | string
    latitude?: FloatWithAggregatesFilter<"SpaceTimeCoordinates"> | number
    longitude?: FloatWithAggregatesFilter<"SpaceTimeCoordinates"> | number
    startTime?: FloatWithAggregatesFilter<"SpaceTimeCoordinates"> | number
    pauseTime?: FloatNullableWithAggregatesFilter<"SpaceTimeCoordinates"> | number | null
    stopTime?: FloatWithAggregatesFilter<"SpaceTimeCoordinates"> | number
    timezone?: StringWithAggregatesFilter<"SpaceTimeCoordinates"> | string
    blogPostId?: UuidWithAggregatesFilter<"SpaceTimeCoordinates"> | string
  }

  export type BudgetEntryWhereInput = {
    AND?: BudgetEntryWhereInput | BudgetEntryWhereInput[]
    OR?: BudgetEntryWhereInput[]
    NOT?: BudgetEntryWhereInput | BudgetEntryWhereInput[]
    id?: StringFilter<"BudgetEntry"> | string
    serviceId?: StringFilter<"BudgetEntry"> | string
    cost?: FloatFilter<"BudgetEntry"> | number
    discount?: FloatFilter<"BudgetEntry"> | number
    promotion?: FloatFilter<"BudgetEntry"> | number
    subtotal?: FloatFilter<"BudgetEntry"> | number
    percentChange?: FloatFilter<"BudgetEntry"> | number
    createdAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    budgetId?: StringFilter<"BudgetEntry"> | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }

  export type BudgetEntryOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetEntryWhereInput | BudgetEntryWhereInput[]
    OR?: BudgetEntryWhereInput[]
    NOT?: BudgetEntryWhereInput | BudgetEntryWhereInput[]
    serviceId?: StringFilter<"BudgetEntry"> | string
    cost?: FloatFilter<"BudgetEntry"> | number
    discount?: FloatFilter<"BudgetEntry"> | number
    promotion?: FloatFilter<"BudgetEntry"> | number
    subtotal?: FloatFilter<"BudgetEntry"> | number
    percentChange?: FloatFilter<"BudgetEntry"> | number
    createdAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    budgetId?: StringFilter<"BudgetEntry"> | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }, "id">

  export type BudgetEntryOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetId?: SortOrder
    _count?: BudgetEntryCountOrderByAggregateInput
    _avg?: BudgetEntryAvgOrderByAggregateInput
    _max?: BudgetEntryMaxOrderByAggregateInput
    _min?: BudgetEntryMinOrderByAggregateInput
    _sum?: BudgetEntrySumOrderByAggregateInput
  }

  export type BudgetEntryScalarWhereWithAggregatesInput = {
    AND?: BudgetEntryScalarWhereWithAggregatesInput | BudgetEntryScalarWhereWithAggregatesInput[]
    OR?: BudgetEntryScalarWhereWithAggregatesInput[]
    NOT?: BudgetEntryScalarWhereWithAggregatesInput | BudgetEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetEntry"> | string
    serviceId?: StringWithAggregatesFilter<"BudgetEntry"> | string
    cost?: FloatWithAggregatesFilter<"BudgetEntry"> | number
    discount?: FloatWithAggregatesFilter<"BudgetEntry"> | number
    promotion?: FloatWithAggregatesFilter<"BudgetEntry"> | number
    subtotal?: FloatWithAggregatesFilter<"BudgetEntry"> | number
    percentChange?: FloatWithAggregatesFilter<"BudgetEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BudgetEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BudgetEntry"> | Date | string
    budgetId?: StringWithAggregatesFilter<"BudgetEntry"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    category?: StringFilter<"Service"> | string
    metadata?: JsonFilter<"Service">
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    entryList?: BudgetEntryListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entryList?: BudgetEntryOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    description?: StringFilter<"Service"> | string
    category?: StringFilter<"Service"> | string
    metadata?: JsonFilter<"Service">
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    entryList?: BudgetEntryListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    description?: StringWithAggregatesFilter<"Service"> | string
    category?: StringWithAggregatesFilter<"Service"> | string
    metadata?: JsonWithAggregatesFilter<"Service">
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    fiscalYear?: IntFilter<"Budget"> | number
    reportId?: StringNullableFilter<"Budget"> | string | null
    entryList?: BudgetEntryListRelationFilter
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
    userList?: BudgetBudUserListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: SortOrder
    reportId?: SortOrderInput | SortOrder
    entryList?: BudgetEntryOrderByRelationAggregateInput
    report?: ReportOrderByWithRelationInput
    userList?: BudgetBudUserOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    fiscalYear?: IntFilter<"Budget"> | number
    reportId?: StringNullableFilter<"Budget"> | string | null
    entryList?: BudgetEntryListRelationFilter
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
    userList?: BudgetBudUserListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    fiscalYear?: IntWithAggregatesFilter<"Budget"> | number
    reportId?: StringNullableWithAggregatesFilter<"Budget"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    budgetId?: StringFilter<"Report"> | string
    totalCost?: FloatFilter<"Report"> | number
    totalDiscount?: FloatFilter<"Report"> | number
    totalPromotion?: FloatFilter<"Report"> | number
    totalSubtotal?: FloatFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetId?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    totalCost?: FloatFilter<"Report"> | number
    totalDiscount?: FloatFilter<"Report"> | number
    totalPromotion?: FloatFilter<"Report"> | number
    totalSubtotal?: FloatFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }, "id" | "budgetId">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    budgetId?: StringWithAggregatesFilter<"Report"> | string
    totalCost?: FloatWithAggregatesFilter<"Report"> | number
    totalDiscount?: FloatWithAggregatesFilter<"Report"> | number
    totalPromotion?: FloatWithAggregatesFilter<"Report"> | number
    totalSubtotal?: FloatWithAggregatesFilter<"Report"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type BudUserWhereInput = {
    AND?: BudUserWhereInput | BudUserWhereInput[]
    OR?: BudUserWhereInput[]
    NOT?: BudUserWhereInput | BudUserWhereInput[]
    id?: StringFilter<"BudUser"> | string
    name?: StringFilter<"BudUser"> | string
    email?: StringFilter<"BudUser"> | string
    password?: StringFilter<"BudUser"> | string
    createdAt?: DateTimeFilter<"BudUser"> | Date | string
    updatedAt?: DateTimeFilter<"BudUser"> | Date | string
    budgetList?: BudgetBudUserListRelationFilter
    eventList?: BudEventListRelationFilter
  }

  export type BudUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetList?: BudgetBudUserOrderByRelationAggregateInput
    eventList?: BudEventOrderByRelationAggregateInput
  }

  export type BudUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: BudUserWhereInput | BudUserWhereInput[]
    OR?: BudUserWhereInput[]
    NOT?: BudUserWhereInput | BudUserWhereInput[]
    name?: StringFilter<"BudUser"> | string
    password?: StringFilter<"BudUser"> | string
    createdAt?: DateTimeFilter<"BudUser"> | Date | string
    updatedAt?: DateTimeFilter<"BudUser"> | Date | string
    budgetList?: BudgetBudUserListRelationFilter
    eventList?: BudEventListRelationFilter
  }, "id" | "email">

  export type BudUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudUserCountOrderByAggregateInput
    _max?: BudUserMaxOrderByAggregateInput
    _min?: BudUserMinOrderByAggregateInput
  }

  export type BudUserScalarWhereWithAggregatesInput = {
    AND?: BudUserScalarWhereWithAggregatesInput | BudUserScalarWhereWithAggregatesInput[]
    OR?: BudUserScalarWhereWithAggregatesInput[]
    NOT?: BudUserScalarWhereWithAggregatesInput | BudUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudUser"> | string
    name?: StringWithAggregatesFilter<"BudUser"> | string
    email?: StringWithAggregatesFilter<"BudUser"> | string
    password?: StringWithAggregatesFilter<"BudUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BudUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BudUser"> | Date | string
  }

  export type BudgetBudUserWhereInput = {
    AND?: BudgetBudUserWhereInput | BudgetBudUserWhereInput[]
    OR?: BudgetBudUserWhereInput[]
    NOT?: BudgetBudUserWhereInput | BudgetBudUserWhereInput[]
    userId?: StringFilter<"BudgetBudUser"> | string
    budgetId?: StringFilter<"BudgetBudUser"> | string
    role?: StringFilter<"BudgetBudUser"> | string
    ability?: StringFilter<"BudgetBudUser"> | string
    category?: StringFilter<"BudgetBudUser"> | string
    user?: XOR<BudUserRelationFilter, BudUserWhereInput>
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }

  export type BudgetBudUserOrderByWithRelationInput = {
    userId?: SortOrder
    budgetId?: SortOrder
    role?: SortOrder
    ability?: SortOrder
    category?: SortOrder
    user?: BudUserOrderByWithRelationInput
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetBudUserWhereUniqueInput = Prisma.AtLeast<{
    userId_budgetId?: BudgetBudUserUserIdBudgetIdCompoundUniqueInput
    AND?: BudgetBudUserWhereInput | BudgetBudUserWhereInput[]
    OR?: BudgetBudUserWhereInput[]
    NOT?: BudgetBudUserWhereInput | BudgetBudUserWhereInput[]
    userId?: StringFilter<"BudgetBudUser"> | string
    budgetId?: StringFilter<"BudgetBudUser"> | string
    role?: StringFilter<"BudgetBudUser"> | string
    ability?: StringFilter<"BudgetBudUser"> | string
    category?: StringFilter<"BudgetBudUser"> | string
    user?: XOR<BudUserRelationFilter, BudUserWhereInput>
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }, "userId_budgetId">

  export type BudgetBudUserOrderByWithAggregationInput = {
    userId?: SortOrder
    budgetId?: SortOrder
    role?: SortOrder
    ability?: SortOrder
    category?: SortOrder
    _count?: BudgetBudUserCountOrderByAggregateInput
    _max?: BudgetBudUserMaxOrderByAggregateInput
    _min?: BudgetBudUserMinOrderByAggregateInput
  }

  export type BudgetBudUserScalarWhereWithAggregatesInput = {
    AND?: BudgetBudUserScalarWhereWithAggregatesInput | BudgetBudUserScalarWhereWithAggregatesInput[]
    OR?: BudgetBudUserScalarWhereWithAggregatesInput[]
    NOT?: BudgetBudUserScalarWhereWithAggregatesInput | BudgetBudUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"BudgetBudUser"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetBudUser"> | string
    role?: StringWithAggregatesFilter<"BudgetBudUser"> | string
    ability?: StringWithAggregatesFilter<"BudgetBudUser"> | string
    category?: StringWithAggregatesFilter<"BudgetBudUser"> | string
  }

  export type BudEventWhereInput = {
    AND?: BudEventWhereInput | BudEventWhereInput[]
    OR?: BudEventWhereInput[]
    NOT?: BudEventWhereInput | BudEventWhereInput[]
    id?: StringFilter<"BudEvent"> | string
    type?: StringFilter<"BudEvent"> | string
    description?: StringFilter<"BudEvent"> | string
    categoryList?: StringNullableListFilter<"BudEvent">
    metadata?: JsonFilter<"BudEvent">
    budUserId?: StringFilter<"BudEvent"> | string
    createdAt?: DateTimeFilter<"BudEvent"> | Date | string
    budUser?: XOR<BudUserRelationFilter, BudUserWhereInput>
  }

  export type BudEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    categoryList?: SortOrder
    metadata?: SortOrder
    budUserId?: SortOrder
    createdAt?: SortOrder
    budUser?: BudUserOrderByWithRelationInput
  }

  export type BudEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudEventWhereInput | BudEventWhereInput[]
    OR?: BudEventWhereInput[]
    NOT?: BudEventWhereInput | BudEventWhereInput[]
    type?: StringFilter<"BudEvent"> | string
    description?: StringFilter<"BudEvent"> | string
    categoryList?: StringNullableListFilter<"BudEvent">
    metadata?: JsonFilter<"BudEvent">
    budUserId?: StringFilter<"BudEvent"> | string
    createdAt?: DateTimeFilter<"BudEvent"> | Date | string
    budUser?: XOR<BudUserRelationFilter, BudUserWhereInput>
  }, "id">

  export type BudEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    categoryList?: SortOrder
    metadata?: SortOrder
    budUserId?: SortOrder
    createdAt?: SortOrder
    _count?: BudEventCountOrderByAggregateInput
    _max?: BudEventMaxOrderByAggregateInput
    _min?: BudEventMinOrderByAggregateInput
  }

  export type BudEventScalarWhereWithAggregatesInput = {
    AND?: BudEventScalarWhereWithAggregatesInput | BudEventScalarWhereWithAggregatesInput[]
    OR?: BudEventScalarWhereWithAggregatesInput[]
    NOT?: BudEventScalarWhereWithAggregatesInput | BudEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudEvent"> | string
    type?: StringWithAggregatesFilter<"BudEvent"> | string
    description?: StringWithAggregatesFilter<"BudEvent"> | string
    categoryList?: StringNullableListFilter<"BudEvent">
    metadata?: JsonWithAggregatesFilter<"BudEvent">
    budUserId?: StringWithAggregatesFilter<"BudEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BudEvent"> | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentType: AppointmentTypeCreateNestedOneWithoutAppointmentListInput
    patient: PatientCreateNestedOneWithoutAppointmentListInput
    location: LocationCreateNestedOneWithoutAppointmentListInput
    provider: ProviderCreateNestedOneWithoutAppointmentListInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentType?: AppointmentTypeUpdateOneRequiredWithoutAppointmentListNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentListNestedInput
    location?: LocationUpdateOneRequiredWithoutAppointmentListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentListNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentTypeCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutAppointmentTypeInput
  }

  export type AppointmentTypeUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutAppointmentTypeInput
  }

  export type AppointmentTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutAppointmentTypeNestedInput
  }

  export type AppointmentTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutAppointmentTypeNestedInput
  }

  export type AppointmentTypeCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutLocationInput
    encounterList?: EncounterCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutLocationNestedInput
    encounterList?: EncounterUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutPatientInput
    encounterList?: EncounterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutPatientNestedInput
    encounterList?: EncounterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderCreateInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutProviderInput
    encounterList?: EncounterCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutProviderNestedInput
    encounterList?: EncounterUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutFormInput
    dield?: FieldCreateNestedOneWithoutFormListInput
    encounterList?: EncounterCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutFormNestedInput
    dield?: FieldUpdateOneWithoutFormListNestedInput
    encounterList?: EncounterUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUncheckedUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormEncounterCreateInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormEncounterListInput
    encounter: EncounterCreateNestedOneWithoutFormEncounterListInput
  }

  export type FormEncounterUncheckedCreateInput = {
    id?: string
    uuid: string
    formId: string
    encounterId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormEncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormEncounterListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutFormEncounterListNestedInput
  }

  export type FormEncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterCreateManyInput = {
    id?: string
    uuid: string
    formId: string
    encounterId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormEncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceCreateInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormResourceListInput
    resource: ResourceCreateNestedOneWithoutFormResourceListInput
  }

  export type FormResourceUncheckedCreateInput = {
    id?: string
    uuid: string
    formId: string
    resourceId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormResourceListNestedInput
    resource?: ResourceUpdateOneRequiredWithoutFormResourceListNestedInput
  }

  export type FormResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceCreateManyInput = {
    id?: string
    uuid: string
    formId: string
    resourceId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    uuid: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormSubmissionListInput
    encounter: EncounterCreateNestedOneWithoutFormSubmissionListInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    uuid: string
    formId: string
    encounterId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormSubmissionListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutFormSubmissionListNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    uuid: string
    formId: string
    encounterId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutFieldListInput
    formList?: FormCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formList?: FormUncheckedCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutFieldListNestedInput
    formList?: FormUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formList?: FormUncheckedUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerCreateInput = {
    id?: string
    uuid: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formSubmission: FormSubmissionCreateNestedOneWithoutFieldAnswerListInput
    field: FieldCreateNestedOneWithoutFieldAnswerListInput
  }

  export type FieldAnswerUncheckedCreateInput = {
    id?: string
    uuid: string
    formSubmissionId: string
    fieldId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formSubmission?: FormSubmissionUpdateOneRequiredWithoutFieldAnswerListNestedInput
    field?: FieldUpdateOneRequiredWithoutFieldAnswerListNestedInput
  }

  export type FieldAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formSubmissionId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerCreateManyInput = {
    id?: string
    uuid: string
    formSubmissionId: string
    fieldId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formSubmissionId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    field: FieldCreateNestedOneWithoutFieldOptionListInput
  }

  export type FieldOptionUncheckedCreateInput = {
    id?: string
    uuid: string
    fieldId: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldOptionListNestedInput
  }

  export type FieldOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionCreateManyInput = {
    id?: string
    uuid: string
    fieldId: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterTypeCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterCreateNestedManyWithoutEncounterTypeInput
  }

  export type EncounterTypeUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterUncheckedCreateNestedManyWithoutEncounterTypeInput
  }

  export type EncounterTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUpdateManyWithoutEncounterTypeNestedInput
  }

  export type EncounterTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUncheckedUpdateManyWithoutEncounterTypeNestedInput
  }

  export type EncounterTypeCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsCreateInput = {
    id?: string
    uuid: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutObsListInput
    encounter: EncounterCreateNestedOneWithoutObsListInput
  }

  export type ObsUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutObsListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutObsListNestedInput
  }

  export type ObsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderFrequencyCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderCreateNestedManyWithoutOrderFrequencyInput
  }

  export type OrderFrequencyUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderUncheckedCreateNestedManyWithoutOrderFrequencyInput
  }

  export type OrderFrequencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUpdateManyWithoutOrderFrequencyNestedInput
  }

  export type OrderFrequencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUncheckedUpdateManyWithoutOrderFrequencyNestedInput
  }

  export type OrderFrequencyCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderFrequencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderFrequencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRouteCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderCreateNestedManyWithoutOrderRouteInput
  }

  export type OrderRouteUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderUncheckedCreateNestedManyWithoutOrderRouteInput
  }

  export type OrderRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUpdateManyWithoutOrderRouteNestedInput
  }

  export type OrderRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUncheckedUpdateManyWithoutOrderRouteNestedInput
  }

  export type OrderRouteCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTypeCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderCreateNestedManyWithoutOrderTypeInput
  }

  export type OrderTypeUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderUncheckedCreateNestedManyWithoutOrderTypeInput
  }

  export type OrderTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUpdateManyWithoutOrderTypeNestedInput
  }

  export type OrderTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUncheckedUpdateManyWithoutOrderTypeNestedInput
  }

  export type OrderTypeCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUnitCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderCreateNestedManyWithoutOrderUnitInput
  }

  export type OrderUnitUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderList?: OrderUncheckedCreateNestedManyWithoutOrderUnitInput
  }

  export type OrderUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUpdateManyWithoutOrderUnitNestedInput
  }

  export type OrderUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderList?: OrderUncheckedUpdateManyWithoutOrderUnitNestedInput
  }

  export type OrderUnitCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
  }

  export type ConceptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptAnswerCreateInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutMetaListInput
    answerConcept: ConceptCreateNestedOneWithoutAnswerListInput
  }

  export type ConceptAnswerUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    answerConceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutMetaListNestedInput
    answerConcept?: ConceptUpdateOneRequiredWithoutAnswerListNestedInput
  }

  export type ConceptAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    answerConceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptAnswerCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    answerConceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    answerConceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptClassCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptCreateNestedManyWithoutConceptClassInput
  }

  export type ConceptClassUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptUncheckedCreateNestedManyWithoutConceptClassInput
  }

  export type ConceptClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUpdateManyWithoutConceptClassNestedInput
  }

  export type ConceptClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUncheckedUpdateManyWithoutConceptClassNestedInput
  }

  export type ConceptClassCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptDatatypeCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptCreateNestedManyWithoutConceptDatatypeInput
  }

  export type ConceptDatatypeUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptUncheckedCreateNestedManyWithoutConceptDatatypeInput
  }

  export type ConceptDatatypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUpdateManyWithoutConceptDatatypeNestedInput
  }

  export type ConceptDatatypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUncheckedUpdateManyWithoutConceptDatatypeNestedInput
  }

  export type ConceptDatatypeCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptDatatypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptDatatypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptMapCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptCreateNestedManyWithoutConceptMapInput
  }

  export type ConceptMapUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptUncheckedCreateNestedManyWithoutConceptMapInput
  }

  export type ConceptMapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUpdateManyWithoutConceptMapNestedInput
  }

  export type ConceptMapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUncheckedUpdateManyWithoutConceptMapNestedInput
  }

  export type ConceptMapCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptMapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptMapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameCreateInput = {
    id?: string
    uuid: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutConceptNameListInput
  }

  export type ConceptNameUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutConceptNameListNestedInput
  }

  export type ConceptNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericCreateInput = {
    id?: string
    uuid: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutConceptNumericListInput
  }

  export type ConceptNumericUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNumericUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutConceptNumericListNestedInput
  }

  export type ConceptNumericUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNumericUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutConceptProposalListInput
  }

  export type ConceptProposalUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutConceptProposalListNestedInput
  }

  export type ConceptProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSetCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptCreateNestedManyWithoutConceptSetInput
  }

  export type ConceptSetUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptUncheckedCreateNestedManyWithoutConceptSetInput
  }

  export type ConceptSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUpdateManyWithoutConceptSetNestedInput
  }

  export type ConceptSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUncheckedUpdateManyWithoutConceptSetNestedInput
  }

  export type ConceptSetCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSourceCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptCreateNestedManyWithoutConceptSourceInput
  }

  export type ConceptSourceUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptList?: ConceptUncheckedCreateNestedManyWithoutConceptSourceInput
  }

  export type ConceptSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUpdateManyWithoutConceptSourceNestedInput
  }

  export type ConceptSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptList?: ConceptUncheckedUpdateManyWithoutConceptSourceNestedInput
  }

  export type ConceptSourceCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordCreateInput = {
    id?: string
    uuid: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutConceptWordListInput
  }

  export type ConceptWordUncheckedCreateInput = {
    id?: string
    uuid: string
    conceptId: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptWordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutConceptWordListNestedInput
  }

  export type ConceptWordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordCreateManyInput = {
    id?: string
    uuid: string
    conceptId: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptWordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formResourceList?: FormResourceCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formResourceList?: FormResourceUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formResourceList?: FormResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    author: BlogPostAuthorCreateNestedOneWithoutBlogPostListInput
    spaceTimeCoordinates: SpaceTimeCoordinatesCreateNestedOneWithoutBlogPostInput
    tagArrowList?: BlogPostTagArrowCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    authorId: string
    spaceTimeCoordinatesId: string
    tagArrowList?: BlogPostTagArrowUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    author?: BlogPostAuthorUpdateOneRequiredWithoutBlogPostListNestedInput
    spaceTimeCoordinates?: SpaceTimeCoordinatesUpdateOneRequiredWithoutBlogPostNestedInput
    tagArrowList?: BlogPostTagArrowUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    spaceTimeCoordinatesId?: StringFieldUpdateOperationsInput | string
    tagArrowList?: BlogPostTagArrowUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    authorId: string
    spaceTimeCoordinatesId: string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    spaceTimeCoordinatesId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagCreateInput = {
    id?: string
    name: string
    descriptor?: string | null
    postArrowList?: BlogPostTagArrowCreateNestedManyWithoutTagInput
  }

  export type BlogPostTagUncheckedCreateInput = {
    id?: string
    name: string
    descriptor?: string | null
    postArrowList?: BlogPostTagArrowUncheckedCreateNestedManyWithoutTagInput
  }

  export type BlogPostTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    postArrowList?: BlogPostTagArrowUpdateManyWithoutTagNestedInput
  }

  export type BlogPostTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
    postArrowList?: BlogPostTagArrowUncheckedUpdateManyWithoutTagNestedInput
  }

  export type BlogPostTagCreateManyInput = {
    id?: string
    name: string
    descriptor?: string | null
  }

  export type BlogPostTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostTagArrowCreateInput = {
    id?: string
    post: BlogPostCreateNestedOneWithoutTagArrowListInput
    tag: BlogPostTagCreateNestedOneWithoutPostArrowListInput
  }

  export type BlogPostTagArrowUncheckedCreateInput = {
    id?: string
    postId: string
    tagId: string
  }

  export type BlogPostTagArrowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: BlogPostUpdateOneRequiredWithoutTagArrowListNestedInput
    tag?: BlogPostTagUpdateOneRequiredWithoutPostArrowListNestedInput
  }

  export type BlogPostTagArrowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowCreateManyInput = {
    id?: string
    postId: string
    tagId: string
  }

  export type BlogPostTagArrowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostAuthorCreateInput = {
    id?: string
    name: string
    blogPostList?: BlogPostCreateNestedManyWithoutAuthorInput
  }

  export type BlogPostAuthorUncheckedCreateInput = {
    id?: string
    name: string
    blogPostList?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type BlogPostAuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    blogPostList?: BlogPostUpdateManyWithoutAuthorNestedInput
  }

  export type BlogPostAuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    blogPostList?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BlogPostAuthorCreateManyInput = {
    id?: string
    name: string
  }

  export type BlogPostAuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostAuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceTimeCoordinatesCreateInput = {
    id?: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime?: number | null
    stopTime: number
    timezone: string
    blogPostId: string
    BlogPost?: BlogPostCreateNestedOneWithoutSpaceTimeCoordinatesInput
  }

  export type SpaceTimeCoordinatesUncheckedCreateInput = {
    id?: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime?: number | null
    stopTime: number
    timezone: string
    blogPostId: string
    BlogPost?: BlogPostUncheckedCreateNestedOneWithoutSpaceTimeCoordinatesInput
  }

  export type SpaceTimeCoordinatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
    BlogPost?: BlogPostUpdateOneWithoutSpaceTimeCoordinatesNestedInput
  }

  export type SpaceTimeCoordinatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
    BlogPost?: BlogPostUncheckedUpdateOneWithoutSpaceTimeCoordinatesNestedInput
  }

  export type SpaceTimeCoordinatesCreateManyInput = {
    id?: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime?: number | null
    stopTime: number
    timezone: string
    blogPostId: string
  }

  export type SpaceTimeCoordinatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceTimeCoordinatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetEntryCreateInput = {
    id?: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutEntryListInput
    budget: BudgetCreateNestedOneWithoutEntryListInput
  }

  export type BudgetEntryUncheckedCreateInput = {
    id?: string
    serviceId: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetId: string
  }

  export type BudgetEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutEntryListNestedInput
    budget?: BudgetUpdateOneRequiredWithoutEntryListNestedInput
  }

  export type BudgetEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetEntryCreateManyInput = {
    id?: string
    serviceId: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetId: string
  }

  export type BudgetEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    description: string
    category: string
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entryList?: BudgetEntryCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    description: string
    category: string
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entryList?: BudgetEntryUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entryList?: BudgetEntryUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entryList?: BudgetEntryUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    description: string
    category: string
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryCreateNestedManyWithoutBudgetInput
    report?: ReportCreateNestedOneWithoutBudgetInput
    userList?: BudgetBudUserCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryUncheckedCreateNestedManyWithoutBudgetInput
    report?: ReportUncheckedCreateNestedOneWithoutBudgetInput
    userList?: BudgetBudUserUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUpdateManyWithoutBudgetNestedInput
    report?: ReportUpdateOneWithoutBudgetNestedInput
    userList?: BudgetBudUserUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUncheckedUpdateManyWithoutBudgetNestedInput
    report?: ReportUncheckedUpdateOneWithoutBudgetNestedInput
    userList?: BudgetBudUserUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    id?: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    budgetId: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    budgetId: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudUserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetList?: BudgetBudUserCreateNestedManyWithoutUserInput
    eventList?: BudEventCreateNestedManyWithoutBudUserInput
  }

  export type BudUserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetList?: BudgetBudUserUncheckedCreateNestedManyWithoutUserInput
    eventList?: BudEventUncheckedCreateNestedManyWithoutBudUserInput
  }

  export type BudUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetList?: BudgetBudUserUpdateManyWithoutUserNestedInput
    eventList?: BudEventUpdateManyWithoutBudUserNestedInput
  }

  export type BudUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetList?: BudgetBudUserUncheckedUpdateManyWithoutUserNestedInput
    eventList?: BudEventUncheckedUpdateManyWithoutBudUserNestedInput
  }

  export type BudUserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetBudUserCreateInput = {
    role: string
    ability: string
    category: string
    user: BudUserCreateNestedOneWithoutBudgetListInput
    budget: BudgetCreateNestedOneWithoutUserListInput
  }

  export type BudgetBudUserUncheckedCreateInput = {
    userId: string
    budgetId: string
    role: string
    ability: string
    category: string
  }

  export type BudgetBudUserUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    user?: BudUserUpdateOneRequiredWithoutBudgetListNestedInput
    budget?: BudgetUpdateOneRequiredWithoutUserListNestedInput
  }

  export type BudgetBudUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetBudUserCreateManyInput = {
    userId: string
    budgetId: string
    role: string
    ability: string
    category: string
  }

  export type BudgetBudUserUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetBudUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudEventCreateInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    budUser: BudUserCreateNestedOneWithoutEventListInput
  }

  export type BudEventUncheckedCreateInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    budUserId: string
    createdAt?: Date | string
  }

  export type BudEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budUser?: BudUserUpdateOneRequiredWithoutEventListNestedInput
  }

  export type BudEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    budUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudEventCreateManyInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    budUserId: string
    createdAt?: Date | string
  }

  export type BudEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    budUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AppointmentTypeRelationFilter = {
    is?: AppointmentTypeWhereInput
    isNot?: AppointmentTypeWhereInput
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type ProviderRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type AppointmentPatientIdLocationIdProviderIdCompoundUniqueInput = {
    patientId: string
    locationId: string
    providerId: string
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type AppointmentTypeAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AppointmentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type AppointmentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type AppointmentTypeSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    givenName?: SortOrder
    middleName?: SortOrder
    familyName?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    dead?: SortOrder
    deathDate?: SortOrder
    causeOfDeath?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    givenName?: SortOrder
    middleName?: SortOrder
    familyName?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    dead?: SortOrder
    deathDate?: SortOrder
    causeOfDeath?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    givenName?: SortOrder
    middleName?: SortOrder
    familyName?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    dead?: SortOrder
    deathDate?: SortOrder
    causeOfDeath?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FormEncounterListRelationFilter = {
    every?: FormEncounterWhereInput
    some?: FormEncounterWhereInput
    none?: FormEncounterWhereInput
  }

  export type FormResourceListRelationFilter = {
    every?: FormResourceWhereInput
    some?: FormResourceWhereInput
    none?: FormResourceWhereInput
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type FieldNullableRelationFilter = {
    is?: FieldWhereInput | null
    isNot?: FieldWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FormEncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    retired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    fieldId?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    retired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    fieldId?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    retired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    fieldId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FormRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type EncounterRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type FormEncounterCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormEncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormEncounterMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ResourceRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type FormResourceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    resourceId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    resourceId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormResourceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    resourceId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldAnswerListRelationFilter = {
    every?: FieldAnswerWhereInput
    some?: FieldAnswerWhereInput
    none?: FieldAnswerWhereInput
  }

  export type FieldAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    submissionDate?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    submissionDate?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formId?: SortOrder
    encounterId?: SortOrder
    submissionDate?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptRelationFilter = {
    is?: ConceptWhereInput
    isNot?: ConceptWhereInput
  }

  export type FormListRelationFilter = {
    every?: FormWhereInput
    some?: FormWhereInput
    none?: FormWhereInput
  }

  export type FieldOptionListRelationFilter = {
    every?: FieldOptionWhereInput
    some?: FieldOptionWhereInput
    none?: FieldOptionWhereInput
  }

  export type FormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fieldType?: SortOrder
    conceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fieldType?: SortOrder
    conceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fieldType?: SortOrder
    conceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FormSubmissionRelationFilter = {
    is?: FormSubmissionWhereInput
    isNot?: FormSubmissionWhereInput
  }

  export type FieldRelationFilter = {
    is?: FieldWhereInput
    isNot?: FieldWhereInput
  }

  export type FieldAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formSubmissionId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formSubmissionId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    formSubmissionId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldOptionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fieldId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fieldId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type FieldOptionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fieldId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterTypeRelationFilter = {
    is?: EncounterTypeWhereInput
    isNot?: EncounterTypeWhereInput
  }

  export type ObsListRelationFilter = {
    every?: ObsWhereInput
    some?: ObsWhereInput
    none?: ObsWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ObsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    encounterTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    formId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    encounterTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    formId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    encounterTypeId?: SortOrder
    patientId?: SortOrder
    locationId?: SortOrder
    formId?: SortOrder
    providerId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    voided?: SortOrder
    voidedBy?: SortOrder
    dateVoided?: SortOrder
    voidReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterTypeCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type EncounterTypeMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ObsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    obsDatetime?: SortOrder
    valueDatetime?: SortOrder
    valueNumeric?: SortOrder
    valueText?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ObsAvgOrderByAggregateInput = {
    valueNumeric?: SortOrder
  }

  export type ObsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    obsDatetime?: SortOrder
    valueDatetime?: SortOrder
    valueNumeric?: SortOrder
    valueText?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ObsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    obsDatetime?: SortOrder
    valueDatetime?: SortOrder
    valueNumeric?: SortOrder
    valueText?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ObsSumOrderByAggregateInput = {
    valueNumeric?: SortOrder
  }

  export type OrderFrequencyNullableRelationFilter = {
    is?: OrderFrequencyWhereInput | null
    isNot?: OrderFrequencyWhereInput | null
  }

  export type OrderRouteNullableRelationFilter = {
    is?: OrderRouteWhereInput | null
    isNot?: OrderRouteWhereInput | null
  }

  export type OrderTypeNullableRelationFilter = {
    is?: OrderTypeWhereInput | null
    isNot?: OrderTypeWhereInput | null
  }

  export type OrderUnitNullableRelationFilter = {
    is?: OrderUnitWhereInput | null
    isNot?: OrderUnitWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    orderDatetime?: SortOrder
    instructions?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    asNeeded?: SortOrder
    prn?: SortOrder
    quantity?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderFrequencyId?: SortOrder
    orderRouteId?: SortOrder
    orderTypeId?: SortOrder
    orderUnitId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    orderDatetime?: SortOrder
    instructions?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    asNeeded?: SortOrder
    prn?: SortOrder
    quantity?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderFrequencyId?: SortOrder
    orderRouteId?: SortOrder
    orderTypeId?: SortOrder
    orderUnitId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    encounterId?: SortOrder
    orderDatetime?: SortOrder
    instructions?: SortOrder
    dosage?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    asNeeded?: SortOrder
    prn?: SortOrder
    quantity?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    orderFrequencyId?: SortOrder
    orderRouteId?: SortOrder
    orderTypeId?: SortOrder
    orderUnitId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderFrequencyCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderFrequencyMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderFrequencyMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderRouteCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderRouteMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderTypeCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderTypeMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderUnitCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type OrderUnitMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptAnswerListRelationFilter = {
    every?: ConceptAnswerWhereInput
    some?: ConceptAnswerWhereInput
    none?: ConceptAnswerWhereInput
  }

  export type FieldListRelationFilter = {
    every?: FieldWhereInput
    some?: FieldWhereInput
    none?: FieldWhereInput
  }

  export type ConceptClassNullableRelationFilter = {
    is?: ConceptClassWhereInput | null
    isNot?: ConceptClassWhereInput | null
  }

  export type ConceptDatatypeNullableRelationFilter = {
    is?: ConceptDatatypeWhereInput | null
    isNot?: ConceptDatatypeWhereInput | null
  }

  export type ConceptMapNullableRelationFilter = {
    is?: ConceptMapWhereInput | null
    isNot?: ConceptMapWhereInput | null
  }

  export type ConceptNameListRelationFilter = {
    every?: ConceptNameWhereInput
    some?: ConceptNameWhereInput
    none?: ConceptNameWhereInput
  }

  export type ConceptNumericListRelationFilter = {
    every?: ConceptNumericWhereInput
    some?: ConceptNumericWhereInput
    none?: ConceptNumericWhereInput
  }

  export type ConceptProposalListRelationFilter = {
    every?: ConceptProposalWhereInput
    some?: ConceptProposalWhereInput
    none?: ConceptProposalWhereInput
  }

  export type ConceptSetNullableRelationFilter = {
    is?: ConceptSetWhereInput | null
    isNot?: ConceptSetWhereInput | null
  }

  export type ConceptSourceNullableRelationFilter = {
    is?: ConceptSourceWhereInput | null
    isNot?: ConceptSourceWhereInput | null
  }

  export type ConceptWordListRelationFilter = {
    every?: ConceptWordWhereInput
    some?: ConceptWordWhereInput
    none?: ConceptWordWhereInput
  }

  export type ConceptAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptNumericOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptWordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    class?: SortOrder
    isRetired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptClassId?: SortOrder
    conceptDatatypeId?: SortOrder
    conceptMapId?: SortOrder
    conceptSetId?: SortOrder
    conceptSourceId?: SortOrder
  }

  export type ConceptMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    class?: SortOrder
    isRetired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptClassId?: SortOrder
    conceptDatatypeId?: SortOrder
    conceptMapId?: SortOrder
    conceptSetId?: SortOrder
    conceptSourceId?: SortOrder
  }

  export type ConceptMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    class?: SortOrder
    isRetired?: SortOrder
    retiredBy?: SortOrder
    dateRetired?: SortOrder
    retiredReason?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
    conceptClassId?: SortOrder
    conceptDatatypeId?: SortOrder
    conceptMapId?: SortOrder
    conceptSetId?: SortOrder
    conceptSourceId?: SortOrder
  }

  export type ConceptAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    answerConceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    answerConceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    answerConceptId?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptListRelationFilter = {
    every?: ConceptWhereInput
    some?: ConceptWhereInput
    none?: ConceptWhereInput
  }

  export type ConceptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptClassCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptClassMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptClassMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptDatatypeCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptDatatypeMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptDatatypeMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptMapCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptMapMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptMapMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNameCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNameMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNameMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNumericCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNumericAvgOrderByAggregateInput = {
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
  }

  export type ConceptNumericMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNumericMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
    units?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptNumericSumOrderByAggregateInput = {
    hiAbsolute?: SortOrder
    hiCritical?: SortOrder
    hiNormal?: SortOrder
    lowAbsolute?: SortOrder
    lowCritical?: SortOrder
    lowNormal?: SortOrder
  }

  export type ConceptProposalCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptProposalMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSetCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSetMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSetMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSourceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptSourceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptWordCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    word?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptWordMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    word?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ConceptWordMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    conceptId?: SortOrder
    word?: SortOrder
    locale?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creator?: SortOrder
    dateCreated?: SortOrder
    lastChangedBy?: SortOrder
    lastChangedDate?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BlogPostAuthorRelationFilter = {
    is?: BlogPostAuthorWhereInput
    isNot?: BlogPostAuthorWhereInput
  }

  export type SpaceTimeCoordinatesRelationFilter = {
    is?: SpaceTimeCoordinatesWhereInput
    isNot?: SpaceTimeCoordinatesWhereInput
  }

  export type BlogPostTagArrowListRelationFilter = {
    every?: BlogPostTagArrowWhereInput
    some?: BlogPostTagArrowWhereInput
    none?: BlogPostTagArrowWhereInput
  }

  export type BlogPostTagArrowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    context?: SortOrder
    authorId?: SortOrder
    spaceTimeCoordinatesId?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    spaceTimeCoordinatesId?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    spaceTimeCoordinatesId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BlogPostTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptor?: SortOrder
  }

  export type BlogPostTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptor?: SortOrder
  }

  export type BlogPostTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptor?: SortOrder
  }

  export type BlogPostRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type BlogPostTagRelationFilter = {
    is?: BlogPostTagWhereInput
    isNot?: BlogPostTagWhereInput
  }

  export type BlogPostTagArrowPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type BlogPostTagArrowCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogPostTagArrowMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogPostTagArrowMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BlogPostAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BlogPostAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type BlogPostNullableRelationFilter = {
    is?: BlogPostWhereInput | null
    isNot?: BlogPostWhereInput | null
  }

  export type SpaceTimeCoordinatesCountOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    stopTime?: SortOrder
    timezone?: SortOrder
    blogPostId?: SortOrder
  }

  export type SpaceTimeCoordinatesAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    stopTime?: SortOrder
  }

  export type SpaceTimeCoordinatesMaxOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    stopTime?: SortOrder
    timezone?: SortOrder
    blogPostId?: SortOrder
  }

  export type SpaceTimeCoordinatesMinOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    stopTime?: SortOrder
    timezone?: SortOrder
    blogPostId?: SortOrder
  }

  export type SpaceTimeCoordinatesSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    stopTime?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type BudgetRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetEntryCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetEntryAvgOrderByAggregateInput = {
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
  }

  export type BudgetEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetEntryMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetEntrySumOrderByAggregateInput = {
    cost?: SortOrder
    discount?: SortOrder
    promotion?: SortOrder
    subtotal?: SortOrder
    percentChange?: SortOrder
  }

  export type BudgetEntryListRelationFilter = {
    every?: BudgetEntryWhereInput
    some?: BudgetEntryWhereInput
    none?: BudgetEntryWhereInput
  }

  export type BudgetEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportNullableRelationFilter = {
    is?: ReportWhereInput | null
    isNot?: ReportWhereInput | null
  }

  export type BudgetBudUserListRelationFilter = {
    every?: BudgetBudUserWhereInput
    some?: BudgetBudUserWhereInput
    none?: BudgetBudUserWhereInput
  }

  export type BudgetBudUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: SortOrder
    reportId?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    fiscalYear?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: SortOrder
    reportId?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: SortOrder
    reportId?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    fiscalYear?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    totalCost?: SortOrder
    totalDiscount?: SortOrder
    totalPromotion?: SortOrder
    totalSubtotal?: SortOrder
  }

  export type BudEventListRelationFilter = {
    every?: BudEventWhereInput
    some?: BudEventWhereInput
    none?: BudEventWhereInput
  }

  export type BudEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudUserRelationFilter = {
    is?: BudUserWhereInput
    isNot?: BudUserWhereInput
  }

  export type BudgetBudUserUserIdBudgetIdCompoundUniqueInput = {
    userId: string
    budgetId: string
  }

  export type BudgetBudUserCountOrderByAggregateInput = {
    userId?: SortOrder
    budgetId?: SortOrder
    role?: SortOrder
    ability?: SortOrder
    category?: SortOrder
  }

  export type BudgetBudUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    budgetId?: SortOrder
    role?: SortOrder
    ability?: SortOrder
    category?: SortOrder
  }

  export type BudgetBudUserMinOrderByAggregateInput = {
    userId?: SortOrder
    budgetId?: SortOrder
    role?: SortOrder
    ability?: SortOrder
    category?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BudEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    categoryList?: SortOrder
    metadata?: SortOrder
    budUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    budUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    budUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentTypeCreateNestedOneWithoutAppointmentListInput = {
    create?: XOR<AppointmentTypeCreateWithoutAppointmentListInput, AppointmentTypeUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: AppointmentTypeCreateOrConnectWithoutAppointmentListInput
    connect?: AppointmentTypeWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentListInput = {
    create?: XOR<PatientCreateWithoutAppointmentListInput, PatientUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentListInput
    connect?: PatientWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutAppointmentListInput = {
    create?: XOR<LocationCreateWithoutAppointmentListInput, LocationUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAppointmentListInput
    connect?: LocationWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutAppointmentListInput = {
    create?: XOR<ProviderCreateWithoutAppointmentListInput, ProviderUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAppointmentListInput
    connect?: ProviderWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AppointmentTypeUpdateOneRequiredWithoutAppointmentListNestedInput = {
    create?: XOR<AppointmentTypeCreateWithoutAppointmentListInput, AppointmentTypeUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: AppointmentTypeCreateOrConnectWithoutAppointmentListInput
    upsert?: AppointmentTypeUpsertWithoutAppointmentListInput
    connect?: AppointmentTypeWhereUniqueInput
    update?: XOR<XOR<AppointmentTypeUpdateToOneWithWhereWithoutAppointmentListInput, AppointmentTypeUpdateWithoutAppointmentListInput>, AppointmentTypeUncheckedUpdateWithoutAppointmentListInput>
  }

  export type PatientUpdateOneRequiredWithoutAppointmentListNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentListInput, PatientUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentListInput
    upsert?: PatientUpsertWithoutAppointmentListInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentListInput, PatientUpdateWithoutAppointmentListInput>, PatientUncheckedUpdateWithoutAppointmentListInput>
  }

  export type LocationUpdateOneRequiredWithoutAppointmentListNestedInput = {
    create?: XOR<LocationCreateWithoutAppointmentListInput, LocationUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAppointmentListInput
    upsert?: LocationUpsertWithoutAppointmentListInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAppointmentListInput, LocationUpdateWithoutAppointmentListInput>, LocationUncheckedUpdateWithoutAppointmentListInput>
  }

  export type ProviderUpdateOneRequiredWithoutAppointmentListNestedInput = {
    create?: XOR<ProviderCreateWithoutAppointmentListInput, ProviderUncheckedCreateWithoutAppointmentListInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAppointmentListInput
    upsert?: ProviderUpsertWithoutAppointmentListInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutAppointmentListInput, ProviderUpdateWithoutAppointmentListInput>, ProviderUncheckedUpdateWithoutAppointmentListInput>
  }

  export type AppointmentCreateNestedManyWithoutAppointmentTypeInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput> | AppointmentCreateWithoutAppointmentTypeInput[] | AppointmentUncheckedCreateWithoutAppointmentTypeInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentTypeInput | AppointmentCreateOrConnectWithoutAppointmentTypeInput[]
    createMany?: AppointmentCreateManyAppointmentTypeInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutAppointmentTypeInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput> | AppointmentCreateWithoutAppointmentTypeInput[] | AppointmentUncheckedCreateWithoutAppointmentTypeInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentTypeInput | AppointmentCreateOrConnectWithoutAppointmentTypeInput[]
    createMany?: AppointmentCreateManyAppointmentTypeInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUpdateManyWithoutAppointmentTypeNestedInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput> | AppointmentCreateWithoutAppointmentTypeInput[] | AppointmentUncheckedCreateWithoutAppointmentTypeInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentTypeInput | AppointmentCreateOrConnectWithoutAppointmentTypeInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAppointmentTypeInput | AppointmentUpsertWithWhereUniqueWithoutAppointmentTypeInput[]
    createMany?: AppointmentCreateManyAppointmentTypeInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAppointmentTypeInput | AppointmentUpdateWithWhereUniqueWithoutAppointmentTypeInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAppointmentTypeInput | AppointmentUpdateManyWithWhereWithoutAppointmentTypeInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutAppointmentTypeNestedInput = {
    create?: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput> | AppointmentCreateWithoutAppointmentTypeInput[] | AppointmentUncheckedCreateWithoutAppointmentTypeInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAppointmentTypeInput | AppointmentCreateOrConnectWithoutAppointmentTypeInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAppointmentTypeInput | AppointmentUpsertWithWhereUniqueWithoutAppointmentTypeInput[]
    createMany?: AppointmentCreateManyAppointmentTypeInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAppointmentTypeInput | AppointmentUpdateWithWhereUniqueWithoutAppointmentTypeInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAppointmentTypeInput | AppointmentUpdateManyWithWhereWithoutAppointmentTypeInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutLocationInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutLocationInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutLocationInput | AppointmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutLocationInput | AppointmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutLocationInput | AppointmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocationInput | EncounterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocationInput | EncounterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocationInput | EncounterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutLocationInput | AppointmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutLocationInput | AppointmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutLocationInput | AppointmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocationInput | EncounterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocationInput | EncounterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocationInput | EncounterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutProviderInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutProviderNestedInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutProviderInput | EncounterUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutProviderInput | EncounterUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutProviderInput | EncounterUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput> | EncounterCreateWithoutProviderInput[] | EncounterUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutProviderInput | EncounterCreateOrConnectWithoutProviderInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutProviderInput | EncounterUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: EncounterCreateManyProviderInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutProviderInput | EncounterUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutProviderInput | EncounterUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type FormEncounterCreateNestedManyWithoutFormInput = {
    create?: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput> | FormEncounterCreateWithoutFormInput[] | FormEncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutFormInput | FormEncounterCreateOrConnectWithoutFormInput[]
    createMany?: FormEncounterCreateManyFormInputEnvelope
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
  }

  export type FormResourceCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput> | FormResourceCreateWithoutFormInput[] | FormResourceUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutFormInput | FormResourceCreateOrConnectWithoutFormInput[]
    createMany?: FormResourceCreateManyFormInputEnvelope
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FieldCreateNestedOneWithoutFormListInput = {
    create?: XOR<FieldCreateWithoutFormListInput, FieldUncheckedCreateWithoutFormListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFormListInput
    connect?: FieldWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutFormInput = {
    create?: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput> | EncounterCreateWithoutFormInput[] | EncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutFormInput | EncounterCreateOrConnectWithoutFormInput[]
    createMany?: EncounterCreateManyFormInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type FormEncounterUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput> | FormEncounterCreateWithoutFormInput[] | FormEncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutFormInput | FormEncounterCreateOrConnectWithoutFormInput[]
    createMany?: FormEncounterCreateManyFormInputEnvelope
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
  }

  export type FormResourceUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput> | FormResourceCreateWithoutFormInput[] | FormResourceUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutFormInput | FormResourceCreateOrConnectWithoutFormInput[]
    createMany?: FormResourceCreateManyFormInputEnvelope
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput> | EncounterCreateWithoutFormInput[] | EncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutFormInput | EncounterCreateOrConnectWithoutFormInput[]
    createMany?: EncounterCreateManyFormInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type FormEncounterUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput> | FormEncounterCreateWithoutFormInput[] | FormEncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutFormInput | FormEncounterCreateOrConnectWithoutFormInput[]
    upsert?: FormEncounterUpsertWithWhereUniqueWithoutFormInput | FormEncounterUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormEncounterCreateManyFormInputEnvelope
    set?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    disconnect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    delete?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    update?: FormEncounterUpdateWithWhereUniqueWithoutFormInput | FormEncounterUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormEncounterUpdateManyWithWhereWithoutFormInput | FormEncounterUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
  }

  export type FormResourceUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput> | FormResourceCreateWithoutFormInput[] | FormResourceUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutFormInput | FormResourceCreateOrConnectWithoutFormInput[]
    upsert?: FormResourceUpsertWithWhereUniqueWithoutFormInput | FormResourceUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResourceCreateManyFormInputEnvelope
    set?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    disconnect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    delete?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    update?: FormResourceUpdateWithWhereUniqueWithoutFormInput | FormResourceUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResourceUpdateManyWithWhereWithoutFormInput | FormResourceUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FieldUpdateOneWithoutFormListNestedInput = {
    create?: XOR<FieldCreateWithoutFormListInput, FieldUncheckedCreateWithoutFormListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFormListInput
    upsert?: FieldUpsertWithoutFormListInput
    disconnect?: FieldWhereInput | boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFormListInput, FieldUpdateWithoutFormListInput>, FieldUncheckedUpdateWithoutFormListInput>
  }

  export type EncounterUpdateManyWithoutFormNestedInput = {
    create?: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput> | EncounterCreateWithoutFormInput[] | EncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutFormInput | EncounterCreateOrConnectWithoutFormInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutFormInput | EncounterUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: EncounterCreateManyFormInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutFormInput | EncounterUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutFormInput | EncounterUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FormEncounterUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput> | FormEncounterCreateWithoutFormInput[] | FormEncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutFormInput | FormEncounterCreateOrConnectWithoutFormInput[]
    upsert?: FormEncounterUpsertWithWhereUniqueWithoutFormInput | FormEncounterUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormEncounterCreateManyFormInputEnvelope
    set?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    disconnect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    delete?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    update?: FormEncounterUpdateWithWhereUniqueWithoutFormInput | FormEncounterUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormEncounterUpdateManyWithWhereWithoutFormInput | FormEncounterUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
  }

  export type FormResourceUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput> | FormResourceCreateWithoutFormInput[] | FormResourceUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutFormInput | FormResourceCreateOrConnectWithoutFormInput[]
    upsert?: FormResourceUpsertWithWhereUniqueWithoutFormInput | FormResourceUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResourceCreateManyFormInputEnvelope
    set?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    disconnect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    delete?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    update?: FormResourceUpdateWithWhereUniqueWithoutFormInput | FormResourceUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResourceUpdateManyWithWhereWithoutFormInput | FormResourceUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput> | FormSubmissionCreateWithoutFormInput[] | FormSubmissionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormInput | FormSubmissionCreateOrConnectWithoutFormInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormInput | FormSubmissionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormSubmissionCreateManyFormInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormInput | FormSubmissionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormInput | FormSubmissionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput> | EncounterCreateWithoutFormInput[] | EncounterUncheckedCreateWithoutFormInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutFormInput | EncounterCreateOrConnectWithoutFormInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutFormInput | EncounterUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: EncounterCreateManyFormInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutFormInput | EncounterUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutFormInput | EncounterUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type FormCreateNestedOneWithoutFormEncounterListInput = {
    create?: XOR<FormCreateWithoutFormEncounterListInput, FormUncheckedCreateWithoutFormEncounterListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormEncounterListInput
    connect?: FormWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutFormEncounterListInput = {
    create?: XOR<EncounterCreateWithoutFormEncounterListInput, EncounterUncheckedCreateWithoutFormEncounterListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutFormEncounterListInput
    connect?: EncounterWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutFormEncounterListNestedInput = {
    create?: XOR<FormCreateWithoutFormEncounterListInput, FormUncheckedCreateWithoutFormEncounterListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormEncounterListInput
    upsert?: FormUpsertWithoutFormEncounterListInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutFormEncounterListInput, FormUpdateWithoutFormEncounterListInput>, FormUncheckedUpdateWithoutFormEncounterListInput>
  }

  export type EncounterUpdateOneRequiredWithoutFormEncounterListNestedInput = {
    create?: XOR<EncounterCreateWithoutFormEncounterListInput, EncounterUncheckedCreateWithoutFormEncounterListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutFormEncounterListInput
    upsert?: EncounterUpsertWithoutFormEncounterListInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutFormEncounterListInput, EncounterUpdateWithoutFormEncounterListInput>, EncounterUncheckedUpdateWithoutFormEncounterListInput>
  }

  export type FormCreateNestedOneWithoutFormResourceListInput = {
    create?: XOR<FormCreateWithoutFormResourceListInput, FormUncheckedCreateWithoutFormResourceListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormResourceListInput
    connect?: FormWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutFormResourceListInput = {
    create?: XOR<ResourceCreateWithoutFormResourceListInput, ResourceUncheckedCreateWithoutFormResourceListInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutFormResourceListInput
    connect?: ResourceWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutFormResourceListNestedInput = {
    create?: XOR<FormCreateWithoutFormResourceListInput, FormUncheckedCreateWithoutFormResourceListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormResourceListInput
    upsert?: FormUpsertWithoutFormResourceListInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutFormResourceListInput, FormUpdateWithoutFormResourceListInput>, FormUncheckedUpdateWithoutFormResourceListInput>
  }

  export type ResourceUpdateOneRequiredWithoutFormResourceListNestedInput = {
    create?: XOR<ResourceCreateWithoutFormResourceListInput, ResourceUncheckedCreateWithoutFormResourceListInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutFormResourceListInput
    upsert?: ResourceUpsertWithoutFormResourceListInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutFormResourceListInput, ResourceUpdateWithoutFormResourceListInput>, ResourceUncheckedUpdateWithoutFormResourceListInput>
  }

  export type FormCreateNestedOneWithoutFormSubmissionListInput = {
    create?: XOR<FormCreateWithoutFormSubmissionListInput, FormUncheckedCreateWithoutFormSubmissionListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormSubmissionListInput
    connect?: FormWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutFormSubmissionListInput = {
    create?: XOR<EncounterCreateWithoutFormSubmissionListInput, EncounterUncheckedCreateWithoutFormSubmissionListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutFormSubmissionListInput
    connect?: EncounterWhereUniqueInput
  }

  export type FieldAnswerCreateNestedManyWithoutFormSubmissionInput = {
    create?: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput> | FieldAnswerCreateWithoutFormSubmissionInput[] | FieldAnswerUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFormSubmissionInput | FieldAnswerCreateOrConnectWithoutFormSubmissionInput[]
    createMany?: FieldAnswerCreateManyFormSubmissionInputEnvelope
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
  }

  export type FieldAnswerUncheckedCreateNestedManyWithoutFormSubmissionInput = {
    create?: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput> | FieldAnswerCreateWithoutFormSubmissionInput[] | FieldAnswerUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFormSubmissionInput | FieldAnswerCreateOrConnectWithoutFormSubmissionInput[]
    createMany?: FieldAnswerCreateManyFormSubmissionInputEnvelope
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
  }

  export type FormUpdateOneRequiredWithoutFormSubmissionListNestedInput = {
    create?: XOR<FormCreateWithoutFormSubmissionListInput, FormUncheckedCreateWithoutFormSubmissionListInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormSubmissionListInput
    upsert?: FormUpsertWithoutFormSubmissionListInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutFormSubmissionListInput, FormUpdateWithoutFormSubmissionListInput>, FormUncheckedUpdateWithoutFormSubmissionListInput>
  }

  export type EncounterUpdateOneRequiredWithoutFormSubmissionListNestedInput = {
    create?: XOR<EncounterCreateWithoutFormSubmissionListInput, EncounterUncheckedCreateWithoutFormSubmissionListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutFormSubmissionListInput
    upsert?: EncounterUpsertWithoutFormSubmissionListInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutFormSubmissionListInput, EncounterUpdateWithoutFormSubmissionListInput>, EncounterUncheckedUpdateWithoutFormSubmissionListInput>
  }

  export type FieldAnswerUpdateManyWithoutFormSubmissionNestedInput = {
    create?: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput> | FieldAnswerCreateWithoutFormSubmissionInput[] | FieldAnswerUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFormSubmissionInput | FieldAnswerCreateOrConnectWithoutFormSubmissionInput[]
    upsert?: FieldAnswerUpsertWithWhereUniqueWithoutFormSubmissionInput | FieldAnswerUpsertWithWhereUniqueWithoutFormSubmissionInput[]
    createMany?: FieldAnswerCreateManyFormSubmissionInputEnvelope
    set?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    disconnect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    delete?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    update?: FieldAnswerUpdateWithWhereUniqueWithoutFormSubmissionInput | FieldAnswerUpdateWithWhereUniqueWithoutFormSubmissionInput[]
    updateMany?: FieldAnswerUpdateManyWithWhereWithoutFormSubmissionInput | FieldAnswerUpdateManyWithWhereWithoutFormSubmissionInput[]
    deleteMany?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
  }

  export type FieldAnswerUncheckedUpdateManyWithoutFormSubmissionNestedInput = {
    create?: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput> | FieldAnswerCreateWithoutFormSubmissionInput[] | FieldAnswerUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFormSubmissionInput | FieldAnswerCreateOrConnectWithoutFormSubmissionInput[]
    upsert?: FieldAnswerUpsertWithWhereUniqueWithoutFormSubmissionInput | FieldAnswerUpsertWithWhereUniqueWithoutFormSubmissionInput[]
    createMany?: FieldAnswerCreateManyFormSubmissionInputEnvelope
    set?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    disconnect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    delete?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    update?: FieldAnswerUpdateWithWhereUniqueWithoutFormSubmissionInput | FieldAnswerUpdateWithWhereUniqueWithoutFormSubmissionInput[]
    updateMany?: FieldAnswerUpdateManyWithWhereWithoutFormSubmissionInput | FieldAnswerUpdateManyWithWhereWithoutFormSubmissionInput[]
    deleteMany?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutFieldListInput = {
    create?: XOR<ConceptCreateWithoutFieldListInput, ConceptUncheckedCreateWithoutFieldListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutFieldListInput
    connect?: ConceptWhereUniqueInput
  }

  export type FormCreateNestedManyWithoutDieldInput = {
    create?: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput> | FormCreateWithoutDieldInput[] | FormUncheckedCreateWithoutDieldInput[]
    connectOrCreate?: FormCreateOrConnectWithoutDieldInput | FormCreateOrConnectWithoutDieldInput[]
    createMany?: FormCreateManyDieldInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type FieldAnswerCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput> | FieldAnswerCreateWithoutFieldInput[] | FieldAnswerUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFieldInput | FieldAnswerCreateOrConnectWithoutFieldInput[]
    createMany?: FieldAnswerCreateManyFieldInputEnvelope
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
  }

  export type FieldOptionCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput> | FieldOptionCreateWithoutFieldInput[] | FieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOptionCreateOrConnectWithoutFieldInput | FieldOptionCreateOrConnectWithoutFieldInput[]
    createMany?: FieldOptionCreateManyFieldInputEnvelope
    connect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutDieldInput = {
    create?: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput> | FormCreateWithoutDieldInput[] | FormUncheckedCreateWithoutDieldInput[]
    connectOrCreate?: FormCreateOrConnectWithoutDieldInput | FormCreateOrConnectWithoutDieldInput[]
    createMany?: FormCreateManyDieldInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type FieldAnswerUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput> | FieldAnswerCreateWithoutFieldInput[] | FieldAnswerUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFieldInput | FieldAnswerCreateOrConnectWithoutFieldInput[]
    createMany?: FieldAnswerCreateManyFieldInputEnvelope
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
  }

  export type FieldOptionUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput> | FieldOptionCreateWithoutFieldInput[] | FieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOptionCreateOrConnectWithoutFieldInput | FieldOptionCreateOrConnectWithoutFieldInput[]
    createMany?: FieldOptionCreateManyFieldInputEnvelope
    connect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
  }

  export type ConceptUpdateOneRequiredWithoutFieldListNestedInput = {
    create?: XOR<ConceptCreateWithoutFieldListInput, ConceptUncheckedCreateWithoutFieldListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutFieldListInput
    upsert?: ConceptUpsertWithoutFieldListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutFieldListInput, ConceptUpdateWithoutFieldListInput>, ConceptUncheckedUpdateWithoutFieldListInput>
  }

  export type FormUpdateManyWithoutDieldNestedInput = {
    create?: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput> | FormCreateWithoutDieldInput[] | FormUncheckedCreateWithoutDieldInput[]
    connectOrCreate?: FormCreateOrConnectWithoutDieldInput | FormCreateOrConnectWithoutDieldInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutDieldInput | FormUpsertWithWhereUniqueWithoutDieldInput[]
    createMany?: FormCreateManyDieldInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutDieldInput | FormUpdateWithWhereUniqueWithoutDieldInput[]
    updateMany?: FormUpdateManyWithWhereWithoutDieldInput | FormUpdateManyWithWhereWithoutDieldInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FieldAnswerUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput> | FieldAnswerCreateWithoutFieldInput[] | FieldAnswerUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFieldInput | FieldAnswerCreateOrConnectWithoutFieldInput[]
    upsert?: FieldAnswerUpsertWithWhereUniqueWithoutFieldInput | FieldAnswerUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldAnswerCreateManyFieldInputEnvelope
    set?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    disconnect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    delete?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    update?: FieldAnswerUpdateWithWhereUniqueWithoutFieldInput | FieldAnswerUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldAnswerUpdateManyWithWhereWithoutFieldInput | FieldAnswerUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
  }

  export type FieldOptionUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput> | FieldOptionCreateWithoutFieldInput[] | FieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOptionCreateOrConnectWithoutFieldInput | FieldOptionCreateOrConnectWithoutFieldInput[]
    upsert?: FieldOptionUpsertWithWhereUniqueWithoutFieldInput | FieldOptionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldOptionCreateManyFieldInputEnvelope
    set?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    disconnect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    delete?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    connect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    update?: FieldOptionUpdateWithWhereUniqueWithoutFieldInput | FieldOptionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldOptionUpdateManyWithWhereWithoutFieldInput | FieldOptionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldOptionScalarWhereInput | FieldOptionScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutDieldNestedInput = {
    create?: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput> | FormCreateWithoutDieldInput[] | FormUncheckedCreateWithoutDieldInput[]
    connectOrCreate?: FormCreateOrConnectWithoutDieldInput | FormCreateOrConnectWithoutDieldInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutDieldInput | FormUpsertWithWhereUniqueWithoutDieldInput[]
    createMany?: FormCreateManyDieldInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutDieldInput | FormUpdateWithWhereUniqueWithoutDieldInput[]
    updateMany?: FormUpdateManyWithWhereWithoutDieldInput | FormUpdateManyWithWhereWithoutDieldInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FieldAnswerUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput> | FieldAnswerCreateWithoutFieldInput[] | FieldAnswerUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldAnswerCreateOrConnectWithoutFieldInput | FieldAnswerCreateOrConnectWithoutFieldInput[]
    upsert?: FieldAnswerUpsertWithWhereUniqueWithoutFieldInput | FieldAnswerUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldAnswerCreateManyFieldInputEnvelope
    set?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    disconnect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    delete?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    connect?: FieldAnswerWhereUniqueInput | FieldAnswerWhereUniqueInput[]
    update?: FieldAnswerUpdateWithWhereUniqueWithoutFieldInput | FieldAnswerUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldAnswerUpdateManyWithWhereWithoutFieldInput | FieldAnswerUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
  }

  export type FieldOptionUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput> | FieldOptionCreateWithoutFieldInput[] | FieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOptionCreateOrConnectWithoutFieldInput | FieldOptionCreateOrConnectWithoutFieldInput[]
    upsert?: FieldOptionUpsertWithWhereUniqueWithoutFieldInput | FieldOptionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldOptionCreateManyFieldInputEnvelope
    set?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    disconnect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    delete?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    connect?: FieldOptionWhereUniqueInput | FieldOptionWhereUniqueInput[]
    update?: FieldOptionUpdateWithWhereUniqueWithoutFieldInput | FieldOptionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldOptionUpdateManyWithWhereWithoutFieldInput | FieldOptionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldOptionScalarWhereInput | FieldOptionScalarWhereInput[]
  }

  export type FormSubmissionCreateNestedOneWithoutFieldAnswerListInput = {
    create?: XOR<FormSubmissionCreateWithoutFieldAnswerListInput, FormSubmissionUncheckedCreateWithoutFieldAnswerListInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFieldAnswerListInput
    connect?: FormSubmissionWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutFieldAnswerListInput = {
    create?: XOR<FieldCreateWithoutFieldAnswerListInput, FieldUncheckedCreateWithoutFieldAnswerListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldAnswerListInput
    connect?: FieldWhereUniqueInput
  }

  export type FormSubmissionUpdateOneRequiredWithoutFieldAnswerListNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFieldAnswerListInput, FormSubmissionUncheckedCreateWithoutFieldAnswerListInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFieldAnswerListInput
    upsert?: FormSubmissionUpsertWithoutFieldAnswerListInput
    connect?: FormSubmissionWhereUniqueInput
    update?: XOR<XOR<FormSubmissionUpdateToOneWithWhereWithoutFieldAnswerListInput, FormSubmissionUpdateWithoutFieldAnswerListInput>, FormSubmissionUncheckedUpdateWithoutFieldAnswerListInput>
  }

  export type FieldUpdateOneRequiredWithoutFieldAnswerListNestedInput = {
    create?: XOR<FieldCreateWithoutFieldAnswerListInput, FieldUncheckedCreateWithoutFieldAnswerListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldAnswerListInput
    upsert?: FieldUpsertWithoutFieldAnswerListInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFieldAnswerListInput, FieldUpdateWithoutFieldAnswerListInput>, FieldUncheckedUpdateWithoutFieldAnswerListInput>
  }

  export type FieldCreateNestedOneWithoutFieldOptionListInput = {
    create?: XOR<FieldCreateWithoutFieldOptionListInput, FieldUncheckedCreateWithoutFieldOptionListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldOptionListInput
    connect?: FieldWhereUniqueInput
  }

  export type FieldUpdateOneRequiredWithoutFieldOptionListNestedInput = {
    create?: XOR<FieldCreateWithoutFieldOptionListInput, FieldUncheckedCreateWithoutFieldOptionListInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldOptionListInput
    upsert?: FieldUpsertWithoutFieldOptionListInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFieldOptionListInput, FieldUpdateWithoutFieldOptionListInput>, FieldUncheckedUpdateWithoutFieldOptionListInput>
  }

  export type EncounterTypeCreateNestedOneWithoutEncounterListInput = {
    create?: XOR<EncounterTypeCreateWithoutEncounterListInput, EncounterTypeUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: EncounterTypeCreateOrConnectWithoutEncounterListInput
    connect?: EncounterTypeWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutEncounterListInput = {
    create?: XOR<PatientCreateWithoutEncounterListInput, PatientUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncounterListInput
    connect?: PatientWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutEncounterListInput = {
    create?: XOR<LocationCreateWithoutEncounterListInput, LocationUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEncounterListInput
    connect?: LocationWhereUniqueInput
  }

  export type FormCreateNestedOneWithoutEncounterListInput = {
    create?: XOR<FormCreateWithoutEncounterListInput, FormUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: FormCreateOrConnectWithoutEncounterListInput
    connect?: FormWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutEncounterListInput = {
    create?: XOR<ProviderCreateWithoutEncounterListInput, ProviderUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutEncounterListInput
    connect?: ProviderWhereUniqueInput
  }

  export type FormEncounterCreateNestedManyWithoutEncounterInput = {
    create?: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput> | FormEncounterCreateWithoutEncounterInput[] | FormEncounterUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutEncounterInput | FormEncounterCreateOrConnectWithoutEncounterInput[]
    createMany?: FormEncounterCreateManyEncounterInputEnvelope
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput> | FormSubmissionCreateWithoutEncounterInput[] | FormSubmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutEncounterInput | FormSubmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: FormSubmissionCreateManyEncounterInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type ObsCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput> | ObsCreateWithoutEncounterInput[] | ObsUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutEncounterInput | ObsCreateOrConnectWithoutEncounterInput[]
    createMany?: ObsCreateManyEncounterInputEnvelope
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutEncounterInput = {
    create?: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput> | OrderCreateWithoutEncounterInput[] | OrderUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEncounterInput | OrderCreateOrConnectWithoutEncounterInput[]
    createMany?: OrderCreateManyEncounterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type FormEncounterUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput> | FormEncounterCreateWithoutEncounterInput[] | FormEncounterUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutEncounterInput | FormEncounterCreateOrConnectWithoutEncounterInput[]
    createMany?: FormEncounterCreateManyEncounterInputEnvelope
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput> | FormSubmissionCreateWithoutEncounterInput[] | FormSubmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutEncounterInput | FormSubmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: FormSubmissionCreateManyEncounterInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type ObsUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput> | ObsCreateWithoutEncounterInput[] | ObsUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutEncounterInput | ObsCreateOrConnectWithoutEncounterInput[]
    createMany?: ObsCreateManyEncounterInputEnvelope
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput> | OrderCreateWithoutEncounterInput[] | OrderUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEncounterInput | OrderCreateOrConnectWithoutEncounterInput[]
    createMany?: OrderCreateManyEncounterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput = {
    create?: XOR<EncounterTypeCreateWithoutEncounterListInput, EncounterTypeUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: EncounterTypeCreateOrConnectWithoutEncounterListInput
    upsert?: EncounterTypeUpsertWithoutEncounterListInput
    connect?: EncounterTypeWhereUniqueInput
    update?: XOR<XOR<EncounterTypeUpdateToOneWithWhereWithoutEncounterListInput, EncounterTypeUpdateWithoutEncounterListInput>, EncounterTypeUncheckedUpdateWithoutEncounterListInput>
  }

  export type PatientUpdateOneRequiredWithoutEncounterListNestedInput = {
    create?: XOR<PatientCreateWithoutEncounterListInput, PatientUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncounterListInput
    upsert?: PatientUpsertWithoutEncounterListInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEncounterListInput, PatientUpdateWithoutEncounterListInput>, PatientUncheckedUpdateWithoutEncounterListInput>
  }

  export type LocationUpdateOneRequiredWithoutEncounterListNestedInput = {
    create?: XOR<LocationCreateWithoutEncounterListInput, LocationUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEncounterListInput
    upsert?: LocationUpsertWithoutEncounterListInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutEncounterListInput, LocationUpdateWithoutEncounterListInput>, LocationUncheckedUpdateWithoutEncounterListInput>
  }

  export type FormUpdateOneRequiredWithoutEncounterListNestedInput = {
    create?: XOR<FormCreateWithoutEncounterListInput, FormUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: FormCreateOrConnectWithoutEncounterListInput
    upsert?: FormUpsertWithoutEncounterListInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutEncounterListInput, FormUpdateWithoutEncounterListInput>, FormUncheckedUpdateWithoutEncounterListInput>
  }

  export type ProviderUpdateOneRequiredWithoutEncounterListNestedInput = {
    create?: XOR<ProviderCreateWithoutEncounterListInput, ProviderUncheckedCreateWithoutEncounterListInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutEncounterListInput
    upsert?: ProviderUpsertWithoutEncounterListInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutEncounterListInput, ProviderUpdateWithoutEncounterListInput>, ProviderUncheckedUpdateWithoutEncounterListInput>
  }

  export type FormEncounterUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput> | FormEncounterCreateWithoutEncounterInput[] | FormEncounterUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutEncounterInput | FormEncounterCreateOrConnectWithoutEncounterInput[]
    upsert?: FormEncounterUpsertWithWhereUniqueWithoutEncounterInput | FormEncounterUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: FormEncounterCreateManyEncounterInputEnvelope
    set?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    disconnect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    delete?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    update?: FormEncounterUpdateWithWhereUniqueWithoutEncounterInput | FormEncounterUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: FormEncounterUpdateManyWithWhereWithoutEncounterInput | FormEncounterUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput> | FormSubmissionCreateWithoutEncounterInput[] | FormSubmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutEncounterInput | FormSubmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutEncounterInput | FormSubmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: FormSubmissionCreateManyEncounterInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutEncounterInput | FormSubmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutEncounterInput | FormSubmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type ObsUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput> | ObsCreateWithoutEncounterInput[] | ObsUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutEncounterInput | ObsCreateOrConnectWithoutEncounterInput[]
    upsert?: ObsUpsertWithWhereUniqueWithoutEncounterInput | ObsUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ObsCreateManyEncounterInputEnvelope
    set?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    disconnect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    delete?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    update?: ObsUpdateWithWhereUniqueWithoutEncounterInput | ObsUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ObsUpdateManyWithWhereWithoutEncounterInput | ObsUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ObsScalarWhereInput | ObsScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput> | OrderCreateWithoutEncounterInput[] | OrderUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEncounterInput | OrderCreateOrConnectWithoutEncounterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEncounterInput | OrderUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: OrderCreateManyEncounterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEncounterInput | OrderUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEncounterInput | OrderUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput> | FormEncounterCreateWithoutEncounterInput[] | FormEncounterUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormEncounterCreateOrConnectWithoutEncounterInput | FormEncounterCreateOrConnectWithoutEncounterInput[]
    upsert?: FormEncounterUpsertWithWhereUniqueWithoutEncounterInput | FormEncounterUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: FormEncounterCreateManyEncounterInputEnvelope
    set?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    disconnect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    delete?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    connect?: FormEncounterWhereUniqueInput | FormEncounterWhereUniqueInput[]
    update?: FormEncounterUpdateWithWhereUniqueWithoutEncounterInput | FormEncounterUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: FormEncounterUpdateManyWithWhereWithoutEncounterInput | FormEncounterUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput> | FormSubmissionCreateWithoutEncounterInput[] | FormSubmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutEncounterInput | FormSubmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutEncounterInput | FormSubmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: FormSubmissionCreateManyEncounterInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutEncounterInput | FormSubmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutEncounterInput | FormSubmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type ObsUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput> | ObsCreateWithoutEncounterInput[] | ObsUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutEncounterInput | ObsCreateOrConnectWithoutEncounterInput[]
    upsert?: ObsUpsertWithWhereUniqueWithoutEncounterInput | ObsUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ObsCreateManyEncounterInputEnvelope
    set?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    disconnect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    delete?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    update?: ObsUpdateWithWhereUniqueWithoutEncounterInput | ObsUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ObsUpdateManyWithWhereWithoutEncounterInput | ObsUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ObsScalarWhereInput | ObsScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput> | OrderCreateWithoutEncounterInput[] | OrderUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEncounterInput | OrderCreateOrConnectWithoutEncounterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEncounterInput | OrderUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: OrderCreateManyEncounterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEncounterInput | OrderUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEncounterInput | OrderUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EncounterCreateNestedManyWithoutEncounterTypeInput = {
    create?: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput> | EncounterCreateWithoutEncounterTypeInput[] | EncounterUncheckedCreateWithoutEncounterTypeInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterTypeInput | EncounterCreateOrConnectWithoutEncounterTypeInput[]
    createMany?: EncounterCreateManyEncounterTypeInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutEncounterTypeInput = {
    create?: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput> | EncounterCreateWithoutEncounterTypeInput[] | EncounterUncheckedCreateWithoutEncounterTypeInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterTypeInput | EncounterCreateOrConnectWithoutEncounterTypeInput[]
    createMany?: EncounterCreateManyEncounterTypeInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUpdateManyWithoutEncounterTypeNestedInput = {
    create?: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput> | EncounterCreateWithoutEncounterTypeInput[] | EncounterUncheckedCreateWithoutEncounterTypeInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterTypeInput | EncounterCreateOrConnectWithoutEncounterTypeInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutEncounterTypeInput | EncounterUpsertWithWhereUniqueWithoutEncounterTypeInput[]
    createMany?: EncounterCreateManyEncounterTypeInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutEncounterTypeInput | EncounterUpdateWithWhereUniqueWithoutEncounterTypeInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutEncounterTypeInput | EncounterUpdateManyWithWhereWithoutEncounterTypeInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutEncounterTypeNestedInput = {
    create?: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput> | EncounterCreateWithoutEncounterTypeInput[] | EncounterUncheckedCreateWithoutEncounterTypeInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterTypeInput | EncounterCreateOrConnectWithoutEncounterTypeInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutEncounterTypeInput | EncounterUpsertWithWhereUniqueWithoutEncounterTypeInput[]
    createMany?: EncounterCreateManyEncounterTypeInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutEncounterTypeInput | EncounterUpdateWithWhereUniqueWithoutEncounterTypeInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutEncounterTypeInput | EncounterUpdateManyWithWhereWithoutEncounterTypeInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutObsListInput = {
    create?: XOR<ConceptCreateWithoutObsListInput, ConceptUncheckedCreateWithoutObsListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutObsListInput
    connect?: ConceptWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutObsListInput = {
    create?: XOR<EncounterCreateWithoutObsListInput, EncounterUncheckedCreateWithoutObsListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutObsListInput
    connect?: EncounterWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutObsListNestedInput = {
    create?: XOR<ConceptCreateWithoutObsListInput, ConceptUncheckedCreateWithoutObsListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutObsListInput
    upsert?: ConceptUpsertWithoutObsListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutObsListInput, ConceptUpdateWithoutObsListInput>, ConceptUncheckedUpdateWithoutObsListInput>
  }

  export type EncounterUpdateOneRequiredWithoutObsListNestedInput = {
    create?: XOR<EncounterCreateWithoutObsListInput, EncounterUncheckedCreateWithoutObsListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutObsListInput
    upsert?: EncounterUpsertWithoutObsListInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutObsListInput, EncounterUpdateWithoutObsListInput>, EncounterUncheckedUpdateWithoutObsListInput>
  }

  export type ConceptCreateNestedOneWithoutOrderListInput = {
    create?: XOR<ConceptCreateWithoutOrderListInput, ConceptUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutOrderListInput
    connect?: ConceptWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutOrderListInput = {
    create?: XOR<EncounterCreateWithoutOrderListInput, EncounterUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutOrderListInput
    connect?: EncounterWhereUniqueInput
  }

  export type OrderFrequencyCreateNestedOneWithoutOrderListInput = {
    create?: XOR<OrderFrequencyCreateWithoutOrderListInput, OrderFrequencyUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderFrequencyCreateOrConnectWithoutOrderListInput
    connect?: OrderFrequencyWhereUniqueInput
  }

  export type OrderRouteCreateNestedOneWithoutOrderListInput = {
    create?: XOR<OrderRouteCreateWithoutOrderListInput, OrderRouteUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderRouteCreateOrConnectWithoutOrderListInput
    connect?: OrderRouteWhereUniqueInput
  }

  export type OrderTypeCreateNestedOneWithoutOrderListInput = {
    create?: XOR<OrderTypeCreateWithoutOrderListInput, OrderTypeUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderTypeCreateOrConnectWithoutOrderListInput
    connect?: OrderTypeWhereUniqueInput
  }

  export type OrderUnitCreateNestedOneWithoutOrderListInput = {
    create?: XOR<OrderUnitCreateWithoutOrderListInput, OrderUnitUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderUnitCreateOrConnectWithoutOrderListInput
    connect?: OrderUnitWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutOrderListNestedInput = {
    create?: XOR<ConceptCreateWithoutOrderListInput, ConceptUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutOrderListInput
    upsert?: ConceptUpsertWithoutOrderListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutOrderListInput, ConceptUpdateWithoutOrderListInput>, ConceptUncheckedUpdateWithoutOrderListInput>
  }

  export type EncounterUpdateOneRequiredWithoutOrderListNestedInput = {
    create?: XOR<EncounterCreateWithoutOrderListInput, EncounterUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutOrderListInput
    upsert?: EncounterUpsertWithoutOrderListInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutOrderListInput, EncounterUpdateWithoutOrderListInput>, EncounterUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderFrequencyUpdateOneWithoutOrderListNestedInput = {
    create?: XOR<OrderFrequencyCreateWithoutOrderListInput, OrderFrequencyUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderFrequencyCreateOrConnectWithoutOrderListInput
    upsert?: OrderFrequencyUpsertWithoutOrderListInput
    disconnect?: OrderFrequencyWhereInput | boolean
    delete?: OrderFrequencyWhereInput | boolean
    connect?: OrderFrequencyWhereUniqueInput
    update?: XOR<XOR<OrderFrequencyUpdateToOneWithWhereWithoutOrderListInput, OrderFrequencyUpdateWithoutOrderListInput>, OrderFrequencyUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderRouteUpdateOneWithoutOrderListNestedInput = {
    create?: XOR<OrderRouteCreateWithoutOrderListInput, OrderRouteUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderRouteCreateOrConnectWithoutOrderListInput
    upsert?: OrderRouteUpsertWithoutOrderListInput
    disconnect?: OrderRouteWhereInput | boolean
    delete?: OrderRouteWhereInput | boolean
    connect?: OrderRouteWhereUniqueInput
    update?: XOR<XOR<OrderRouteUpdateToOneWithWhereWithoutOrderListInput, OrderRouteUpdateWithoutOrderListInput>, OrderRouteUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderTypeUpdateOneWithoutOrderListNestedInput = {
    create?: XOR<OrderTypeCreateWithoutOrderListInput, OrderTypeUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderTypeCreateOrConnectWithoutOrderListInput
    upsert?: OrderTypeUpsertWithoutOrderListInput
    disconnect?: OrderTypeWhereInput | boolean
    delete?: OrderTypeWhereInput | boolean
    connect?: OrderTypeWhereUniqueInput
    update?: XOR<XOR<OrderTypeUpdateToOneWithWhereWithoutOrderListInput, OrderTypeUpdateWithoutOrderListInput>, OrderTypeUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderUnitUpdateOneWithoutOrderListNestedInput = {
    create?: XOR<OrderUnitCreateWithoutOrderListInput, OrderUnitUncheckedCreateWithoutOrderListInput>
    connectOrCreate?: OrderUnitCreateOrConnectWithoutOrderListInput
    upsert?: OrderUnitUpsertWithoutOrderListInput
    disconnect?: OrderUnitWhereInput | boolean
    delete?: OrderUnitWhereInput | boolean
    connect?: OrderUnitWhereUniqueInput
    update?: XOR<XOR<OrderUnitUpdateToOneWithWhereWithoutOrderListInput, OrderUnitUpdateWithoutOrderListInput>, OrderUnitUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderCreateNestedManyWithoutOrderFrequencyInput = {
    create?: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput> | OrderCreateWithoutOrderFrequencyInput[] | OrderUncheckedCreateWithoutOrderFrequencyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderFrequencyInput | OrderCreateOrConnectWithoutOrderFrequencyInput[]
    createMany?: OrderCreateManyOrderFrequencyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrderFrequencyInput = {
    create?: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput> | OrderCreateWithoutOrderFrequencyInput[] | OrderUncheckedCreateWithoutOrderFrequencyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderFrequencyInput | OrderCreateOrConnectWithoutOrderFrequencyInput[]
    createMany?: OrderCreateManyOrderFrequencyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutOrderFrequencyNestedInput = {
    create?: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput> | OrderCreateWithoutOrderFrequencyInput[] | OrderUncheckedCreateWithoutOrderFrequencyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderFrequencyInput | OrderCreateOrConnectWithoutOrderFrequencyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderFrequencyInput | OrderUpsertWithWhereUniqueWithoutOrderFrequencyInput[]
    createMany?: OrderCreateManyOrderFrequencyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderFrequencyInput | OrderUpdateWithWhereUniqueWithoutOrderFrequencyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderFrequencyInput | OrderUpdateManyWithWhereWithoutOrderFrequencyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrderFrequencyNestedInput = {
    create?: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput> | OrderCreateWithoutOrderFrequencyInput[] | OrderUncheckedCreateWithoutOrderFrequencyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderFrequencyInput | OrderCreateOrConnectWithoutOrderFrequencyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderFrequencyInput | OrderUpsertWithWhereUniqueWithoutOrderFrequencyInput[]
    createMany?: OrderCreateManyOrderFrequencyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderFrequencyInput | OrderUpdateWithWhereUniqueWithoutOrderFrequencyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderFrequencyInput | OrderUpdateManyWithWhereWithoutOrderFrequencyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutOrderRouteInput = {
    create?: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput> | OrderCreateWithoutOrderRouteInput[] | OrderUncheckedCreateWithoutOrderRouteInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderRouteInput | OrderCreateOrConnectWithoutOrderRouteInput[]
    createMany?: OrderCreateManyOrderRouteInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrderRouteInput = {
    create?: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput> | OrderCreateWithoutOrderRouteInput[] | OrderUncheckedCreateWithoutOrderRouteInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderRouteInput | OrderCreateOrConnectWithoutOrderRouteInput[]
    createMany?: OrderCreateManyOrderRouteInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutOrderRouteNestedInput = {
    create?: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput> | OrderCreateWithoutOrderRouteInput[] | OrderUncheckedCreateWithoutOrderRouteInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderRouteInput | OrderCreateOrConnectWithoutOrderRouteInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderRouteInput | OrderUpsertWithWhereUniqueWithoutOrderRouteInput[]
    createMany?: OrderCreateManyOrderRouteInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderRouteInput | OrderUpdateWithWhereUniqueWithoutOrderRouteInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderRouteInput | OrderUpdateManyWithWhereWithoutOrderRouteInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrderRouteNestedInput = {
    create?: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput> | OrderCreateWithoutOrderRouteInput[] | OrderUncheckedCreateWithoutOrderRouteInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderRouteInput | OrderCreateOrConnectWithoutOrderRouteInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderRouteInput | OrderUpsertWithWhereUniqueWithoutOrderRouteInput[]
    createMany?: OrderCreateManyOrderRouteInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderRouteInput | OrderUpdateWithWhereUniqueWithoutOrderRouteInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderRouteInput | OrderUpdateManyWithWhereWithoutOrderRouteInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutOrderTypeInput = {
    create?: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput> | OrderCreateWithoutOrderTypeInput[] | OrderUncheckedCreateWithoutOrderTypeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderTypeInput | OrderCreateOrConnectWithoutOrderTypeInput[]
    createMany?: OrderCreateManyOrderTypeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrderTypeInput = {
    create?: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput> | OrderCreateWithoutOrderTypeInput[] | OrderUncheckedCreateWithoutOrderTypeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderTypeInput | OrderCreateOrConnectWithoutOrderTypeInput[]
    createMany?: OrderCreateManyOrderTypeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutOrderTypeNestedInput = {
    create?: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput> | OrderCreateWithoutOrderTypeInput[] | OrderUncheckedCreateWithoutOrderTypeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderTypeInput | OrderCreateOrConnectWithoutOrderTypeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderTypeInput | OrderUpsertWithWhereUniqueWithoutOrderTypeInput[]
    createMany?: OrderCreateManyOrderTypeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderTypeInput | OrderUpdateWithWhereUniqueWithoutOrderTypeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderTypeInput | OrderUpdateManyWithWhereWithoutOrderTypeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrderTypeNestedInput = {
    create?: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput> | OrderCreateWithoutOrderTypeInput[] | OrderUncheckedCreateWithoutOrderTypeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderTypeInput | OrderCreateOrConnectWithoutOrderTypeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderTypeInput | OrderUpsertWithWhereUniqueWithoutOrderTypeInput[]
    createMany?: OrderCreateManyOrderTypeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderTypeInput | OrderUpdateWithWhereUniqueWithoutOrderTypeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderTypeInput | OrderUpdateManyWithWhereWithoutOrderTypeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutOrderUnitInput = {
    create?: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput> | OrderCreateWithoutOrderUnitInput[] | OrderUncheckedCreateWithoutOrderUnitInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderUnitInput | OrderCreateOrConnectWithoutOrderUnitInput[]
    createMany?: OrderCreateManyOrderUnitInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrderUnitInput = {
    create?: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput> | OrderCreateWithoutOrderUnitInput[] | OrderUncheckedCreateWithoutOrderUnitInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderUnitInput | OrderCreateOrConnectWithoutOrderUnitInput[]
    createMany?: OrderCreateManyOrderUnitInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutOrderUnitNestedInput = {
    create?: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput> | OrderCreateWithoutOrderUnitInput[] | OrderUncheckedCreateWithoutOrderUnitInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderUnitInput | OrderCreateOrConnectWithoutOrderUnitInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderUnitInput | OrderUpsertWithWhereUniqueWithoutOrderUnitInput[]
    createMany?: OrderCreateManyOrderUnitInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderUnitInput | OrderUpdateWithWhereUniqueWithoutOrderUnitInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderUnitInput | OrderUpdateManyWithWhereWithoutOrderUnitInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrderUnitNestedInput = {
    create?: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput> | OrderCreateWithoutOrderUnitInput[] | OrderUncheckedCreateWithoutOrderUnitInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderUnitInput | OrderCreateOrConnectWithoutOrderUnitInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderUnitInput | OrderUpsertWithWhereUniqueWithoutOrderUnitInput[]
    createMany?: OrderCreateManyOrderUnitInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderUnitInput | OrderUpdateWithWhereUniqueWithoutOrderUnitInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderUnitInput | OrderUpdateManyWithWhereWithoutOrderUnitInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ConceptAnswerCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput> | ConceptAnswerCreateWithoutConceptInput[] | ConceptAnswerUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutConceptInput | ConceptAnswerCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptAnswerCreateManyConceptInputEnvelope
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
  }

  export type ConceptAnswerCreateNestedManyWithoutAnswerConceptInput = {
    create?: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput> | ConceptAnswerCreateWithoutAnswerConceptInput[] | ConceptAnswerUncheckedCreateWithoutAnswerConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutAnswerConceptInput | ConceptAnswerCreateOrConnectWithoutAnswerConceptInput[]
    createMany?: ConceptAnswerCreateManyAnswerConceptInputEnvelope
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
  }

  export type FieldCreateNestedManyWithoutConceptInput = {
    create?: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput> | FieldCreateWithoutConceptInput[] | FieldUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutConceptInput | FieldCreateOrConnectWithoutConceptInput[]
    createMany?: FieldCreateManyConceptInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type ObsCreateNestedManyWithoutConceptInput = {
    create?: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput> | ObsCreateWithoutConceptInput[] | ObsUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutConceptInput | ObsCreateOrConnectWithoutConceptInput[]
    createMany?: ObsCreateManyConceptInputEnvelope
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutConceptInput = {
    create?: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput> | OrderCreateWithoutConceptInput[] | OrderUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutConceptInput | OrderCreateOrConnectWithoutConceptInput[]
    createMany?: OrderCreateManyConceptInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ConceptClassCreateNestedOneWithoutConceptListInput = {
    create?: XOR<ConceptClassCreateWithoutConceptListInput, ConceptClassUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptClassCreateOrConnectWithoutConceptListInput
    connect?: ConceptClassWhereUniqueInput
  }

  export type ConceptDatatypeCreateNestedOneWithoutConceptListInput = {
    create?: XOR<ConceptDatatypeCreateWithoutConceptListInput, ConceptDatatypeUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptDatatypeCreateOrConnectWithoutConceptListInput
    connect?: ConceptDatatypeWhereUniqueInput
  }

  export type ConceptMapCreateNestedOneWithoutConceptListInput = {
    create?: XOR<ConceptMapCreateWithoutConceptListInput, ConceptMapUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptMapCreateOrConnectWithoutConceptListInput
    connect?: ConceptMapWhereUniqueInput
  }

  export type ConceptNameCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput> | ConceptNameCreateWithoutConceptInput[] | ConceptNameUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNameCreateOrConnectWithoutConceptInput | ConceptNameCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptNameCreateManyConceptInputEnvelope
    connect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
  }

  export type ConceptNumericCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput> | ConceptNumericCreateWithoutConceptInput[] | ConceptNumericUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNumericCreateOrConnectWithoutConceptInput | ConceptNumericCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptNumericCreateManyConceptInputEnvelope
    connect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
  }

  export type ConceptProposalCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput> | ConceptProposalCreateWithoutConceptInput[] | ConceptProposalUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptProposalCreateOrConnectWithoutConceptInput | ConceptProposalCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptProposalCreateManyConceptInputEnvelope
    connect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
  }

  export type ConceptSetCreateNestedOneWithoutConceptListInput = {
    create?: XOR<ConceptSetCreateWithoutConceptListInput, ConceptSetUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptSetCreateOrConnectWithoutConceptListInput
    connect?: ConceptSetWhereUniqueInput
  }

  export type ConceptSourceCreateNestedOneWithoutConceptListInput = {
    create?: XOR<ConceptSourceCreateWithoutConceptListInput, ConceptSourceUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptSourceCreateOrConnectWithoutConceptListInput
    connect?: ConceptSourceWhereUniqueInput
  }

  export type ConceptWordCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput> | ConceptWordCreateWithoutConceptInput[] | ConceptWordUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptWordCreateOrConnectWithoutConceptInput | ConceptWordCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptWordCreateManyConceptInputEnvelope
    connect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
  }

  export type ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput> | ConceptAnswerCreateWithoutConceptInput[] | ConceptAnswerUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutConceptInput | ConceptAnswerCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptAnswerCreateManyConceptInputEnvelope
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
  }

  export type ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput = {
    create?: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput> | ConceptAnswerCreateWithoutAnswerConceptInput[] | ConceptAnswerUncheckedCreateWithoutAnswerConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutAnswerConceptInput | ConceptAnswerCreateOrConnectWithoutAnswerConceptInput[]
    createMany?: ConceptAnswerCreateManyAnswerConceptInputEnvelope
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
  }

  export type FieldUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput> | FieldCreateWithoutConceptInput[] | FieldUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutConceptInput | FieldCreateOrConnectWithoutConceptInput[]
    createMany?: FieldCreateManyConceptInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type ObsUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput> | ObsCreateWithoutConceptInput[] | ObsUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutConceptInput | ObsCreateOrConnectWithoutConceptInput[]
    createMany?: ObsCreateManyConceptInputEnvelope
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput> | OrderCreateWithoutConceptInput[] | OrderUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutConceptInput | OrderCreateOrConnectWithoutConceptInput[]
    createMany?: OrderCreateManyConceptInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ConceptNameUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput> | ConceptNameCreateWithoutConceptInput[] | ConceptNameUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNameCreateOrConnectWithoutConceptInput | ConceptNameCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptNameCreateManyConceptInputEnvelope
    connect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
  }

  export type ConceptNumericUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput> | ConceptNumericCreateWithoutConceptInput[] | ConceptNumericUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNumericCreateOrConnectWithoutConceptInput | ConceptNumericCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptNumericCreateManyConceptInputEnvelope
    connect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
  }

  export type ConceptProposalUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput> | ConceptProposalCreateWithoutConceptInput[] | ConceptProposalUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptProposalCreateOrConnectWithoutConceptInput | ConceptProposalCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptProposalCreateManyConceptInputEnvelope
    connect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
  }

  export type ConceptWordUncheckedCreateNestedManyWithoutConceptInput = {
    create?: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput> | ConceptWordCreateWithoutConceptInput[] | ConceptWordUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptWordCreateOrConnectWithoutConceptInput | ConceptWordCreateOrConnectWithoutConceptInput[]
    createMany?: ConceptWordCreateManyConceptInputEnvelope
    connect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
  }

  export type ConceptAnswerUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput> | ConceptAnswerCreateWithoutConceptInput[] | ConceptAnswerUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutConceptInput | ConceptAnswerCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptAnswerUpsertWithWhereUniqueWithoutConceptInput | ConceptAnswerUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptAnswerCreateManyConceptInputEnvelope
    set?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    disconnect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    delete?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    update?: ConceptAnswerUpdateWithWhereUniqueWithoutConceptInput | ConceptAnswerUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptAnswerUpdateManyWithWhereWithoutConceptInput | ConceptAnswerUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
  }

  export type ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput = {
    create?: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput> | ConceptAnswerCreateWithoutAnswerConceptInput[] | ConceptAnswerUncheckedCreateWithoutAnswerConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutAnswerConceptInput | ConceptAnswerCreateOrConnectWithoutAnswerConceptInput[]
    upsert?: ConceptAnswerUpsertWithWhereUniqueWithoutAnswerConceptInput | ConceptAnswerUpsertWithWhereUniqueWithoutAnswerConceptInput[]
    createMany?: ConceptAnswerCreateManyAnswerConceptInputEnvelope
    set?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    disconnect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    delete?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    update?: ConceptAnswerUpdateWithWhereUniqueWithoutAnswerConceptInput | ConceptAnswerUpdateWithWhereUniqueWithoutAnswerConceptInput[]
    updateMany?: ConceptAnswerUpdateManyWithWhereWithoutAnswerConceptInput | ConceptAnswerUpdateManyWithWhereWithoutAnswerConceptInput[]
    deleteMany?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
  }

  export type FieldUpdateManyWithoutConceptNestedInput = {
    create?: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput> | FieldCreateWithoutConceptInput[] | FieldUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutConceptInput | FieldCreateOrConnectWithoutConceptInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutConceptInput | FieldUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: FieldCreateManyConceptInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutConceptInput | FieldUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutConceptInput | FieldUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type ObsUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput> | ObsCreateWithoutConceptInput[] | ObsUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutConceptInput | ObsCreateOrConnectWithoutConceptInput[]
    upsert?: ObsUpsertWithWhereUniqueWithoutConceptInput | ObsUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ObsCreateManyConceptInputEnvelope
    set?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    disconnect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    delete?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    update?: ObsUpdateWithWhereUniqueWithoutConceptInput | ObsUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ObsUpdateManyWithWhereWithoutConceptInput | ObsUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ObsScalarWhereInput | ObsScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutConceptNestedInput = {
    create?: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput> | OrderCreateWithoutConceptInput[] | OrderUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutConceptInput | OrderCreateOrConnectWithoutConceptInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutConceptInput | OrderUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: OrderCreateManyConceptInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutConceptInput | OrderUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutConceptInput | OrderUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ConceptClassUpdateOneWithoutConceptListNestedInput = {
    create?: XOR<ConceptClassCreateWithoutConceptListInput, ConceptClassUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptClassCreateOrConnectWithoutConceptListInput
    upsert?: ConceptClassUpsertWithoutConceptListInput
    disconnect?: ConceptClassWhereInput | boolean
    delete?: ConceptClassWhereInput | boolean
    connect?: ConceptClassWhereUniqueInput
    update?: XOR<XOR<ConceptClassUpdateToOneWithWhereWithoutConceptListInput, ConceptClassUpdateWithoutConceptListInput>, ConceptClassUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptDatatypeUpdateOneWithoutConceptListNestedInput = {
    create?: XOR<ConceptDatatypeCreateWithoutConceptListInput, ConceptDatatypeUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptDatatypeCreateOrConnectWithoutConceptListInput
    upsert?: ConceptDatatypeUpsertWithoutConceptListInput
    disconnect?: ConceptDatatypeWhereInput | boolean
    delete?: ConceptDatatypeWhereInput | boolean
    connect?: ConceptDatatypeWhereUniqueInput
    update?: XOR<XOR<ConceptDatatypeUpdateToOneWithWhereWithoutConceptListInput, ConceptDatatypeUpdateWithoutConceptListInput>, ConceptDatatypeUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptMapUpdateOneWithoutConceptListNestedInput = {
    create?: XOR<ConceptMapCreateWithoutConceptListInput, ConceptMapUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptMapCreateOrConnectWithoutConceptListInput
    upsert?: ConceptMapUpsertWithoutConceptListInput
    disconnect?: ConceptMapWhereInput | boolean
    delete?: ConceptMapWhereInput | boolean
    connect?: ConceptMapWhereUniqueInput
    update?: XOR<XOR<ConceptMapUpdateToOneWithWhereWithoutConceptListInput, ConceptMapUpdateWithoutConceptListInput>, ConceptMapUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptNameUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput> | ConceptNameCreateWithoutConceptInput[] | ConceptNameUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNameCreateOrConnectWithoutConceptInput | ConceptNameCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptNameUpsertWithWhereUniqueWithoutConceptInput | ConceptNameUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptNameCreateManyConceptInputEnvelope
    set?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    disconnect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    delete?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    connect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    update?: ConceptNameUpdateWithWhereUniqueWithoutConceptInput | ConceptNameUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptNameUpdateManyWithWhereWithoutConceptInput | ConceptNameUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptNameScalarWhereInput | ConceptNameScalarWhereInput[]
  }

  export type ConceptNumericUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput> | ConceptNumericCreateWithoutConceptInput[] | ConceptNumericUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNumericCreateOrConnectWithoutConceptInput | ConceptNumericCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptNumericUpsertWithWhereUniqueWithoutConceptInput | ConceptNumericUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptNumericCreateManyConceptInputEnvelope
    set?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    disconnect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    delete?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    connect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    update?: ConceptNumericUpdateWithWhereUniqueWithoutConceptInput | ConceptNumericUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptNumericUpdateManyWithWhereWithoutConceptInput | ConceptNumericUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptNumericScalarWhereInput | ConceptNumericScalarWhereInput[]
  }

  export type ConceptProposalUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput> | ConceptProposalCreateWithoutConceptInput[] | ConceptProposalUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptProposalCreateOrConnectWithoutConceptInput | ConceptProposalCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptProposalUpsertWithWhereUniqueWithoutConceptInput | ConceptProposalUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptProposalCreateManyConceptInputEnvelope
    set?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    disconnect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    delete?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    connect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    update?: ConceptProposalUpdateWithWhereUniqueWithoutConceptInput | ConceptProposalUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptProposalUpdateManyWithWhereWithoutConceptInput | ConceptProposalUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptProposalScalarWhereInput | ConceptProposalScalarWhereInput[]
  }

  export type ConceptSetUpdateOneWithoutConceptListNestedInput = {
    create?: XOR<ConceptSetCreateWithoutConceptListInput, ConceptSetUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptSetCreateOrConnectWithoutConceptListInput
    upsert?: ConceptSetUpsertWithoutConceptListInput
    disconnect?: ConceptSetWhereInput | boolean
    delete?: ConceptSetWhereInput | boolean
    connect?: ConceptSetWhereUniqueInput
    update?: XOR<XOR<ConceptSetUpdateToOneWithWhereWithoutConceptListInput, ConceptSetUpdateWithoutConceptListInput>, ConceptSetUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptSourceUpdateOneWithoutConceptListNestedInput = {
    create?: XOR<ConceptSourceCreateWithoutConceptListInput, ConceptSourceUncheckedCreateWithoutConceptListInput>
    connectOrCreate?: ConceptSourceCreateOrConnectWithoutConceptListInput
    upsert?: ConceptSourceUpsertWithoutConceptListInput
    disconnect?: ConceptSourceWhereInput | boolean
    delete?: ConceptSourceWhereInput | boolean
    connect?: ConceptSourceWhereUniqueInput
    update?: XOR<XOR<ConceptSourceUpdateToOneWithWhereWithoutConceptListInput, ConceptSourceUpdateWithoutConceptListInput>, ConceptSourceUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptWordUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput> | ConceptWordCreateWithoutConceptInput[] | ConceptWordUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptWordCreateOrConnectWithoutConceptInput | ConceptWordCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptWordUpsertWithWhereUniqueWithoutConceptInput | ConceptWordUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptWordCreateManyConceptInputEnvelope
    set?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    disconnect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    delete?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    connect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    update?: ConceptWordUpdateWithWhereUniqueWithoutConceptInput | ConceptWordUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptWordUpdateManyWithWhereWithoutConceptInput | ConceptWordUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptWordScalarWhereInput | ConceptWordScalarWhereInput[]
  }

  export type ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput> | ConceptAnswerCreateWithoutConceptInput[] | ConceptAnswerUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutConceptInput | ConceptAnswerCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptAnswerUpsertWithWhereUniqueWithoutConceptInput | ConceptAnswerUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptAnswerCreateManyConceptInputEnvelope
    set?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    disconnect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    delete?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    update?: ConceptAnswerUpdateWithWhereUniqueWithoutConceptInput | ConceptAnswerUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptAnswerUpdateManyWithWhereWithoutConceptInput | ConceptAnswerUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
  }

  export type ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput = {
    create?: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput> | ConceptAnswerCreateWithoutAnswerConceptInput[] | ConceptAnswerUncheckedCreateWithoutAnswerConceptInput[]
    connectOrCreate?: ConceptAnswerCreateOrConnectWithoutAnswerConceptInput | ConceptAnswerCreateOrConnectWithoutAnswerConceptInput[]
    upsert?: ConceptAnswerUpsertWithWhereUniqueWithoutAnswerConceptInput | ConceptAnswerUpsertWithWhereUniqueWithoutAnswerConceptInput[]
    createMany?: ConceptAnswerCreateManyAnswerConceptInputEnvelope
    set?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    disconnect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    delete?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    connect?: ConceptAnswerWhereUniqueInput | ConceptAnswerWhereUniqueInput[]
    update?: ConceptAnswerUpdateWithWhereUniqueWithoutAnswerConceptInput | ConceptAnswerUpdateWithWhereUniqueWithoutAnswerConceptInput[]
    updateMany?: ConceptAnswerUpdateManyWithWhereWithoutAnswerConceptInput | ConceptAnswerUpdateManyWithWhereWithoutAnswerConceptInput[]
    deleteMany?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
  }

  export type FieldUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput> | FieldCreateWithoutConceptInput[] | FieldUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutConceptInput | FieldCreateOrConnectWithoutConceptInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutConceptInput | FieldUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: FieldCreateManyConceptInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutConceptInput | FieldUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutConceptInput | FieldUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type ObsUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput> | ObsCreateWithoutConceptInput[] | ObsUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ObsCreateOrConnectWithoutConceptInput | ObsCreateOrConnectWithoutConceptInput[]
    upsert?: ObsUpsertWithWhereUniqueWithoutConceptInput | ObsUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ObsCreateManyConceptInputEnvelope
    set?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    disconnect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    delete?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    connect?: ObsWhereUniqueInput | ObsWhereUniqueInput[]
    update?: ObsUpdateWithWhereUniqueWithoutConceptInput | ObsUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ObsUpdateManyWithWhereWithoutConceptInput | ObsUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ObsScalarWhereInput | ObsScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput> | OrderCreateWithoutConceptInput[] | OrderUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutConceptInput | OrderCreateOrConnectWithoutConceptInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutConceptInput | OrderUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: OrderCreateManyConceptInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutConceptInput | OrderUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutConceptInput | OrderUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ConceptNameUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput> | ConceptNameCreateWithoutConceptInput[] | ConceptNameUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNameCreateOrConnectWithoutConceptInput | ConceptNameCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptNameUpsertWithWhereUniqueWithoutConceptInput | ConceptNameUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptNameCreateManyConceptInputEnvelope
    set?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    disconnect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    delete?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    connect?: ConceptNameWhereUniqueInput | ConceptNameWhereUniqueInput[]
    update?: ConceptNameUpdateWithWhereUniqueWithoutConceptInput | ConceptNameUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptNameUpdateManyWithWhereWithoutConceptInput | ConceptNameUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptNameScalarWhereInput | ConceptNameScalarWhereInput[]
  }

  export type ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput> | ConceptNumericCreateWithoutConceptInput[] | ConceptNumericUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptNumericCreateOrConnectWithoutConceptInput | ConceptNumericCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptNumericUpsertWithWhereUniqueWithoutConceptInput | ConceptNumericUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptNumericCreateManyConceptInputEnvelope
    set?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    disconnect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    delete?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    connect?: ConceptNumericWhereUniqueInput | ConceptNumericWhereUniqueInput[]
    update?: ConceptNumericUpdateWithWhereUniqueWithoutConceptInput | ConceptNumericUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptNumericUpdateManyWithWhereWithoutConceptInput | ConceptNumericUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptNumericScalarWhereInput | ConceptNumericScalarWhereInput[]
  }

  export type ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput> | ConceptProposalCreateWithoutConceptInput[] | ConceptProposalUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptProposalCreateOrConnectWithoutConceptInput | ConceptProposalCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptProposalUpsertWithWhereUniqueWithoutConceptInput | ConceptProposalUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptProposalCreateManyConceptInputEnvelope
    set?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    disconnect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    delete?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    connect?: ConceptProposalWhereUniqueInput | ConceptProposalWhereUniqueInput[]
    update?: ConceptProposalUpdateWithWhereUniqueWithoutConceptInput | ConceptProposalUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptProposalUpdateManyWithWhereWithoutConceptInput | ConceptProposalUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptProposalScalarWhereInput | ConceptProposalScalarWhereInput[]
  }

  export type ConceptWordUncheckedUpdateManyWithoutConceptNestedInput = {
    create?: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput> | ConceptWordCreateWithoutConceptInput[] | ConceptWordUncheckedCreateWithoutConceptInput[]
    connectOrCreate?: ConceptWordCreateOrConnectWithoutConceptInput | ConceptWordCreateOrConnectWithoutConceptInput[]
    upsert?: ConceptWordUpsertWithWhereUniqueWithoutConceptInput | ConceptWordUpsertWithWhereUniqueWithoutConceptInput[]
    createMany?: ConceptWordCreateManyConceptInputEnvelope
    set?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    disconnect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    delete?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    connect?: ConceptWordWhereUniqueInput | ConceptWordWhereUniqueInput[]
    update?: ConceptWordUpdateWithWhereUniqueWithoutConceptInput | ConceptWordUpdateWithWhereUniqueWithoutConceptInput[]
    updateMany?: ConceptWordUpdateManyWithWhereWithoutConceptInput | ConceptWordUpdateManyWithWhereWithoutConceptInput[]
    deleteMany?: ConceptWordScalarWhereInput | ConceptWordScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutMetaListInput = {
    create?: XOR<ConceptCreateWithoutMetaListInput, ConceptUncheckedCreateWithoutMetaListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutMetaListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptCreateNestedOneWithoutAnswerListInput = {
    create?: XOR<ConceptCreateWithoutAnswerListInput, ConceptUncheckedCreateWithoutAnswerListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutAnswerListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutMetaListNestedInput = {
    create?: XOR<ConceptCreateWithoutMetaListInput, ConceptUncheckedCreateWithoutMetaListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutMetaListInput
    upsert?: ConceptUpsertWithoutMetaListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutMetaListInput, ConceptUpdateWithoutMetaListInput>, ConceptUncheckedUpdateWithoutMetaListInput>
  }

  export type ConceptUpdateOneRequiredWithoutAnswerListNestedInput = {
    create?: XOR<ConceptCreateWithoutAnswerListInput, ConceptUncheckedCreateWithoutAnswerListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutAnswerListInput
    upsert?: ConceptUpsertWithoutAnswerListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutAnswerListInput, ConceptUpdateWithoutAnswerListInput>, ConceptUncheckedUpdateWithoutAnswerListInput>
  }

  export type ConceptCreateNestedManyWithoutConceptClassInput = {
    create?: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput> | ConceptCreateWithoutConceptClassInput[] | ConceptUncheckedCreateWithoutConceptClassInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptClassInput | ConceptCreateOrConnectWithoutConceptClassInput[]
    createMany?: ConceptCreateManyConceptClassInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUncheckedCreateNestedManyWithoutConceptClassInput = {
    create?: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput> | ConceptCreateWithoutConceptClassInput[] | ConceptUncheckedCreateWithoutConceptClassInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptClassInput | ConceptCreateOrConnectWithoutConceptClassInput[]
    createMany?: ConceptCreateManyConceptClassInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUpdateManyWithoutConceptClassNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput> | ConceptCreateWithoutConceptClassInput[] | ConceptUncheckedCreateWithoutConceptClassInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptClassInput | ConceptCreateOrConnectWithoutConceptClassInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptClassInput | ConceptUpsertWithWhereUniqueWithoutConceptClassInput[]
    createMany?: ConceptCreateManyConceptClassInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptClassInput | ConceptUpdateWithWhereUniqueWithoutConceptClassInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptClassInput | ConceptUpdateManyWithWhereWithoutConceptClassInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptUncheckedUpdateManyWithoutConceptClassNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput> | ConceptCreateWithoutConceptClassInput[] | ConceptUncheckedCreateWithoutConceptClassInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptClassInput | ConceptCreateOrConnectWithoutConceptClassInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptClassInput | ConceptUpsertWithWhereUniqueWithoutConceptClassInput[]
    createMany?: ConceptCreateManyConceptClassInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptClassInput | ConceptUpdateWithWhereUniqueWithoutConceptClassInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptClassInput | ConceptUpdateManyWithWhereWithoutConceptClassInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptCreateNestedManyWithoutConceptDatatypeInput = {
    create?: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput> | ConceptCreateWithoutConceptDatatypeInput[] | ConceptUncheckedCreateWithoutConceptDatatypeInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptDatatypeInput | ConceptCreateOrConnectWithoutConceptDatatypeInput[]
    createMany?: ConceptCreateManyConceptDatatypeInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUncheckedCreateNestedManyWithoutConceptDatatypeInput = {
    create?: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput> | ConceptCreateWithoutConceptDatatypeInput[] | ConceptUncheckedCreateWithoutConceptDatatypeInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptDatatypeInput | ConceptCreateOrConnectWithoutConceptDatatypeInput[]
    createMany?: ConceptCreateManyConceptDatatypeInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUpdateManyWithoutConceptDatatypeNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput> | ConceptCreateWithoutConceptDatatypeInput[] | ConceptUncheckedCreateWithoutConceptDatatypeInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptDatatypeInput | ConceptCreateOrConnectWithoutConceptDatatypeInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptDatatypeInput | ConceptUpsertWithWhereUniqueWithoutConceptDatatypeInput[]
    createMany?: ConceptCreateManyConceptDatatypeInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptDatatypeInput | ConceptUpdateWithWhereUniqueWithoutConceptDatatypeInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptDatatypeInput | ConceptUpdateManyWithWhereWithoutConceptDatatypeInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptUncheckedUpdateManyWithoutConceptDatatypeNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput> | ConceptCreateWithoutConceptDatatypeInput[] | ConceptUncheckedCreateWithoutConceptDatatypeInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptDatatypeInput | ConceptCreateOrConnectWithoutConceptDatatypeInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptDatatypeInput | ConceptUpsertWithWhereUniqueWithoutConceptDatatypeInput[]
    createMany?: ConceptCreateManyConceptDatatypeInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptDatatypeInput | ConceptUpdateWithWhereUniqueWithoutConceptDatatypeInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptDatatypeInput | ConceptUpdateManyWithWhereWithoutConceptDatatypeInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptCreateNestedManyWithoutConceptMapInput = {
    create?: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput> | ConceptCreateWithoutConceptMapInput[] | ConceptUncheckedCreateWithoutConceptMapInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptMapInput | ConceptCreateOrConnectWithoutConceptMapInput[]
    createMany?: ConceptCreateManyConceptMapInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUncheckedCreateNestedManyWithoutConceptMapInput = {
    create?: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput> | ConceptCreateWithoutConceptMapInput[] | ConceptUncheckedCreateWithoutConceptMapInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptMapInput | ConceptCreateOrConnectWithoutConceptMapInput[]
    createMany?: ConceptCreateManyConceptMapInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUpdateManyWithoutConceptMapNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput> | ConceptCreateWithoutConceptMapInput[] | ConceptUncheckedCreateWithoutConceptMapInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptMapInput | ConceptCreateOrConnectWithoutConceptMapInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptMapInput | ConceptUpsertWithWhereUniqueWithoutConceptMapInput[]
    createMany?: ConceptCreateManyConceptMapInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptMapInput | ConceptUpdateWithWhereUniqueWithoutConceptMapInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptMapInput | ConceptUpdateManyWithWhereWithoutConceptMapInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptUncheckedUpdateManyWithoutConceptMapNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput> | ConceptCreateWithoutConceptMapInput[] | ConceptUncheckedCreateWithoutConceptMapInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptMapInput | ConceptCreateOrConnectWithoutConceptMapInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptMapInput | ConceptUpsertWithWhereUniqueWithoutConceptMapInput[]
    createMany?: ConceptCreateManyConceptMapInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptMapInput | ConceptUpdateWithWhereUniqueWithoutConceptMapInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptMapInput | ConceptUpdateManyWithWhereWithoutConceptMapInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutConceptNameListInput = {
    create?: XOR<ConceptCreateWithoutConceptNameListInput, ConceptUncheckedCreateWithoutConceptNameListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptNameListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutConceptNameListNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptNameListInput, ConceptUncheckedCreateWithoutConceptNameListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptNameListInput
    upsert?: ConceptUpsertWithoutConceptNameListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutConceptNameListInput, ConceptUpdateWithoutConceptNameListInput>, ConceptUncheckedUpdateWithoutConceptNameListInput>
  }

  export type ConceptCreateNestedOneWithoutConceptNumericListInput = {
    create?: XOR<ConceptCreateWithoutConceptNumericListInput, ConceptUncheckedCreateWithoutConceptNumericListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptNumericListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutConceptNumericListNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptNumericListInput, ConceptUncheckedCreateWithoutConceptNumericListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptNumericListInput
    upsert?: ConceptUpsertWithoutConceptNumericListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutConceptNumericListInput, ConceptUpdateWithoutConceptNumericListInput>, ConceptUncheckedUpdateWithoutConceptNumericListInput>
  }

  export type ConceptCreateNestedOneWithoutConceptProposalListInput = {
    create?: XOR<ConceptCreateWithoutConceptProposalListInput, ConceptUncheckedCreateWithoutConceptProposalListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptProposalListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutConceptProposalListNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptProposalListInput, ConceptUncheckedCreateWithoutConceptProposalListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptProposalListInput
    upsert?: ConceptUpsertWithoutConceptProposalListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutConceptProposalListInput, ConceptUpdateWithoutConceptProposalListInput>, ConceptUncheckedUpdateWithoutConceptProposalListInput>
  }

  export type ConceptCreateNestedManyWithoutConceptSetInput = {
    create?: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput> | ConceptCreateWithoutConceptSetInput[] | ConceptUncheckedCreateWithoutConceptSetInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSetInput | ConceptCreateOrConnectWithoutConceptSetInput[]
    createMany?: ConceptCreateManyConceptSetInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUncheckedCreateNestedManyWithoutConceptSetInput = {
    create?: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput> | ConceptCreateWithoutConceptSetInput[] | ConceptUncheckedCreateWithoutConceptSetInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSetInput | ConceptCreateOrConnectWithoutConceptSetInput[]
    createMany?: ConceptCreateManyConceptSetInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUpdateManyWithoutConceptSetNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput> | ConceptCreateWithoutConceptSetInput[] | ConceptUncheckedCreateWithoutConceptSetInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSetInput | ConceptCreateOrConnectWithoutConceptSetInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptSetInput | ConceptUpsertWithWhereUniqueWithoutConceptSetInput[]
    createMany?: ConceptCreateManyConceptSetInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptSetInput | ConceptUpdateWithWhereUniqueWithoutConceptSetInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptSetInput | ConceptUpdateManyWithWhereWithoutConceptSetInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptUncheckedUpdateManyWithoutConceptSetNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput> | ConceptCreateWithoutConceptSetInput[] | ConceptUncheckedCreateWithoutConceptSetInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSetInput | ConceptCreateOrConnectWithoutConceptSetInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptSetInput | ConceptUpsertWithWhereUniqueWithoutConceptSetInput[]
    createMany?: ConceptCreateManyConceptSetInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptSetInput | ConceptUpdateWithWhereUniqueWithoutConceptSetInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptSetInput | ConceptUpdateManyWithWhereWithoutConceptSetInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptCreateNestedManyWithoutConceptSourceInput = {
    create?: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput> | ConceptCreateWithoutConceptSourceInput[] | ConceptUncheckedCreateWithoutConceptSourceInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSourceInput | ConceptCreateOrConnectWithoutConceptSourceInput[]
    createMany?: ConceptCreateManyConceptSourceInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUncheckedCreateNestedManyWithoutConceptSourceInput = {
    create?: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput> | ConceptCreateWithoutConceptSourceInput[] | ConceptUncheckedCreateWithoutConceptSourceInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSourceInput | ConceptCreateOrConnectWithoutConceptSourceInput[]
    createMany?: ConceptCreateManyConceptSourceInputEnvelope
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
  }

  export type ConceptUpdateManyWithoutConceptSourceNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput> | ConceptCreateWithoutConceptSourceInput[] | ConceptUncheckedCreateWithoutConceptSourceInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSourceInput | ConceptCreateOrConnectWithoutConceptSourceInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptSourceInput | ConceptUpsertWithWhereUniqueWithoutConceptSourceInput[]
    createMany?: ConceptCreateManyConceptSourceInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptSourceInput | ConceptUpdateWithWhereUniqueWithoutConceptSourceInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptSourceInput | ConceptUpdateManyWithWhereWithoutConceptSourceInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptUncheckedUpdateManyWithoutConceptSourceNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput> | ConceptCreateWithoutConceptSourceInput[] | ConceptUncheckedCreateWithoutConceptSourceInput[]
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptSourceInput | ConceptCreateOrConnectWithoutConceptSourceInput[]
    upsert?: ConceptUpsertWithWhereUniqueWithoutConceptSourceInput | ConceptUpsertWithWhereUniqueWithoutConceptSourceInput[]
    createMany?: ConceptCreateManyConceptSourceInputEnvelope
    set?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    disconnect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    delete?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    connect?: ConceptWhereUniqueInput | ConceptWhereUniqueInput[]
    update?: ConceptUpdateWithWhereUniqueWithoutConceptSourceInput | ConceptUpdateWithWhereUniqueWithoutConceptSourceInput[]
    updateMany?: ConceptUpdateManyWithWhereWithoutConceptSourceInput | ConceptUpdateManyWithWhereWithoutConceptSourceInput[]
    deleteMany?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutConceptWordListInput = {
    create?: XOR<ConceptCreateWithoutConceptWordListInput, ConceptUncheckedCreateWithoutConceptWordListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptWordListInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptUpdateOneRequiredWithoutConceptWordListNestedInput = {
    create?: XOR<ConceptCreateWithoutConceptWordListInput, ConceptUncheckedCreateWithoutConceptWordListInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutConceptWordListInput
    upsert?: ConceptUpsertWithoutConceptWordListInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutConceptWordListInput, ConceptUpdateWithoutConceptWordListInput>, ConceptUncheckedUpdateWithoutConceptWordListInput>
  }

  export type FormResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput> | FormResourceCreateWithoutResourceInput[] | FormResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutResourceInput | FormResourceCreateOrConnectWithoutResourceInput[]
    createMany?: FormResourceCreateManyResourceInputEnvelope
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
  }

  export type FormResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput> | FormResourceCreateWithoutResourceInput[] | FormResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutResourceInput | FormResourceCreateOrConnectWithoutResourceInput[]
    createMany?: FormResourceCreateManyResourceInputEnvelope
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
  }

  export type FormResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput> | FormResourceCreateWithoutResourceInput[] | FormResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutResourceInput | FormResourceCreateOrConnectWithoutResourceInput[]
    upsert?: FormResourceUpsertWithWhereUniqueWithoutResourceInput | FormResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: FormResourceCreateManyResourceInputEnvelope
    set?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    disconnect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    delete?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    update?: FormResourceUpdateWithWhereUniqueWithoutResourceInput | FormResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: FormResourceUpdateManyWithWhereWithoutResourceInput | FormResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
  }

  export type FormResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput> | FormResourceCreateWithoutResourceInput[] | FormResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: FormResourceCreateOrConnectWithoutResourceInput | FormResourceCreateOrConnectWithoutResourceInput[]
    upsert?: FormResourceUpsertWithWhereUniqueWithoutResourceInput | FormResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: FormResourceCreateManyResourceInputEnvelope
    set?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    disconnect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    delete?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    connect?: FormResourceWhereUniqueInput | FormResourceWhereUniqueInput[]
    update?: FormResourceUpdateWithWhereUniqueWithoutResourceInput | FormResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: FormResourceUpdateManyWithWhereWithoutResourceInput | FormResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
  }

  export type BlogPostAuthorCreateNestedOneWithoutBlogPostListInput = {
    create?: XOR<BlogPostAuthorCreateWithoutBlogPostListInput, BlogPostAuthorUncheckedCreateWithoutBlogPostListInput>
    connectOrCreate?: BlogPostAuthorCreateOrConnectWithoutBlogPostListInput
    connect?: BlogPostAuthorWhereUniqueInput
  }

  export type SpaceTimeCoordinatesCreateNestedOneWithoutBlogPostInput = {
    create?: XOR<SpaceTimeCoordinatesCreateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SpaceTimeCoordinatesCreateOrConnectWithoutBlogPostInput
    connect?: SpaceTimeCoordinatesWhereUniqueInput
  }

  export type BlogPostTagArrowCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput> | BlogPostTagArrowCreateWithoutPostInput[] | BlogPostTagArrowUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutPostInput | BlogPostTagArrowCreateOrConnectWithoutPostInput[]
    createMany?: BlogPostTagArrowCreateManyPostInputEnvelope
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
  }

  export type BlogPostTagArrowUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput> | BlogPostTagArrowCreateWithoutPostInput[] | BlogPostTagArrowUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutPostInput | BlogPostTagArrowCreateOrConnectWithoutPostInput[]
    createMany?: BlogPostTagArrowCreateManyPostInputEnvelope
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
  }

  export type BlogPostAuthorUpdateOneRequiredWithoutBlogPostListNestedInput = {
    create?: XOR<BlogPostAuthorCreateWithoutBlogPostListInput, BlogPostAuthorUncheckedCreateWithoutBlogPostListInput>
    connectOrCreate?: BlogPostAuthorCreateOrConnectWithoutBlogPostListInput
    upsert?: BlogPostAuthorUpsertWithoutBlogPostListInput
    connect?: BlogPostAuthorWhereUniqueInput
    update?: XOR<XOR<BlogPostAuthorUpdateToOneWithWhereWithoutBlogPostListInput, BlogPostAuthorUpdateWithoutBlogPostListInput>, BlogPostAuthorUncheckedUpdateWithoutBlogPostListInput>
  }

  export type SpaceTimeCoordinatesUpdateOneRequiredWithoutBlogPostNestedInput = {
    create?: XOR<SpaceTimeCoordinatesCreateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedCreateWithoutBlogPostInput>
    connectOrCreate?: SpaceTimeCoordinatesCreateOrConnectWithoutBlogPostInput
    upsert?: SpaceTimeCoordinatesUpsertWithoutBlogPostInput
    connect?: SpaceTimeCoordinatesWhereUniqueInput
    update?: XOR<XOR<SpaceTimeCoordinatesUpdateToOneWithWhereWithoutBlogPostInput, SpaceTimeCoordinatesUpdateWithoutBlogPostInput>, SpaceTimeCoordinatesUncheckedUpdateWithoutBlogPostInput>
  }

  export type BlogPostTagArrowUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput> | BlogPostTagArrowCreateWithoutPostInput[] | BlogPostTagArrowUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutPostInput | BlogPostTagArrowCreateOrConnectWithoutPostInput[]
    upsert?: BlogPostTagArrowUpsertWithWhereUniqueWithoutPostInput | BlogPostTagArrowUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogPostTagArrowCreateManyPostInputEnvelope
    set?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    disconnect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    delete?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    update?: BlogPostTagArrowUpdateWithWhereUniqueWithoutPostInput | BlogPostTagArrowUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogPostTagArrowUpdateManyWithWhereWithoutPostInput | BlogPostTagArrowUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
  }

  export type BlogPostTagArrowUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput> | BlogPostTagArrowCreateWithoutPostInput[] | BlogPostTagArrowUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutPostInput | BlogPostTagArrowCreateOrConnectWithoutPostInput[]
    upsert?: BlogPostTagArrowUpsertWithWhereUniqueWithoutPostInput | BlogPostTagArrowUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BlogPostTagArrowCreateManyPostInputEnvelope
    set?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    disconnect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    delete?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    update?: BlogPostTagArrowUpdateWithWhereUniqueWithoutPostInput | BlogPostTagArrowUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BlogPostTagArrowUpdateManyWithWhereWithoutPostInput | BlogPostTagArrowUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
  }

  export type BlogPostTagArrowCreateNestedManyWithoutTagInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput> | BlogPostTagArrowCreateWithoutTagInput[] | BlogPostTagArrowUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutTagInput | BlogPostTagArrowCreateOrConnectWithoutTagInput[]
    createMany?: BlogPostTagArrowCreateManyTagInputEnvelope
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
  }

  export type BlogPostTagArrowUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput> | BlogPostTagArrowCreateWithoutTagInput[] | BlogPostTagArrowUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutTagInput | BlogPostTagArrowCreateOrConnectWithoutTagInput[]
    createMany?: BlogPostTagArrowCreateManyTagInputEnvelope
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
  }

  export type BlogPostTagArrowUpdateManyWithoutTagNestedInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput> | BlogPostTagArrowCreateWithoutTagInput[] | BlogPostTagArrowUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutTagInput | BlogPostTagArrowCreateOrConnectWithoutTagInput[]
    upsert?: BlogPostTagArrowUpsertWithWhereUniqueWithoutTagInput | BlogPostTagArrowUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BlogPostTagArrowCreateManyTagInputEnvelope
    set?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    disconnect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    delete?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    update?: BlogPostTagArrowUpdateWithWhereUniqueWithoutTagInput | BlogPostTagArrowUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BlogPostTagArrowUpdateManyWithWhereWithoutTagInput | BlogPostTagArrowUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
  }

  export type BlogPostTagArrowUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput> | BlogPostTagArrowCreateWithoutTagInput[] | BlogPostTagArrowUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BlogPostTagArrowCreateOrConnectWithoutTagInput | BlogPostTagArrowCreateOrConnectWithoutTagInput[]
    upsert?: BlogPostTagArrowUpsertWithWhereUniqueWithoutTagInput | BlogPostTagArrowUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BlogPostTagArrowCreateManyTagInputEnvelope
    set?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    disconnect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    delete?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    connect?: BlogPostTagArrowWhereUniqueInput | BlogPostTagArrowWhereUniqueInput[]
    update?: BlogPostTagArrowUpdateWithWhereUniqueWithoutTagInput | BlogPostTagArrowUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BlogPostTagArrowUpdateManyWithWhereWithoutTagInput | BlogPostTagArrowUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutTagArrowListInput = {
    create?: XOR<BlogPostCreateWithoutTagArrowListInput, BlogPostUncheckedCreateWithoutTagArrowListInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagArrowListInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostTagCreateNestedOneWithoutPostArrowListInput = {
    create?: XOR<BlogPostTagCreateWithoutPostArrowListInput, BlogPostTagUncheckedCreateWithoutPostArrowListInput>
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutPostArrowListInput
    connect?: BlogPostTagWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutTagArrowListNestedInput = {
    create?: XOR<BlogPostCreateWithoutTagArrowListInput, BlogPostUncheckedCreateWithoutTagArrowListInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutTagArrowListInput
    upsert?: BlogPostUpsertWithoutTagArrowListInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutTagArrowListInput, BlogPostUpdateWithoutTagArrowListInput>, BlogPostUncheckedUpdateWithoutTagArrowListInput>
  }

  export type BlogPostTagUpdateOneRequiredWithoutPostArrowListNestedInput = {
    create?: XOR<BlogPostTagCreateWithoutPostArrowListInput, BlogPostTagUncheckedCreateWithoutPostArrowListInput>
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutPostArrowListInput
    upsert?: BlogPostTagUpsertWithoutPostArrowListInput
    connect?: BlogPostTagWhereUniqueInput
    update?: XOR<XOR<BlogPostTagUpdateToOneWithWhereWithoutPostArrowListInput, BlogPostTagUpdateWithoutPostArrowListInput>, BlogPostTagUncheckedUpdateWithoutPostArrowListInput>
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutSpaceTimeCoordinatesInput = {
    create?: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSpaceTimeCoordinatesInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogPostUncheckedCreateNestedOneWithoutSpaceTimeCoordinatesInput = {
    create?: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSpaceTimeCoordinatesInput
    connect?: BlogPostWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlogPostUpdateOneWithoutSpaceTimeCoordinatesNestedInput = {
    create?: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSpaceTimeCoordinatesInput
    upsert?: BlogPostUpsertWithoutSpaceTimeCoordinatesInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSpaceTimeCoordinatesInput, BlogPostUpdateWithoutSpaceTimeCoordinatesInput>, BlogPostUncheckedUpdateWithoutSpaceTimeCoordinatesInput>
  }

  export type BlogPostUncheckedUpdateOneWithoutSpaceTimeCoordinatesNestedInput = {
    create?: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutSpaceTimeCoordinatesInput
    upsert?: BlogPostUpsertWithoutSpaceTimeCoordinatesInput
    disconnect?: BlogPostWhereInput | boolean
    delete?: BlogPostWhereInput | boolean
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutSpaceTimeCoordinatesInput, BlogPostUpdateWithoutSpaceTimeCoordinatesInput>, BlogPostUncheckedUpdateWithoutSpaceTimeCoordinatesInput>
  }

  export type ServiceCreateNestedOneWithoutEntryListInput = {
    create?: XOR<ServiceCreateWithoutEntryListInput, ServiceUncheckedCreateWithoutEntryListInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEntryListInput
    connect?: ServiceWhereUniqueInput
  }

  export type BudgetCreateNestedOneWithoutEntryListInput = {
    create?: XOR<BudgetCreateWithoutEntryListInput, BudgetUncheckedCreateWithoutEntryListInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutEntryListInput
    connect?: BudgetWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutEntryListNestedInput = {
    create?: XOR<ServiceCreateWithoutEntryListInput, ServiceUncheckedCreateWithoutEntryListInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEntryListInput
    upsert?: ServiceUpsertWithoutEntryListInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutEntryListInput, ServiceUpdateWithoutEntryListInput>, ServiceUncheckedUpdateWithoutEntryListInput>
  }

  export type BudgetUpdateOneRequiredWithoutEntryListNestedInput = {
    create?: XOR<BudgetCreateWithoutEntryListInput, BudgetUncheckedCreateWithoutEntryListInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutEntryListInput
    upsert?: BudgetUpsertWithoutEntryListInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutEntryListInput, BudgetUpdateWithoutEntryListInput>, BudgetUncheckedUpdateWithoutEntryListInput>
  }

  export type BudgetEntryCreateNestedManyWithoutServiceInput = {
    create?: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput> | BudgetEntryCreateWithoutServiceInput[] | BudgetEntryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutServiceInput | BudgetEntryCreateOrConnectWithoutServiceInput[]
    createMany?: BudgetEntryCreateManyServiceInputEnvelope
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
  }

  export type BudgetEntryUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput> | BudgetEntryCreateWithoutServiceInput[] | BudgetEntryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutServiceInput | BudgetEntryCreateOrConnectWithoutServiceInput[]
    createMany?: BudgetEntryCreateManyServiceInputEnvelope
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
  }

  export type BudgetEntryUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput> | BudgetEntryCreateWithoutServiceInput[] | BudgetEntryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutServiceInput | BudgetEntryCreateOrConnectWithoutServiceInput[]
    upsert?: BudgetEntryUpsertWithWhereUniqueWithoutServiceInput | BudgetEntryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BudgetEntryCreateManyServiceInputEnvelope
    set?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    disconnect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    delete?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    update?: BudgetEntryUpdateWithWhereUniqueWithoutServiceInput | BudgetEntryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BudgetEntryUpdateManyWithWhereWithoutServiceInput | BudgetEntryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
  }

  export type BudgetEntryUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput> | BudgetEntryCreateWithoutServiceInput[] | BudgetEntryUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutServiceInput | BudgetEntryCreateOrConnectWithoutServiceInput[]
    upsert?: BudgetEntryUpsertWithWhereUniqueWithoutServiceInput | BudgetEntryUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BudgetEntryCreateManyServiceInputEnvelope
    set?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    disconnect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    delete?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    update?: BudgetEntryUpdateWithWhereUniqueWithoutServiceInput | BudgetEntryUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BudgetEntryUpdateManyWithWhereWithoutServiceInput | BudgetEntryUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
  }

  export type BudgetEntryCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput> | BudgetEntryCreateWithoutBudgetInput[] | BudgetEntryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutBudgetInput | BudgetEntryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetEntryCreateManyBudgetInputEnvelope
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
  }

  export type ReportCreateNestedOneWithoutBudgetInput = {
    create?: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ReportCreateOrConnectWithoutBudgetInput
    connect?: ReportWhereUniqueInput
  }

  export type BudgetBudUserCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput> | BudgetBudUserCreateWithoutBudgetInput[] | BudgetBudUserUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutBudgetInput | BudgetBudUserCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetBudUserCreateManyBudgetInputEnvelope
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
  }

  export type BudgetEntryUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput> | BudgetEntryCreateWithoutBudgetInput[] | BudgetEntryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutBudgetInput | BudgetEntryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetEntryCreateManyBudgetInputEnvelope
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedOneWithoutBudgetInput = {
    create?: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ReportCreateOrConnectWithoutBudgetInput
    connect?: ReportWhereUniqueInput
  }

  export type BudgetBudUserUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput> | BudgetBudUserCreateWithoutBudgetInput[] | BudgetBudUserUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutBudgetInput | BudgetBudUserCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetBudUserCreateManyBudgetInputEnvelope
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
  }

  export type BudgetEntryUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput> | BudgetEntryCreateWithoutBudgetInput[] | BudgetEntryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutBudgetInput | BudgetEntryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetEntryUpsertWithWhereUniqueWithoutBudgetInput | BudgetEntryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetEntryCreateManyBudgetInputEnvelope
    set?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    disconnect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    delete?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    update?: BudgetEntryUpdateWithWhereUniqueWithoutBudgetInput | BudgetEntryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetEntryUpdateManyWithWhereWithoutBudgetInput | BudgetEntryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
  }

  export type ReportUpdateOneWithoutBudgetNestedInput = {
    create?: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ReportCreateOrConnectWithoutBudgetInput
    upsert?: ReportUpsertWithoutBudgetInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutBudgetInput, ReportUpdateWithoutBudgetInput>, ReportUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetBudUserUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput> | BudgetBudUserCreateWithoutBudgetInput[] | BudgetBudUserUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutBudgetInput | BudgetBudUserCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetBudUserUpsertWithWhereUniqueWithoutBudgetInput | BudgetBudUserUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetBudUserCreateManyBudgetInputEnvelope
    set?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    disconnect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    delete?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    update?: BudgetBudUserUpdateWithWhereUniqueWithoutBudgetInput | BudgetBudUserUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetBudUserUpdateManyWithWhereWithoutBudgetInput | BudgetBudUserUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
  }

  export type BudgetEntryUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput> | BudgetEntryCreateWithoutBudgetInput[] | BudgetEntryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetEntryCreateOrConnectWithoutBudgetInput | BudgetEntryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetEntryUpsertWithWhereUniqueWithoutBudgetInput | BudgetEntryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetEntryCreateManyBudgetInputEnvelope
    set?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    disconnect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    delete?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    connect?: BudgetEntryWhereUniqueInput | BudgetEntryWhereUniqueInput[]
    update?: BudgetEntryUpdateWithWhereUniqueWithoutBudgetInput | BudgetEntryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetEntryUpdateManyWithWhereWithoutBudgetInput | BudgetEntryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
  }

  export type ReportUncheckedUpdateOneWithoutBudgetNestedInput = {
    create?: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ReportCreateOrConnectWithoutBudgetInput
    upsert?: ReportUpsertWithoutBudgetInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutBudgetInput, ReportUpdateWithoutBudgetInput>, ReportUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetBudUserUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput> | BudgetBudUserCreateWithoutBudgetInput[] | BudgetBudUserUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutBudgetInput | BudgetBudUserCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetBudUserUpsertWithWhereUniqueWithoutBudgetInput | BudgetBudUserUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetBudUserCreateManyBudgetInputEnvelope
    set?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    disconnect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    delete?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    update?: BudgetBudUserUpdateWithWhereUniqueWithoutBudgetInput | BudgetBudUserUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetBudUserUpdateManyWithWhereWithoutBudgetInput | BudgetBudUserUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutReportInput = {
    create?: XOR<BudgetCreateWithoutReportInput, BudgetUncheckedCreateWithoutReportInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutReportInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<BudgetCreateWithoutReportInput, BudgetUncheckedCreateWithoutReportInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutReportInput
    upsert?: BudgetUpsertWithoutReportInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutReportInput, BudgetUpdateWithoutReportInput>, BudgetUncheckedUpdateWithoutReportInput>
  }

  export type BudgetBudUserCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput> | BudgetBudUserCreateWithoutUserInput[] | BudgetBudUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutUserInput | BudgetBudUserCreateOrConnectWithoutUserInput[]
    createMany?: BudgetBudUserCreateManyUserInputEnvelope
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
  }

  export type BudEventCreateNestedManyWithoutBudUserInput = {
    create?: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput> | BudEventCreateWithoutBudUserInput[] | BudEventUncheckedCreateWithoutBudUserInput[]
    connectOrCreate?: BudEventCreateOrConnectWithoutBudUserInput | BudEventCreateOrConnectWithoutBudUserInput[]
    createMany?: BudEventCreateManyBudUserInputEnvelope
    connect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
  }

  export type BudgetBudUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput> | BudgetBudUserCreateWithoutUserInput[] | BudgetBudUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutUserInput | BudgetBudUserCreateOrConnectWithoutUserInput[]
    createMany?: BudgetBudUserCreateManyUserInputEnvelope
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
  }

  export type BudEventUncheckedCreateNestedManyWithoutBudUserInput = {
    create?: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput> | BudEventCreateWithoutBudUserInput[] | BudEventUncheckedCreateWithoutBudUserInput[]
    connectOrCreate?: BudEventCreateOrConnectWithoutBudUserInput | BudEventCreateOrConnectWithoutBudUserInput[]
    createMany?: BudEventCreateManyBudUserInputEnvelope
    connect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
  }

  export type BudgetBudUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput> | BudgetBudUserCreateWithoutUserInput[] | BudgetBudUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutUserInput | BudgetBudUserCreateOrConnectWithoutUserInput[]
    upsert?: BudgetBudUserUpsertWithWhereUniqueWithoutUserInput | BudgetBudUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetBudUserCreateManyUserInputEnvelope
    set?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    disconnect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    delete?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    update?: BudgetBudUserUpdateWithWhereUniqueWithoutUserInput | BudgetBudUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetBudUserUpdateManyWithWhereWithoutUserInput | BudgetBudUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
  }

  export type BudEventUpdateManyWithoutBudUserNestedInput = {
    create?: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput> | BudEventCreateWithoutBudUserInput[] | BudEventUncheckedCreateWithoutBudUserInput[]
    connectOrCreate?: BudEventCreateOrConnectWithoutBudUserInput | BudEventCreateOrConnectWithoutBudUserInput[]
    upsert?: BudEventUpsertWithWhereUniqueWithoutBudUserInput | BudEventUpsertWithWhereUniqueWithoutBudUserInput[]
    createMany?: BudEventCreateManyBudUserInputEnvelope
    set?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    disconnect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    delete?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    connect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    update?: BudEventUpdateWithWhereUniqueWithoutBudUserInput | BudEventUpdateWithWhereUniqueWithoutBudUserInput[]
    updateMany?: BudEventUpdateManyWithWhereWithoutBudUserInput | BudEventUpdateManyWithWhereWithoutBudUserInput[]
    deleteMany?: BudEventScalarWhereInput | BudEventScalarWhereInput[]
  }

  export type BudgetBudUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput> | BudgetBudUserCreateWithoutUserInput[] | BudgetBudUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BudgetBudUserCreateOrConnectWithoutUserInput | BudgetBudUserCreateOrConnectWithoutUserInput[]
    upsert?: BudgetBudUserUpsertWithWhereUniqueWithoutUserInput | BudgetBudUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BudgetBudUserCreateManyUserInputEnvelope
    set?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    disconnect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    delete?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    connect?: BudgetBudUserWhereUniqueInput | BudgetBudUserWhereUniqueInput[]
    update?: BudgetBudUserUpdateWithWhereUniqueWithoutUserInput | BudgetBudUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BudgetBudUserUpdateManyWithWhereWithoutUserInput | BudgetBudUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
  }

  export type BudEventUncheckedUpdateManyWithoutBudUserNestedInput = {
    create?: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput> | BudEventCreateWithoutBudUserInput[] | BudEventUncheckedCreateWithoutBudUserInput[]
    connectOrCreate?: BudEventCreateOrConnectWithoutBudUserInput | BudEventCreateOrConnectWithoutBudUserInput[]
    upsert?: BudEventUpsertWithWhereUniqueWithoutBudUserInput | BudEventUpsertWithWhereUniqueWithoutBudUserInput[]
    createMany?: BudEventCreateManyBudUserInputEnvelope
    set?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    disconnect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    delete?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    connect?: BudEventWhereUniqueInput | BudEventWhereUniqueInput[]
    update?: BudEventUpdateWithWhereUniqueWithoutBudUserInput | BudEventUpdateWithWhereUniqueWithoutBudUserInput[]
    updateMany?: BudEventUpdateManyWithWhereWithoutBudUserInput | BudEventUpdateManyWithWhereWithoutBudUserInput[]
    deleteMany?: BudEventScalarWhereInput | BudEventScalarWhereInput[]
  }

  export type BudUserCreateNestedOneWithoutBudgetListInput = {
    create?: XOR<BudUserCreateWithoutBudgetListInput, BudUserUncheckedCreateWithoutBudgetListInput>
    connectOrCreate?: BudUserCreateOrConnectWithoutBudgetListInput
    connect?: BudUserWhereUniqueInput
  }

  export type BudgetCreateNestedOneWithoutUserListInput = {
    create?: XOR<BudgetCreateWithoutUserListInput, BudgetUncheckedCreateWithoutUserListInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutUserListInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudUserUpdateOneRequiredWithoutBudgetListNestedInput = {
    create?: XOR<BudUserCreateWithoutBudgetListInput, BudUserUncheckedCreateWithoutBudgetListInput>
    connectOrCreate?: BudUserCreateOrConnectWithoutBudgetListInput
    upsert?: BudUserUpsertWithoutBudgetListInput
    connect?: BudUserWhereUniqueInput
    update?: XOR<XOR<BudUserUpdateToOneWithWhereWithoutBudgetListInput, BudUserUpdateWithoutBudgetListInput>, BudUserUncheckedUpdateWithoutBudgetListInput>
  }

  export type BudgetUpdateOneRequiredWithoutUserListNestedInput = {
    create?: XOR<BudgetCreateWithoutUserListInput, BudgetUncheckedCreateWithoutUserListInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutUserListInput
    upsert?: BudgetUpsertWithoutUserListInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutUserListInput, BudgetUpdateWithoutUserListInput>, BudgetUncheckedUpdateWithoutUserListInput>
  }

  export type BudEventCreatecategoryListInput = {
    set: string[]
  }

  export type BudUserCreateNestedOneWithoutEventListInput = {
    create?: XOR<BudUserCreateWithoutEventListInput, BudUserUncheckedCreateWithoutEventListInput>
    connectOrCreate?: BudUserCreateOrConnectWithoutEventListInput
    connect?: BudUserWhereUniqueInput
  }

  export type BudEventUpdatecategoryListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BudUserUpdateOneRequiredWithoutEventListNestedInput = {
    create?: XOR<BudUserCreateWithoutEventListInput, BudUserUncheckedCreateWithoutEventListInput>
    connectOrCreate?: BudUserCreateOrConnectWithoutEventListInput
    upsert?: BudUserUpsertWithoutEventListInput
    connect?: BudUserWhereUniqueInput
    update?: XOR<XOR<BudUserUpdateToOneWithWhereWithoutEventListInput, BudUserUpdateWithoutEventListInput>, BudUserUncheckedUpdateWithoutEventListInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AppointmentTypeCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentTypeUncheckedCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    duration: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentTypeCreateOrConnectWithoutAppointmentListInput = {
    where: AppointmentTypeWhereUniqueInput
    create: XOR<AppointmentTypeCreateWithoutAppointmentListInput, AppointmentTypeUncheckedCreateWithoutAppointmentListInput>
  }

  export type PatientCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentListInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentListInput, PatientUncheckedCreateWithoutAppointmentListInput>
  }

  export type LocationCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAppointmentListInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAppointmentListInput, LocationUncheckedCreateWithoutAppointmentListInput>
  }

  export type ProviderCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutAppointmentListInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterList?: EncounterUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutAppointmentListInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutAppointmentListInput, ProviderUncheckedCreateWithoutAppointmentListInput>
  }

  export type AppointmentTypeUpsertWithoutAppointmentListInput = {
    update: XOR<AppointmentTypeUpdateWithoutAppointmentListInput, AppointmentTypeUncheckedUpdateWithoutAppointmentListInput>
    create: XOR<AppointmentTypeCreateWithoutAppointmentListInput, AppointmentTypeUncheckedCreateWithoutAppointmentListInput>
    where?: AppointmentTypeWhereInput
  }

  export type AppointmentTypeUpdateToOneWithWhereWithoutAppointmentListInput = {
    where?: AppointmentTypeWhereInput
    data: XOR<AppointmentTypeUpdateWithoutAppointmentListInput, AppointmentTypeUncheckedUpdateWithoutAppointmentListInput>
  }

  export type AppointmentTypeUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentTypeUncheckedUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutAppointmentListInput = {
    update: XOR<PatientUpdateWithoutAppointmentListInput, PatientUncheckedUpdateWithoutAppointmentListInput>
    create: XOR<PatientCreateWithoutAppointmentListInput, PatientUncheckedCreateWithoutAppointmentListInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentListInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentListInput, PatientUncheckedUpdateWithoutAppointmentListInput>
  }

  export type PatientUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LocationUpsertWithoutAppointmentListInput = {
    update: XOR<LocationUpdateWithoutAppointmentListInput, LocationUncheckedUpdateWithoutAppointmentListInput>
    create: XOR<LocationCreateWithoutAppointmentListInput, LocationUncheckedCreateWithoutAppointmentListInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAppointmentListInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAppointmentListInput, LocationUncheckedUpdateWithoutAppointmentListInput>
  }

  export type LocationUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ProviderUpsertWithoutAppointmentListInput = {
    update: XOR<ProviderUpdateWithoutAppointmentListInput, ProviderUncheckedUpdateWithoutAppointmentListInput>
    create: XOR<ProviderCreateWithoutAppointmentListInput, ProviderUncheckedCreateWithoutAppointmentListInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutAppointmentListInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutAppointmentListInput, ProviderUncheckedUpdateWithoutAppointmentListInput>
  }

  export type ProviderUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutAppointmentListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterList?: EncounterUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type AppointmentCreateWithoutAppointmentTypeInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentListInput
    location: LocationCreateNestedOneWithoutAppointmentListInput
    provider: ProviderCreateNestedOneWithoutAppointmentListInput
  }

  export type AppointmentUncheckedCreateWithoutAppointmentTypeInput = {
    id?: string
    uuid: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentCreateOrConnectWithoutAppointmentTypeInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput>
  }

  export type AppointmentCreateManyAppointmentTypeInputEnvelope = {
    data: AppointmentCreateManyAppointmentTypeInput | AppointmentCreateManyAppointmentTypeInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutAppointmentTypeInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutAppointmentTypeInput, AppointmentUncheckedUpdateWithoutAppointmentTypeInput>
    create: XOR<AppointmentCreateWithoutAppointmentTypeInput, AppointmentUncheckedCreateWithoutAppointmentTypeInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutAppointmentTypeInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutAppointmentTypeInput, AppointmentUncheckedUpdateWithoutAppointmentTypeInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutAppointmentTypeInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAppointmentTypeInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    uuid?: StringFilter<"Appointment"> | string
    appointmentTypeId?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    locationId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startDatetime?: DateTimeFilter<"Appointment"> | Date | string
    endDatetime?: DateTimeFilter<"Appointment"> | Date | string
    voided?: BoolFilter<"Appointment"> | boolean
    voidedBy?: StringFilter<"Appointment"> | string
    dateVoided?: DateTimeFilter<"Appointment"> | Date | string
    voidReason?: StringFilter<"Appointment"> | string
    creator?: StringFilter<"Appointment"> | string
    dateCreated?: DateTimeFilter<"Appointment"> | Date | string
    lastChangedBy?: StringFilter<"Appointment"> | string
    lastChangedDate?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentCreateWithoutLocationInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentType: AppointmentTypeCreateNestedOneWithoutAppointmentListInput
    patient: PatientCreateNestedOneWithoutAppointmentListInput
    provider: ProviderCreateNestedOneWithoutAppointmentListInput
  }

  export type AppointmentUncheckedCreateWithoutLocationInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentCreateOrConnectWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput>
  }

  export type AppointmentCreateManyLocationInputEnvelope = {
    data: AppointmentCreateManyLocationInput | AppointmentCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutLocationInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutLocationInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput>
  }

  export type EncounterCreateManyLocationInputEnvelope = {
    data: EncounterCreateManyLocationInput | EncounterCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutLocationInput, AppointmentUncheckedUpdateWithoutLocationInput>
    create: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutLocationInput, AppointmentUncheckedUpdateWithoutLocationInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutLocationInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutLocationInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutLocationInput, EncounterUncheckedUpdateWithoutLocationInput>
    create: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutLocationInput, EncounterUncheckedUpdateWithoutLocationInput>
  }

  export type EncounterUpdateManyWithWhereWithoutLocationInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutLocationInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    uuid?: StringFilter<"Encounter"> | string
    encounterTypeId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    locationId?: StringFilter<"Encounter"> | string
    formId?: StringFilter<"Encounter"> | string
    providerId?: StringFilter<"Encounter"> | string
    startDatetime?: DateTimeFilter<"Encounter"> | Date | string
    endDatetime?: DateTimeFilter<"Encounter"> | Date | string
    voided?: BoolFilter<"Encounter"> | boolean
    voidedBy?: StringFilter<"Encounter"> | string
    dateVoided?: DateTimeFilter<"Encounter"> | Date | string
    voidReason?: StringFilter<"Encounter"> | string
    creator?: StringFilter<"Encounter"> | string
    dateCreated?: DateTimeFilter<"Encounter"> | Date | string
    lastChangedBy?: StringFilter<"Encounter"> | string
    lastChangedDate?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentType: AppointmentTypeCreateNestedOneWithoutAppointmentListInput
    location: LocationCreateNestedOneWithoutAppointmentListInput
    provider: ProviderCreateNestedOneWithoutAppointmentListInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutPatientInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterCreateManyPatientInputEnvelope = {
    data: EncounterCreateManyPatientInput | EncounterCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientInput>
  }

  export type AppointmentCreateWithoutProviderInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentType: AppointmentTypeCreateNestedOneWithoutAppointmentListInput
    patient: PatientCreateNestedOneWithoutAppointmentListInput
    location: LocationCreateNestedOneWithoutAppointmentListInput
  }

  export type AppointmentUncheckedCreateWithoutProviderInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    locationId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentCreateOrConnectWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentCreateManyProviderInputEnvelope = {
    data: AppointmentCreateManyProviderInput | AppointmentCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutProviderInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutProviderInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput>
  }

  export type EncounterCreateManyProviderInputEnvelope = {
    data: EncounterCreateManyProviderInput | EncounterCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProviderInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutProviderInput, EncounterUncheckedUpdateWithoutProviderInput>
    create: XOR<EncounterCreateWithoutProviderInput, EncounterUncheckedCreateWithoutProviderInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutProviderInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutProviderInput, EncounterUncheckedUpdateWithoutProviderInput>
  }

  export type EncounterUpdateManyWithWhereWithoutProviderInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutProviderInput>
  }

  export type FormEncounterCreateWithoutFormInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounter: EncounterCreateNestedOneWithoutFormEncounterListInput
  }

  export type FormEncounterUncheckedCreateWithoutFormInput = {
    id?: string
    uuid: string
    encounterId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormEncounterCreateOrConnectWithoutFormInput = {
    where: FormEncounterWhereUniqueInput
    create: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput>
  }

  export type FormEncounterCreateManyFormInputEnvelope = {
    data: FormEncounterCreateManyFormInput | FormEncounterCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormResourceCreateWithoutFormInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    resource: ResourceCreateNestedOneWithoutFormResourceListInput
  }

  export type FormResourceUncheckedCreateWithoutFormInput = {
    id?: string
    uuid: string
    resourceId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceCreateOrConnectWithoutFormInput = {
    where: FormResourceWhereUniqueInput
    create: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput>
  }

  export type FormResourceCreateManyFormInputEnvelope = {
    data: FormResourceCreateManyFormInput | FormResourceCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutFormInput = {
    id?: string
    uuid: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounter: EncounterCreateNestedOneWithoutFormSubmissionListInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionUncheckedCreateWithoutFormInput = {
    id?: string
    uuid: string
    encounterId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionCreateOrConnectWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionCreateManyFormInputEnvelope = {
    data: FormSubmissionCreateManyFormInput | FormSubmissionCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FieldCreateWithoutFormListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutFieldListInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutFormListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutFormListInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFormListInput, FieldUncheckedCreateWithoutFormListInput>
  }

  export type EncounterCreateWithoutFormInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutFormInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutFormInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput>
  }

  export type EncounterCreateManyFormInputEnvelope = {
    data: EncounterCreateManyFormInput | EncounterCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormEncounterUpsertWithWhereUniqueWithoutFormInput = {
    where: FormEncounterWhereUniqueInput
    update: XOR<FormEncounterUpdateWithoutFormInput, FormEncounterUncheckedUpdateWithoutFormInput>
    create: XOR<FormEncounterCreateWithoutFormInput, FormEncounterUncheckedCreateWithoutFormInput>
  }

  export type FormEncounterUpdateWithWhereUniqueWithoutFormInput = {
    where: FormEncounterWhereUniqueInput
    data: XOR<FormEncounterUpdateWithoutFormInput, FormEncounterUncheckedUpdateWithoutFormInput>
  }

  export type FormEncounterUpdateManyWithWhereWithoutFormInput = {
    where: FormEncounterScalarWhereInput
    data: XOR<FormEncounterUpdateManyMutationInput, FormEncounterUncheckedUpdateManyWithoutFormInput>
  }

  export type FormEncounterScalarWhereInput = {
    AND?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
    OR?: FormEncounterScalarWhereInput[]
    NOT?: FormEncounterScalarWhereInput | FormEncounterScalarWhereInput[]
    id?: StringFilter<"FormEncounter"> | string
    uuid?: StringFilter<"FormEncounter"> | string
    formId?: StringFilter<"FormEncounter"> | string
    encounterId?: StringFilter<"FormEncounter"> | string
    creator?: StringFilter<"FormEncounter"> | string
    dateCreated?: DateTimeFilter<"FormEncounter"> | Date | string
    lastChangedBy?: StringFilter<"FormEncounter"> | string
    lastChangedDate?: DateTimeFilter<"FormEncounter"> | Date | string
  }

  export type FormResourceUpsertWithWhereUniqueWithoutFormInput = {
    where: FormResourceWhereUniqueInput
    update: XOR<FormResourceUpdateWithoutFormInput, FormResourceUncheckedUpdateWithoutFormInput>
    create: XOR<FormResourceCreateWithoutFormInput, FormResourceUncheckedCreateWithoutFormInput>
  }

  export type FormResourceUpdateWithWhereUniqueWithoutFormInput = {
    where: FormResourceWhereUniqueInput
    data: XOR<FormResourceUpdateWithoutFormInput, FormResourceUncheckedUpdateWithoutFormInput>
  }

  export type FormResourceUpdateManyWithWhereWithoutFormInput = {
    where: FormResourceScalarWhereInput
    data: XOR<FormResourceUpdateManyMutationInput, FormResourceUncheckedUpdateManyWithoutFormInput>
  }

  export type FormResourceScalarWhereInput = {
    AND?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
    OR?: FormResourceScalarWhereInput[]
    NOT?: FormResourceScalarWhereInput | FormResourceScalarWhereInput[]
    id?: StringFilter<"FormResource"> | string
    uuid?: StringFilter<"FormResource"> | string
    formId?: StringFilter<"FormResource"> | string
    resourceId?: StringFilter<"FormResource"> | string
    creator?: StringFilter<"FormResource"> | string
    dateCreated?: DateTimeFilter<"FormResource"> | Date | string
    lastChangedBy?: StringFilter<"FormResource"> | string
    lastChangedDate?: DateTimeFilter<"FormResource"> | Date | string
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
    create: XOR<FormSubmissionCreateWithoutFormInput, FormSubmissionUncheckedCreateWithoutFormInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutFormInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutFormInput, FormSubmissionUncheckedUpdateWithoutFormInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutFormInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutFormInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    id?: StringFilter<"FormSubmission"> | string
    uuid?: StringFilter<"FormSubmission"> | string
    formId?: StringFilter<"FormSubmission"> | string
    encounterId?: StringFilter<"FormSubmission"> | string
    submissionDate?: DateTimeFilter<"FormSubmission"> | Date | string
    creator?: StringFilter<"FormSubmission"> | string
    dateCreated?: DateTimeFilter<"FormSubmission"> | Date | string
    lastChangedBy?: StringFilter<"FormSubmission"> | string
    lastChangedDate?: DateTimeFilter<"FormSubmission"> | Date | string
  }

  export type FieldUpsertWithoutFormListInput = {
    update: XOR<FieldUpdateWithoutFormListInput, FieldUncheckedUpdateWithoutFormListInput>
    create: XOR<FieldCreateWithoutFormListInput, FieldUncheckedCreateWithoutFormListInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFormListInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFormListInput, FieldUncheckedUpdateWithoutFormListInput>
  }

  export type FieldUpdateWithoutFormListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutFieldListNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFormListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutFormInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutFormInput, EncounterUncheckedUpdateWithoutFormInput>
    create: XOR<EncounterCreateWithoutFormInput, EncounterUncheckedCreateWithoutFormInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutFormInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutFormInput, EncounterUncheckedUpdateWithoutFormInput>
  }

  export type EncounterUpdateManyWithWhereWithoutFormInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutFormInput>
  }

  export type FormCreateWithoutFormEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formResourceList?: FormResourceCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutFormInput
    dield?: FieldCreateNestedOneWithoutFormListInput
    encounterList?: EncounterCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutFormEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutFormEncounterListInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFormEncounterListInput, FormUncheckedCreateWithoutFormEncounterListInput>
  }

  export type EncounterCreateWithoutFormEncounterListInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutFormEncounterListInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutFormEncounterListInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutFormEncounterListInput, EncounterUncheckedCreateWithoutFormEncounterListInput>
  }

  export type FormUpsertWithoutFormEncounterListInput = {
    update: XOR<FormUpdateWithoutFormEncounterListInput, FormUncheckedUpdateWithoutFormEncounterListInput>
    create: XOR<FormCreateWithoutFormEncounterListInput, FormUncheckedCreateWithoutFormEncounterListInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutFormEncounterListInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutFormEncounterListInput, FormUncheckedUpdateWithoutFormEncounterListInput>
  }

  export type FormUpdateWithoutFormEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formResourceList?: FormResourceUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutFormNestedInput
    dield?: FieldUpdateOneWithoutFormListNestedInput
    encounterList?: EncounterUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutFormEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    formResourceList?: FormResourceUncheckedUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutFormNestedInput
  }

  export type EncounterUpsertWithoutFormEncounterListInput = {
    update: XOR<EncounterUpdateWithoutFormEncounterListInput, EncounterUncheckedUpdateWithoutFormEncounterListInput>
    create: XOR<EncounterCreateWithoutFormEncounterListInput, EncounterUncheckedCreateWithoutFormEncounterListInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutFormEncounterListInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutFormEncounterListInput, EncounterUncheckedUpdateWithoutFormEncounterListInput>
  }

  export type EncounterUpdateWithoutFormEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutFormEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type FormCreateWithoutFormResourceListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutFormInput
    dield?: FieldCreateNestedOneWithoutFormListInput
    encounterList?: EncounterCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutFormResourceListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutFormResourceListInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFormResourceListInput, FormUncheckedCreateWithoutFormResourceListInput>
  }

  export type ResourceCreateWithoutFormResourceListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ResourceUncheckedCreateWithoutFormResourceListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ResourceCreateOrConnectWithoutFormResourceListInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutFormResourceListInput, ResourceUncheckedCreateWithoutFormResourceListInput>
  }

  export type FormUpsertWithoutFormResourceListInput = {
    update: XOR<FormUpdateWithoutFormResourceListInput, FormUncheckedUpdateWithoutFormResourceListInput>
    create: XOR<FormCreateWithoutFormResourceListInput, FormUncheckedCreateWithoutFormResourceListInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutFormResourceListInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutFormResourceListInput, FormUncheckedUpdateWithoutFormResourceListInput>
  }

  export type FormUpdateWithoutFormResourceListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutFormNestedInput
    dield?: FieldUpdateOneWithoutFormListNestedInput
    encounterList?: EncounterUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutFormResourceListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ResourceUpsertWithoutFormResourceListInput = {
    update: XOR<ResourceUpdateWithoutFormResourceListInput, ResourceUncheckedUpdateWithoutFormResourceListInput>
    create: XOR<ResourceCreateWithoutFormResourceListInput, ResourceUncheckedCreateWithoutFormResourceListInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutFormResourceListInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutFormResourceListInput, ResourceUncheckedUpdateWithoutFormResourceListInput>
  }

  export type ResourceUpdateWithoutFormResourceListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateWithoutFormResourceListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateWithoutFormSubmissionListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceCreateNestedManyWithoutFormInput
    dield?: FieldCreateNestedOneWithoutFormListInput
    encounterList?: EncounterCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutFormSubmissionListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutFormInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutFormSubmissionListInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFormSubmissionListInput, FormUncheckedCreateWithoutFormSubmissionListInput>
  }

  export type EncounterCreateWithoutFormSubmissionListInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutFormSubmissionListInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutFormSubmissionListInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutFormSubmissionListInput, EncounterUncheckedCreateWithoutFormSubmissionListInput>
  }

  export type FieldAnswerCreateWithoutFormSubmissionInput = {
    id?: string
    uuid: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    field: FieldCreateNestedOneWithoutFieldAnswerListInput
  }

  export type FieldAnswerUncheckedCreateWithoutFormSubmissionInput = {
    id?: string
    uuid: string
    fieldId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerCreateOrConnectWithoutFormSubmissionInput = {
    where: FieldAnswerWhereUniqueInput
    create: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput>
  }

  export type FieldAnswerCreateManyFormSubmissionInputEnvelope = {
    data: FieldAnswerCreateManyFormSubmissionInput | FieldAnswerCreateManyFormSubmissionInput[]
    skipDuplicates?: boolean
  }

  export type FormUpsertWithoutFormSubmissionListInput = {
    update: XOR<FormUpdateWithoutFormSubmissionListInput, FormUncheckedUpdateWithoutFormSubmissionListInput>
    create: XOR<FormCreateWithoutFormSubmissionListInput, FormUncheckedCreateWithoutFormSubmissionListInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutFormSubmissionListInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutFormSubmissionListInput, FormUncheckedUpdateWithoutFormSubmissionListInput>
  }

  export type FormUpdateWithoutFormSubmissionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUpdateManyWithoutFormNestedInput
    dield?: FieldUpdateOneWithoutFormListNestedInput
    encounterList?: EncounterUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutFormSubmissionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUncheckedUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutFormNestedInput
  }

  export type EncounterUpsertWithoutFormSubmissionListInput = {
    update: XOR<EncounterUpdateWithoutFormSubmissionListInput, EncounterUncheckedUpdateWithoutFormSubmissionListInput>
    create: XOR<EncounterCreateWithoutFormSubmissionListInput, EncounterUncheckedCreateWithoutFormSubmissionListInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutFormSubmissionListInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutFormSubmissionListInput, EncounterUncheckedUpdateWithoutFormSubmissionListInput>
  }

  export type EncounterUpdateWithoutFormSubmissionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutFormSubmissionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type FieldAnswerUpsertWithWhereUniqueWithoutFormSubmissionInput = {
    where: FieldAnswerWhereUniqueInput
    update: XOR<FieldAnswerUpdateWithoutFormSubmissionInput, FieldAnswerUncheckedUpdateWithoutFormSubmissionInput>
    create: XOR<FieldAnswerCreateWithoutFormSubmissionInput, FieldAnswerUncheckedCreateWithoutFormSubmissionInput>
  }

  export type FieldAnswerUpdateWithWhereUniqueWithoutFormSubmissionInput = {
    where: FieldAnswerWhereUniqueInput
    data: XOR<FieldAnswerUpdateWithoutFormSubmissionInput, FieldAnswerUncheckedUpdateWithoutFormSubmissionInput>
  }

  export type FieldAnswerUpdateManyWithWhereWithoutFormSubmissionInput = {
    where: FieldAnswerScalarWhereInput
    data: XOR<FieldAnswerUpdateManyMutationInput, FieldAnswerUncheckedUpdateManyWithoutFormSubmissionInput>
  }

  export type FieldAnswerScalarWhereInput = {
    AND?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
    OR?: FieldAnswerScalarWhereInput[]
    NOT?: FieldAnswerScalarWhereInput | FieldAnswerScalarWhereInput[]
    id?: StringFilter<"FieldAnswer"> | string
    uuid?: StringFilter<"FieldAnswer"> | string
    formSubmissionId?: StringFilter<"FieldAnswer"> | string
    fieldId?: StringFilter<"FieldAnswer"> | string
    value?: StringFilter<"FieldAnswer"> | string
    creator?: StringFilter<"FieldAnswer"> | string
    dateCreated?: DateTimeFilter<"FieldAnswer"> | Date | string
    lastChangedBy?: StringFilter<"FieldAnswer"> | string
    lastChangedDate?: DateTimeFilter<"FieldAnswer"> | Date | string
  }

  export type ConceptCreateWithoutFieldListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutFieldListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutFieldListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutFieldListInput, ConceptUncheckedCreateWithoutFieldListInput>
  }

  export type FormCreateWithoutDieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutFormInput
    encounterList?: EncounterCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutDieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
    encounterList?: EncounterUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutDieldInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput>
  }

  export type FormCreateManyDieldInputEnvelope = {
    data: FormCreateManyDieldInput | FormCreateManyDieldInput[]
    skipDuplicates?: boolean
  }

  export type FieldAnswerCreateWithoutFieldInput = {
    id?: string
    uuid: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formSubmission: FormSubmissionCreateNestedOneWithoutFieldAnswerListInput
  }

  export type FieldAnswerUncheckedCreateWithoutFieldInput = {
    id?: string
    uuid: string
    formSubmissionId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerCreateOrConnectWithoutFieldInput = {
    where: FieldAnswerWhereUniqueInput
    create: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput>
  }

  export type FieldAnswerCreateManyFieldInputEnvelope = {
    data: FieldAnswerCreateManyFieldInput | FieldAnswerCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type FieldOptionCreateWithoutFieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldOptionUncheckedCreateWithoutFieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldOptionCreateOrConnectWithoutFieldInput = {
    where: FieldOptionWhereUniqueInput
    create: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput>
  }

  export type FieldOptionCreateManyFieldInputEnvelope = {
    data: FieldOptionCreateManyFieldInput | FieldOptionCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithoutFieldListInput = {
    update: XOR<ConceptUpdateWithoutFieldListInput, ConceptUncheckedUpdateWithoutFieldListInput>
    create: XOR<ConceptCreateWithoutFieldListInput, ConceptUncheckedCreateWithoutFieldListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutFieldListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutFieldListInput, ConceptUncheckedUpdateWithoutFieldListInput>
  }

  export type ConceptUpdateWithoutFieldListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutFieldListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type FormUpsertWithWhereUniqueWithoutDieldInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutDieldInput, FormUncheckedUpdateWithoutDieldInput>
    create: XOR<FormCreateWithoutDieldInput, FormUncheckedCreateWithoutDieldInput>
  }

  export type FormUpdateWithWhereUniqueWithoutDieldInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutDieldInput, FormUncheckedUpdateWithoutDieldInput>
  }

  export type FormUpdateManyWithWhereWithoutDieldInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutDieldInput>
  }

  export type FormScalarWhereInput = {
    AND?: FormScalarWhereInput | FormScalarWhereInput[]
    OR?: FormScalarWhereInput[]
    NOT?: FormScalarWhereInput | FormScalarWhereInput[]
    id?: StringFilter<"Form"> | string
    uuid?: StringFilter<"Form"> | string
    name?: StringFilter<"Form"> | string
    description?: StringFilter<"Form"> | string
    version?: StringFilter<"Form"> | string
    retired?: BoolFilter<"Form"> | boolean
    retiredBy?: StringFilter<"Form"> | string
    dateRetired?: DateTimeFilter<"Form"> | Date | string
    retiredReason?: StringFilter<"Form"> | string
    creator?: StringFilter<"Form"> | string
    dateCreated?: DateTimeFilter<"Form"> | Date | string
    lastChangedBy?: StringFilter<"Form"> | string
    lastChangedDate?: DateTimeFilter<"Form"> | Date | string
    fieldId?: StringNullableFilter<"Form"> | string | null
  }

  export type FieldAnswerUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldAnswerWhereUniqueInput
    update: XOR<FieldAnswerUpdateWithoutFieldInput, FieldAnswerUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldAnswerCreateWithoutFieldInput, FieldAnswerUncheckedCreateWithoutFieldInput>
  }

  export type FieldAnswerUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldAnswerWhereUniqueInput
    data: XOR<FieldAnswerUpdateWithoutFieldInput, FieldAnswerUncheckedUpdateWithoutFieldInput>
  }

  export type FieldAnswerUpdateManyWithWhereWithoutFieldInput = {
    where: FieldAnswerScalarWhereInput
    data: XOR<FieldAnswerUpdateManyMutationInput, FieldAnswerUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldOptionUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldOptionWhereUniqueInput
    update: XOR<FieldOptionUpdateWithoutFieldInput, FieldOptionUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldOptionCreateWithoutFieldInput, FieldOptionUncheckedCreateWithoutFieldInput>
  }

  export type FieldOptionUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldOptionWhereUniqueInput
    data: XOR<FieldOptionUpdateWithoutFieldInput, FieldOptionUncheckedUpdateWithoutFieldInput>
  }

  export type FieldOptionUpdateManyWithWhereWithoutFieldInput = {
    where: FieldOptionScalarWhereInput
    data: XOR<FieldOptionUpdateManyMutationInput, FieldOptionUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldOptionScalarWhereInput = {
    AND?: FieldOptionScalarWhereInput | FieldOptionScalarWhereInput[]
    OR?: FieldOptionScalarWhereInput[]
    NOT?: FieldOptionScalarWhereInput | FieldOptionScalarWhereInput[]
    id?: StringFilter<"FieldOption"> | string
    uuid?: StringFilter<"FieldOption"> | string
    fieldId?: StringFilter<"FieldOption"> | string
    name?: StringFilter<"FieldOption"> | string
    description?: StringFilter<"FieldOption"> | string
    creator?: StringFilter<"FieldOption"> | string
    dateCreated?: DateTimeFilter<"FieldOption"> | Date | string
    lastChangedBy?: StringFilter<"FieldOption"> | string
    lastChangedDate?: DateTimeFilter<"FieldOption"> | Date | string
  }

  export type FormSubmissionCreateWithoutFieldAnswerListInput = {
    id?: string
    uuid: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormSubmissionListInput
    encounter: EncounterCreateNestedOneWithoutFormSubmissionListInput
  }

  export type FormSubmissionUncheckedCreateWithoutFieldAnswerListInput = {
    id?: string
    uuid: string
    formId: string
    encounterId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutFieldAnswerListInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutFieldAnswerListInput, FormSubmissionUncheckedCreateWithoutFieldAnswerListInput>
  }

  export type FieldCreateWithoutFieldAnswerListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutFieldListInput
    formList?: FormCreateNestedManyWithoutDieldInput
    fieldOptionList?: FieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutFieldAnswerListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formList?: FormUncheckedCreateNestedManyWithoutDieldInput
    fieldOptionList?: FieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutFieldAnswerListInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFieldAnswerListInput, FieldUncheckedCreateWithoutFieldAnswerListInput>
  }

  export type FormSubmissionUpsertWithoutFieldAnswerListInput = {
    update: XOR<FormSubmissionUpdateWithoutFieldAnswerListInput, FormSubmissionUncheckedUpdateWithoutFieldAnswerListInput>
    create: XOR<FormSubmissionCreateWithoutFieldAnswerListInput, FormSubmissionUncheckedCreateWithoutFieldAnswerListInput>
    where?: FormSubmissionWhereInput
  }

  export type FormSubmissionUpdateToOneWithWhereWithoutFieldAnswerListInput = {
    where?: FormSubmissionWhereInput
    data: XOR<FormSubmissionUpdateWithoutFieldAnswerListInput, FormSubmissionUncheckedUpdateWithoutFieldAnswerListInput>
  }

  export type FormSubmissionUpdateWithoutFieldAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormSubmissionListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutFormSubmissionListNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutFieldAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldUpsertWithoutFieldAnswerListInput = {
    update: XOR<FieldUpdateWithoutFieldAnswerListInput, FieldUncheckedUpdateWithoutFieldAnswerListInput>
    create: XOR<FieldCreateWithoutFieldAnswerListInput, FieldUncheckedCreateWithoutFieldAnswerListInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFieldAnswerListInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFieldAnswerListInput, FieldUncheckedUpdateWithoutFieldAnswerListInput>
  }

  export type FieldUpdateWithoutFieldAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutFieldListNestedInput
    formList?: FormUpdateManyWithoutDieldNestedInput
    fieldOptionList?: FieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFieldAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formList?: FormUncheckedUpdateManyWithoutDieldNestedInput
    fieldOptionList?: FieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldCreateWithoutFieldOptionListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutFieldListInput
    formList?: FormCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutFieldOptionListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formList?: FormUncheckedCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutFieldOptionListInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFieldOptionListInput, FieldUncheckedCreateWithoutFieldOptionListInput>
  }

  export type FieldUpsertWithoutFieldOptionListInput = {
    update: XOR<FieldUpdateWithoutFieldOptionListInput, FieldUncheckedUpdateWithoutFieldOptionListInput>
    create: XOR<FieldCreateWithoutFieldOptionListInput, FieldUncheckedCreateWithoutFieldOptionListInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFieldOptionListInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFieldOptionListInput, FieldUncheckedUpdateWithoutFieldOptionListInput>
  }

  export type FieldUpdateWithoutFieldOptionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutFieldListNestedInput
    formList?: FormUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFieldOptionListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formList?: FormUncheckedUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type EncounterTypeCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterTypeUncheckedCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterTypeCreateOrConnectWithoutEncounterListInput = {
    where: EncounterTypeWhereUniqueInput
    create: XOR<EncounterTypeCreateWithoutEncounterListInput, EncounterTypeUncheckedCreateWithoutEncounterListInput>
  }

  export type PatientCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    givenName: string
    middleName: string
    familyName: string
    gender: string
    birthdate: Date | string
    dead?: boolean
    deathDate: Date | string
    causeOfDeath: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEncounterListInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEncounterListInput, PatientUncheckedCreateWithoutEncounterListInput>
  }

  export type LocationCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    address1: string
    address2: string
    city: string
    stateProvince: string
    country: string
    postalCode: string
    latitude: number
    longitude: number
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutEncounterListInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEncounterListInput, LocationUncheckedCreateWithoutEncounterListInput>
  }

  export type FormCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutFormInput
    dield?: FieldCreateNestedOneWithoutFormListInput
  }

  export type FormUncheckedCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldId?: string | null
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutFormInput
    formResourceList?: FormResourceUncheckedCreateNestedManyWithoutFormInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutEncounterListInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutEncounterListInput, FormUncheckedCreateWithoutEncounterListInput>
  }

  export type ProviderCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutEncounterListInput = {
    id?: string
    uuid: string
    name: string
    identifier: string
    description: string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    appointmentList?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutEncounterListInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutEncounterListInput, ProviderUncheckedCreateWithoutEncounterListInput>
  }

  export type FormEncounterCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormEncounterListInput
  }

  export type FormEncounterUncheckedCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    formId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormEncounterCreateOrConnectWithoutEncounterInput = {
    where: FormEncounterWhereUniqueInput
    create: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput>
  }

  export type FormEncounterCreateManyEncounterInputEnvelope = {
    data: FormEncounterCreateManyEncounterInput | FormEncounterCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormSubmissionListInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionUncheckedCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    formId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionCreateOrConnectWithoutEncounterInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput>
  }

  export type FormSubmissionCreateManyEncounterInputEnvelope = {
    data: FormSubmissionCreateManyEncounterInput | FormSubmissionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type ObsCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutObsListInput
  }

  export type ObsUncheckedCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    conceptId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsCreateOrConnectWithoutEncounterInput = {
    where: ObsWhereUniqueInput
    create: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput>
  }

  export type ObsCreateManyEncounterInputEnvelope = {
    data: ObsCreateManyEncounterInput | ObsCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutEncounterInput = {
    id?: string
    uuid: string
    conceptId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderCreateOrConnectWithoutEncounterInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput>
  }

  export type OrderCreateManyEncounterInputEnvelope = {
    data: OrderCreateManyEncounterInput | OrderCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterTypeUpsertWithoutEncounterListInput = {
    update: XOR<EncounterTypeUpdateWithoutEncounterListInput, EncounterTypeUncheckedUpdateWithoutEncounterListInput>
    create: XOR<EncounterTypeCreateWithoutEncounterListInput, EncounterTypeUncheckedCreateWithoutEncounterListInput>
    where?: EncounterTypeWhereInput
  }

  export type EncounterTypeUpdateToOneWithWhereWithoutEncounterListInput = {
    where?: EncounterTypeWhereInput
    data: XOR<EncounterTypeUpdateWithoutEncounterListInput, EncounterTypeUncheckedUpdateWithoutEncounterListInput>
  }

  export type EncounterTypeUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterTypeUncheckedUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutEncounterListInput = {
    update: XOR<PatientUpdateWithoutEncounterListInput, PatientUncheckedUpdateWithoutEncounterListInput>
    create: XOR<PatientCreateWithoutEncounterListInput, PatientUncheckedCreateWithoutEncounterListInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEncounterListInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEncounterListInput, PatientUncheckedUpdateWithoutEncounterListInput>
  }

  export type PatientUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    givenName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    familyName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    dead?: BoolFieldUpdateOperationsInput | boolean
    deathDate?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LocationUpsertWithoutEncounterListInput = {
    update: XOR<LocationUpdateWithoutEncounterListInput, LocationUncheckedUpdateWithoutEncounterListInput>
    create: XOR<LocationCreateWithoutEncounterListInput, LocationUncheckedCreateWithoutEncounterListInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutEncounterListInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutEncounterListInput, LocationUncheckedUpdateWithoutEncounterListInput>
  }

  export type LocationUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address1?: StringFieldUpdateOperationsInput | string
    address2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type FormUpsertWithoutEncounterListInput = {
    update: XOR<FormUpdateWithoutEncounterListInput, FormUncheckedUpdateWithoutEncounterListInput>
    create: XOR<FormCreateWithoutEncounterListInput, FormUncheckedCreateWithoutEncounterListInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutEncounterListInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutEncounterListInput, FormUncheckedUpdateWithoutEncounterListInput>
  }

  export type FormUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutFormNestedInput
    dield?: FieldUpdateOneWithoutFormListNestedInput
  }

  export type FormUncheckedUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUncheckedUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProviderUpsertWithoutEncounterListInput = {
    update: XOR<ProviderUpdateWithoutEncounterListInput, ProviderUncheckedUpdateWithoutEncounterListInput>
    create: XOR<ProviderCreateWithoutEncounterListInput, ProviderUncheckedCreateWithoutEncounterListInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutEncounterListInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutEncounterListInput, ProviderUncheckedUpdateWithoutEncounterListInput>
  }

  export type ProviderUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutEncounterListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentList?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type FormEncounterUpsertWithWhereUniqueWithoutEncounterInput = {
    where: FormEncounterWhereUniqueInput
    update: XOR<FormEncounterUpdateWithoutEncounterInput, FormEncounterUncheckedUpdateWithoutEncounterInput>
    create: XOR<FormEncounterCreateWithoutEncounterInput, FormEncounterUncheckedCreateWithoutEncounterInput>
  }

  export type FormEncounterUpdateWithWhereUniqueWithoutEncounterInput = {
    where: FormEncounterWhereUniqueInput
    data: XOR<FormEncounterUpdateWithoutEncounterInput, FormEncounterUncheckedUpdateWithoutEncounterInput>
  }

  export type FormEncounterUpdateManyWithWhereWithoutEncounterInput = {
    where: FormEncounterScalarWhereInput
    data: XOR<FormEncounterUpdateManyMutationInput, FormEncounterUncheckedUpdateManyWithoutEncounterInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutEncounterInput, FormSubmissionUncheckedUpdateWithoutEncounterInput>
    create: XOR<FormSubmissionCreateWithoutEncounterInput, FormSubmissionUncheckedCreateWithoutEncounterInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutEncounterInput, FormSubmissionUncheckedUpdateWithoutEncounterInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutEncounterInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ObsUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ObsWhereUniqueInput
    update: XOR<ObsUpdateWithoutEncounterInput, ObsUncheckedUpdateWithoutEncounterInput>
    create: XOR<ObsCreateWithoutEncounterInput, ObsUncheckedCreateWithoutEncounterInput>
  }

  export type ObsUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ObsWhereUniqueInput
    data: XOR<ObsUpdateWithoutEncounterInput, ObsUncheckedUpdateWithoutEncounterInput>
  }

  export type ObsUpdateManyWithWhereWithoutEncounterInput = {
    where: ObsScalarWhereInput
    data: XOR<ObsUpdateManyMutationInput, ObsUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ObsScalarWhereInput = {
    AND?: ObsScalarWhereInput | ObsScalarWhereInput[]
    OR?: ObsScalarWhereInput[]
    NOT?: ObsScalarWhereInput | ObsScalarWhereInput[]
    id?: StringFilter<"Obs"> | string
    uuid?: StringFilter<"Obs"> | string
    conceptId?: StringFilter<"Obs"> | string
    encounterId?: StringFilter<"Obs"> | string
    obsDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueDatetime?: DateTimeFilter<"Obs"> | Date | string
    valueNumeric?: FloatFilter<"Obs"> | number
    valueText?: StringFilter<"Obs"> | string
    creator?: StringFilter<"Obs"> | string
    dateCreated?: DateTimeFilter<"Obs"> | Date | string
    lastChangedBy?: StringFilter<"Obs"> | string
    lastChangedDate?: DateTimeFilter<"Obs"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutEncounterInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutEncounterInput, OrderUncheckedUpdateWithoutEncounterInput>
    create: XOR<OrderCreateWithoutEncounterInput, OrderUncheckedCreateWithoutEncounterInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutEncounterInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutEncounterInput, OrderUncheckedUpdateWithoutEncounterInput>
  }

  export type OrderUpdateManyWithWhereWithoutEncounterInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutEncounterInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    uuid?: StringFilter<"Order"> | string
    conceptId?: StringFilter<"Order"> | string
    encounterId?: StringFilter<"Order"> | string
    orderDatetime?: DateTimeFilter<"Order"> | Date | string
    instructions?: StringFilter<"Order"> | string
    dosage?: StringFilter<"Order"> | string
    route?: StringFilter<"Order"> | string
    frequency?: StringFilter<"Order"> | string
    asNeeded?: BoolFilter<"Order"> | boolean
    prn?: BoolFilter<"Order"> | boolean
    quantity?: IntFilter<"Order"> | number
    units?: StringFilter<"Order"> | string
    creator?: StringFilter<"Order"> | string
    dateCreated?: DateTimeFilter<"Order"> | Date | string
    lastChangedBy?: StringFilter<"Order"> | string
    lastChangedDate?: DateTimeFilter<"Order"> | Date | string
    orderFrequencyId?: StringNullableFilter<"Order"> | string | null
    orderRouteId?: StringNullableFilter<"Order"> | string | null
    orderTypeId?: StringNullableFilter<"Order"> | string | null
    orderUnitId?: StringNullableFilter<"Order"> | string | null
  }

  export type EncounterCreateWithoutEncounterTypeInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutEncounterTypeInput = {
    id?: string
    uuid: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutEncounterTypeInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput>
  }

  export type EncounterCreateManyEncounterTypeInputEnvelope = {
    data: EncounterCreateManyEncounterTypeInput | EncounterCreateManyEncounterTypeInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithWhereUniqueWithoutEncounterTypeInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutEncounterTypeInput, EncounterUncheckedUpdateWithoutEncounterTypeInput>
    create: XOR<EncounterCreateWithoutEncounterTypeInput, EncounterUncheckedCreateWithoutEncounterTypeInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutEncounterTypeInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutEncounterTypeInput, EncounterUncheckedUpdateWithoutEncounterTypeInput>
  }

  export type EncounterUpdateManyWithWhereWithoutEncounterTypeInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutEncounterTypeInput>
  }

  export type ConceptCreateWithoutObsListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutObsListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutObsListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutObsListInput, ConceptUncheckedCreateWithoutObsListInput>
  }

  export type EncounterCreateWithoutObsListInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    orderList?: OrderCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutObsListInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    orderList?: OrderUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutObsListInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutObsListInput, EncounterUncheckedCreateWithoutObsListInput>
  }

  export type ConceptUpsertWithoutObsListInput = {
    update: XOR<ConceptUpdateWithoutObsListInput, ConceptUncheckedUpdateWithoutObsListInput>
    create: XOR<ConceptCreateWithoutObsListInput, ConceptUncheckedCreateWithoutObsListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutObsListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutObsListInput, ConceptUncheckedUpdateWithoutObsListInput>
  }

  export type ConceptUpdateWithoutObsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutObsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type EncounterUpsertWithoutObsListInput = {
    update: XOR<EncounterUpdateWithoutObsListInput, EncounterUncheckedUpdateWithoutObsListInput>
    create: XOR<EncounterCreateWithoutObsListInput, EncounterUncheckedCreateWithoutObsListInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutObsListInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutObsListInput, EncounterUncheckedUpdateWithoutObsListInput>
  }

  export type EncounterUpdateWithoutObsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutObsListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ConceptCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutOrderListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutOrderListInput, ConceptUncheckedCreateWithoutOrderListInput>
  }

  export type EncounterCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounterType: EncounterTypeCreateNestedOneWithoutEncounterListInput
    patient: PatientCreateNestedOneWithoutEncounterListInput
    location: LocationCreateNestedOneWithoutEncounterListInput
    form: FormCreateNestedOneWithoutEncounterListInput
    provider: ProviderCreateNestedOneWithoutEncounterListInput
    formEncounterList?: FormEncounterCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionCreateNestedManyWithoutEncounterInput
    obsList?: ObsCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formEncounterList?: FormEncounterUncheckedCreateNestedManyWithoutEncounterInput
    formSubmissionList?: FormSubmissionUncheckedCreateNestedManyWithoutEncounterInput
    obsList?: ObsUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutOrderListInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutOrderListInput, EncounterUncheckedCreateWithoutOrderListInput>
  }

  export type OrderFrequencyCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderFrequencyUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderFrequencyCreateOrConnectWithoutOrderListInput = {
    where: OrderFrequencyWhereUniqueInput
    create: XOR<OrderFrequencyCreateWithoutOrderListInput, OrderFrequencyUncheckedCreateWithoutOrderListInput>
  }

  export type OrderRouteCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderRouteUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderRouteCreateOrConnectWithoutOrderListInput = {
    where: OrderRouteWhereUniqueInput
    create: XOR<OrderRouteCreateWithoutOrderListInput, OrderRouteUncheckedCreateWithoutOrderListInput>
  }

  export type OrderTypeCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderTypeUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderTypeCreateOrConnectWithoutOrderListInput = {
    where: OrderTypeWhereUniqueInput
    create: XOR<OrderTypeCreateWithoutOrderListInput, OrderTypeUncheckedCreateWithoutOrderListInput>
  }

  export type OrderUnitCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderUnitUncheckedCreateWithoutOrderListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderUnitCreateOrConnectWithoutOrderListInput = {
    where: OrderUnitWhereUniqueInput
    create: XOR<OrderUnitCreateWithoutOrderListInput, OrderUnitUncheckedCreateWithoutOrderListInput>
  }

  export type ConceptUpsertWithoutOrderListInput = {
    update: XOR<ConceptUpdateWithoutOrderListInput, ConceptUncheckedUpdateWithoutOrderListInput>
    create: XOR<ConceptCreateWithoutOrderListInput, ConceptUncheckedCreateWithoutOrderListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutOrderListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutOrderListInput, ConceptUncheckedUpdateWithoutOrderListInput>
  }

  export type ConceptUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type EncounterUpsertWithoutOrderListInput = {
    update: XOR<EncounterUpdateWithoutOrderListInput, EncounterUncheckedUpdateWithoutOrderListInput>
    create: XOR<EncounterCreateWithoutOrderListInput, EncounterUncheckedCreateWithoutOrderListInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutOrderListInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutOrderListInput, EncounterUncheckedUpdateWithoutOrderListInput>
  }

  export type EncounterUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type OrderFrequencyUpsertWithoutOrderListInput = {
    update: XOR<OrderFrequencyUpdateWithoutOrderListInput, OrderFrequencyUncheckedUpdateWithoutOrderListInput>
    create: XOR<OrderFrequencyCreateWithoutOrderListInput, OrderFrequencyUncheckedCreateWithoutOrderListInput>
    where?: OrderFrequencyWhereInput
  }

  export type OrderFrequencyUpdateToOneWithWhereWithoutOrderListInput = {
    where?: OrderFrequencyWhereInput
    data: XOR<OrderFrequencyUpdateWithoutOrderListInput, OrderFrequencyUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderFrequencyUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderFrequencyUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRouteUpsertWithoutOrderListInput = {
    update: XOR<OrderRouteUpdateWithoutOrderListInput, OrderRouteUncheckedUpdateWithoutOrderListInput>
    create: XOR<OrderRouteCreateWithoutOrderListInput, OrderRouteUncheckedCreateWithoutOrderListInput>
    where?: OrderRouteWhereInput
  }

  export type OrderRouteUpdateToOneWithWhereWithoutOrderListInput = {
    where?: OrderRouteWhereInput
    data: XOR<OrderRouteUpdateWithoutOrderListInput, OrderRouteUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderRouteUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderRouteUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTypeUpsertWithoutOrderListInput = {
    update: XOR<OrderTypeUpdateWithoutOrderListInput, OrderTypeUncheckedUpdateWithoutOrderListInput>
    create: XOR<OrderTypeCreateWithoutOrderListInput, OrderTypeUncheckedCreateWithoutOrderListInput>
    where?: OrderTypeWhereInput
  }

  export type OrderTypeUpdateToOneWithWhereWithoutOrderListInput = {
    where?: OrderTypeWhereInput
    data: XOR<OrderTypeUpdateWithoutOrderListInput, OrderTypeUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderTypeUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTypeUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUnitUpsertWithoutOrderListInput = {
    update: XOR<OrderUnitUpdateWithoutOrderListInput, OrderUnitUncheckedUpdateWithoutOrderListInput>
    create: XOR<OrderUnitCreateWithoutOrderListInput, OrderUnitUncheckedCreateWithoutOrderListInput>
    where?: OrderUnitWhereInput
  }

  export type OrderUnitUpdateToOneWithWhereWithoutOrderListInput = {
    where?: OrderUnitWhereInput
    data: XOR<OrderUnitUpdateWithoutOrderListInput, OrderUnitUncheckedUpdateWithoutOrderListInput>
  }

  export type OrderUnitUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUnitUncheckedUpdateWithoutOrderListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutOrderFrequencyInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutOrderFrequencyInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderFrequencyInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput>
  }

  export type OrderCreateManyOrderFrequencyInputEnvelope = {
    data: OrderCreateManyOrderFrequencyInput | OrderCreateManyOrderFrequencyInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrderFrequencyInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrderFrequencyInput, OrderUncheckedUpdateWithoutOrderFrequencyInput>
    create: XOR<OrderCreateWithoutOrderFrequencyInput, OrderUncheckedCreateWithoutOrderFrequencyInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrderFrequencyInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrderFrequencyInput, OrderUncheckedUpdateWithoutOrderFrequencyInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrderFrequencyInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderFrequencyInput>
  }

  export type OrderCreateWithoutOrderRouteInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutOrderRouteInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderRouteInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput>
  }

  export type OrderCreateManyOrderRouteInputEnvelope = {
    data: OrderCreateManyOrderRouteInput | OrderCreateManyOrderRouteInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrderRouteInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrderRouteInput, OrderUncheckedUpdateWithoutOrderRouteInput>
    create: XOR<OrderCreateWithoutOrderRouteInput, OrderUncheckedCreateWithoutOrderRouteInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrderRouteInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrderRouteInput, OrderUncheckedUpdateWithoutOrderRouteInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrderRouteInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderRouteInput>
  }

  export type OrderCreateWithoutOrderTypeInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutOrderTypeInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderUnitId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderTypeInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput>
  }

  export type OrderCreateManyOrderTypeInputEnvelope = {
    data: OrderCreateManyOrderTypeInput | OrderCreateManyOrderTypeInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrderTypeInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrderTypeInput, OrderUncheckedUpdateWithoutOrderTypeInput>
    create: XOR<OrderCreateWithoutOrderTypeInput, OrderUncheckedCreateWithoutOrderTypeInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrderTypeInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrderTypeInput, OrderUncheckedUpdateWithoutOrderTypeInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrderTypeInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderTypeInput>
  }

  export type OrderCreateWithoutOrderUnitInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutOrderListInput
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutOrderUnitInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderUnitInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput>
  }

  export type OrderCreateManyOrderUnitInputEnvelope = {
    data: OrderCreateManyOrderUnitInput | OrderCreateManyOrderUnitInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrderUnitInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrderUnitInput, OrderUncheckedUpdateWithoutOrderUnitInput>
    create: XOR<OrderCreateWithoutOrderUnitInput, OrderUncheckedCreateWithoutOrderUnitInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrderUnitInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrderUnitInput, OrderUncheckedUpdateWithoutOrderUnitInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrderUnitInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderUnitInput>
  }

  export type ConceptAnswerCreateWithoutConceptInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    answerConcept: ConceptCreateNestedOneWithoutAnswerListInput
  }

  export type ConceptAnswerUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    answerConceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerCreateOrConnectWithoutConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    create: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput>
  }

  export type ConceptAnswerCreateManyConceptInputEnvelope = {
    data: ConceptAnswerCreateManyConceptInput | ConceptAnswerCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptAnswerCreateWithoutAnswerConceptInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    concept: ConceptCreateNestedOneWithoutMetaListInput
  }

  export type ConceptAnswerUncheckedCreateWithoutAnswerConceptInput = {
    id?: string
    uuid: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerCreateOrConnectWithoutAnswerConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    create: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput>
  }

  export type ConceptAnswerCreateManyAnswerConceptInputEnvelope = {
    data: ConceptAnswerCreateManyAnswerConceptInput | ConceptAnswerCreateManyAnswerConceptInput[]
    skipDuplicates?: boolean
  }

  export type FieldCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formList?: FormCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    formList?: FormUncheckedCreateNestedManyWithoutDieldInput
    fieldAnswerList?: FieldAnswerUncheckedCreateNestedManyWithoutFieldInput
    fieldOptionList?: FieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutConceptInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput>
  }

  export type FieldCreateManyConceptInputEnvelope = {
    data: FieldCreateManyConceptInput | FieldCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ObsCreateWithoutConceptInput = {
    id?: string
    uuid: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounter: EncounterCreateNestedOneWithoutObsListInput
  }

  export type ObsUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    encounterId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsCreateOrConnectWithoutConceptInput = {
    where: ObsWhereUniqueInput
    create: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput>
  }

  export type ObsCreateManyConceptInputEnvelope = {
    data: ObsCreateManyConceptInput | ObsCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutConceptInput = {
    id?: string
    uuid: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    encounter: EncounterCreateNestedOneWithoutOrderListInput
    OrderFrequency?: OrderFrequencyCreateNestedOneWithoutOrderListInput
    OrderRoute?: OrderRouteCreateNestedOneWithoutOrderListInput
    OrderType?: OrderTypeCreateNestedOneWithoutOrderListInput
    OrderUnit?: OrderUnitCreateNestedOneWithoutOrderListInput
  }

  export type OrderUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderCreateOrConnectWithoutConceptInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput>
  }

  export type OrderCreateManyConceptInputEnvelope = {
    data: OrderCreateManyConceptInput | OrderCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptClassCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptClassUncheckedCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptClassCreateOrConnectWithoutConceptListInput = {
    where: ConceptClassWhereUniqueInput
    create: XOR<ConceptClassCreateWithoutConceptListInput, ConceptClassUncheckedCreateWithoutConceptListInput>
  }

  export type ConceptDatatypeCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptDatatypeUncheckedCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptDatatypeCreateOrConnectWithoutConceptListInput = {
    where: ConceptDatatypeWhereUniqueInput
    create: XOR<ConceptDatatypeCreateWithoutConceptListInput, ConceptDatatypeUncheckedCreateWithoutConceptListInput>
  }

  export type ConceptMapCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptMapUncheckedCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptMapCreateOrConnectWithoutConceptListInput = {
    where: ConceptMapWhereUniqueInput
    create: XOR<ConceptMapCreateWithoutConceptListInput, ConceptMapUncheckedCreateWithoutConceptListInput>
  }

  export type ConceptNameCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNameUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNameCreateOrConnectWithoutConceptInput = {
    where: ConceptNameWhereUniqueInput
    create: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput>
  }

  export type ConceptNameCreateManyConceptInputEnvelope = {
    data: ConceptNameCreateManyConceptInput | ConceptNameCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptNumericCreateWithoutConceptInput = {
    id?: string
    uuid: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNumericUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNumericCreateOrConnectWithoutConceptInput = {
    where: ConceptNumericWhereUniqueInput
    create: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput>
  }

  export type ConceptNumericCreateManyConceptInputEnvelope = {
    data: ConceptNumericCreateManyConceptInput | ConceptNumericCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptProposalCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptProposalUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptProposalCreateOrConnectWithoutConceptInput = {
    where: ConceptProposalWhereUniqueInput
    create: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput>
  }

  export type ConceptProposalCreateManyConceptInputEnvelope = {
    data: ConceptProposalCreateManyConceptInput | ConceptProposalCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptSetCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSetUncheckedCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSetCreateOrConnectWithoutConceptListInput = {
    where: ConceptSetWhereUniqueInput
    create: XOR<ConceptSetCreateWithoutConceptListInput, ConceptSetUncheckedCreateWithoutConceptListInput>
  }

  export type ConceptSourceCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSourceUncheckedCreateWithoutConceptListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptSourceCreateOrConnectWithoutConceptListInput = {
    where: ConceptSourceWhereUniqueInput
    create: XOR<ConceptSourceCreateWithoutConceptListInput, ConceptSourceUncheckedCreateWithoutConceptListInput>
  }

  export type ConceptWordCreateWithoutConceptInput = {
    id?: string
    uuid: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptWordUncheckedCreateWithoutConceptInput = {
    id?: string
    uuid: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptWordCreateOrConnectWithoutConceptInput = {
    where: ConceptWordWhereUniqueInput
    create: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput>
  }

  export type ConceptWordCreateManyConceptInputEnvelope = {
    data: ConceptWordCreateManyConceptInput | ConceptWordCreateManyConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptAnswerUpsertWithWhereUniqueWithoutConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    update: XOR<ConceptAnswerUpdateWithoutConceptInput, ConceptAnswerUncheckedUpdateWithoutConceptInput>
    create: XOR<ConceptAnswerCreateWithoutConceptInput, ConceptAnswerUncheckedCreateWithoutConceptInput>
  }

  export type ConceptAnswerUpdateWithWhereUniqueWithoutConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    data: XOR<ConceptAnswerUpdateWithoutConceptInput, ConceptAnswerUncheckedUpdateWithoutConceptInput>
  }

  export type ConceptAnswerUpdateManyWithWhereWithoutConceptInput = {
    where: ConceptAnswerScalarWhereInput
    data: XOR<ConceptAnswerUpdateManyMutationInput, ConceptAnswerUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptAnswerScalarWhereInput = {
    AND?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
    OR?: ConceptAnswerScalarWhereInput[]
    NOT?: ConceptAnswerScalarWhereInput | ConceptAnswerScalarWhereInput[]
    id?: StringFilter<"ConceptAnswer"> | string
    uuid?: StringFilter<"ConceptAnswer"> | string
    conceptId?: StringFilter<"ConceptAnswer"> | string
    answerConceptId?: StringFilter<"ConceptAnswer"> | string
    creator?: StringFilter<"ConceptAnswer"> | string
    dateCreated?: DateTimeFilter<"ConceptAnswer"> | Date | string
    lastChangedBy?: StringFilter<"ConceptAnswer"> | string
    lastChangedDate?: DateTimeFilter<"ConceptAnswer"> | Date | string
  }

  export type ConceptAnswerUpsertWithWhereUniqueWithoutAnswerConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    update: XOR<ConceptAnswerUpdateWithoutAnswerConceptInput, ConceptAnswerUncheckedUpdateWithoutAnswerConceptInput>
    create: XOR<ConceptAnswerCreateWithoutAnswerConceptInput, ConceptAnswerUncheckedCreateWithoutAnswerConceptInput>
  }

  export type ConceptAnswerUpdateWithWhereUniqueWithoutAnswerConceptInput = {
    where: ConceptAnswerWhereUniqueInput
    data: XOR<ConceptAnswerUpdateWithoutAnswerConceptInput, ConceptAnswerUncheckedUpdateWithoutAnswerConceptInput>
  }

  export type ConceptAnswerUpdateManyWithWhereWithoutAnswerConceptInput = {
    where: ConceptAnswerScalarWhereInput
    data: XOR<ConceptAnswerUpdateManyMutationInput, ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptInput>
  }

  export type FieldUpsertWithWhereUniqueWithoutConceptInput = {
    where: FieldWhereUniqueInput
    update: XOR<FieldUpdateWithoutConceptInput, FieldUncheckedUpdateWithoutConceptInput>
    create: XOR<FieldCreateWithoutConceptInput, FieldUncheckedCreateWithoutConceptInput>
  }

  export type FieldUpdateWithWhereUniqueWithoutConceptInput = {
    where: FieldWhereUniqueInput
    data: XOR<FieldUpdateWithoutConceptInput, FieldUncheckedUpdateWithoutConceptInput>
  }

  export type FieldUpdateManyWithWhereWithoutConceptInput = {
    where: FieldScalarWhereInput
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyWithoutConceptInput>
  }

  export type FieldScalarWhereInput = {
    AND?: FieldScalarWhereInput | FieldScalarWhereInput[]
    OR?: FieldScalarWhereInput[]
    NOT?: FieldScalarWhereInput | FieldScalarWhereInput[]
    id?: StringFilter<"Field"> | string
    uuid?: StringFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    description?: StringFilter<"Field"> | string
    fieldType?: StringFilter<"Field"> | string
    conceptId?: StringFilter<"Field"> | string
    creator?: StringFilter<"Field"> | string
    dateCreated?: DateTimeFilter<"Field"> | Date | string
    lastChangedBy?: StringFilter<"Field"> | string
    lastChangedDate?: DateTimeFilter<"Field"> | Date | string
  }

  export type ObsUpsertWithWhereUniqueWithoutConceptInput = {
    where: ObsWhereUniqueInput
    update: XOR<ObsUpdateWithoutConceptInput, ObsUncheckedUpdateWithoutConceptInput>
    create: XOR<ObsCreateWithoutConceptInput, ObsUncheckedCreateWithoutConceptInput>
  }

  export type ObsUpdateWithWhereUniqueWithoutConceptInput = {
    where: ObsWhereUniqueInput
    data: XOR<ObsUpdateWithoutConceptInput, ObsUncheckedUpdateWithoutConceptInput>
  }

  export type ObsUpdateManyWithWhereWithoutConceptInput = {
    where: ObsScalarWhereInput
    data: XOR<ObsUpdateManyMutationInput, ObsUncheckedUpdateManyWithoutConceptInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutConceptInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutConceptInput, OrderUncheckedUpdateWithoutConceptInput>
    create: XOR<OrderCreateWithoutConceptInput, OrderUncheckedCreateWithoutConceptInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutConceptInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutConceptInput, OrderUncheckedUpdateWithoutConceptInput>
  }

  export type OrderUpdateManyWithWhereWithoutConceptInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptClassUpsertWithoutConceptListInput = {
    update: XOR<ConceptClassUpdateWithoutConceptListInput, ConceptClassUncheckedUpdateWithoutConceptListInput>
    create: XOR<ConceptClassCreateWithoutConceptListInput, ConceptClassUncheckedCreateWithoutConceptListInput>
    where?: ConceptClassWhereInput
  }

  export type ConceptClassUpdateToOneWithWhereWithoutConceptListInput = {
    where?: ConceptClassWhereInput
    data: XOR<ConceptClassUpdateWithoutConceptListInput, ConceptClassUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptClassUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptClassUncheckedUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptDatatypeUpsertWithoutConceptListInput = {
    update: XOR<ConceptDatatypeUpdateWithoutConceptListInput, ConceptDatatypeUncheckedUpdateWithoutConceptListInput>
    create: XOR<ConceptDatatypeCreateWithoutConceptListInput, ConceptDatatypeUncheckedCreateWithoutConceptListInput>
    where?: ConceptDatatypeWhereInput
  }

  export type ConceptDatatypeUpdateToOneWithWhereWithoutConceptListInput = {
    where?: ConceptDatatypeWhereInput
    data: XOR<ConceptDatatypeUpdateWithoutConceptListInput, ConceptDatatypeUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptDatatypeUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptDatatypeUncheckedUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptMapUpsertWithoutConceptListInput = {
    update: XOR<ConceptMapUpdateWithoutConceptListInput, ConceptMapUncheckedUpdateWithoutConceptListInput>
    create: XOR<ConceptMapCreateWithoutConceptListInput, ConceptMapUncheckedCreateWithoutConceptListInput>
    where?: ConceptMapWhereInput
  }

  export type ConceptMapUpdateToOneWithWhereWithoutConceptListInput = {
    where?: ConceptMapWhereInput
    data: XOR<ConceptMapUpdateWithoutConceptListInput, ConceptMapUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptMapUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptMapUncheckedUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameUpsertWithWhereUniqueWithoutConceptInput = {
    where: ConceptNameWhereUniqueInput
    update: XOR<ConceptNameUpdateWithoutConceptInput, ConceptNameUncheckedUpdateWithoutConceptInput>
    create: XOR<ConceptNameCreateWithoutConceptInput, ConceptNameUncheckedCreateWithoutConceptInput>
  }

  export type ConceptNameUpdateWithWhereUniqueWithoutConceptInput = {
    where: ConceptNameWhereUniqueInput
    data: XOR<ConceptNameUpdateWithoutConceptInput, ConceptNameUncheckedUpdateWithoutConceptInput>
  }

  export type ConceptNameUpdateManyWithWhereWithoutConceptInput = {
    where: ConceptNameScalarWhereInput
    data: XOR<ConceptNameUpdateManyMutationInput, ConceptNameUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptNameScalarWhereInput = {
    AND?: ConceptNameScalarWhereInput | ConceptNameScalarWhereInput[]
    OR?: ConceptNameScalarWhereInput[]
    NOT?: ConceptNameScalarWhereInput | ConceptNameScalarWhereInput[]
    id?: StringFilter<"ConceptName"> | string
    uuid?: StringFilter<"ConceptName"> | string
    conceptId?: StringFilter<"ConceptName"> | string
    name?: StringFilter<"ConceptName"> | string
    locale?: StringFilter<"ConceptName"> | string
    creator?: StringFilter<"ConceptName"> | string
    dateCreated?: DateTimeFilter<"ConceptName"> | Date | string
    lastChangedBy?: StringFilter<"ConceptName"> | string
    lastChangedDate?: DateTimeFilter<"ConceptName"> | Date | string
  }

  export type ConceptNumericUpsertWithWhereUniqueWithoutConceptInput = {
    where: ConceptNumericWhereUniqueInput
    update: XOR<ConceptNumericUpdateWithoutConceptInput, ConceptNumericUncheckedUpdateWithoutConceptInput>
    create: XOR<ConceptNumericCreateWithoutConceptInput, ConceptNumericUncheckedCreateWithoutConceptInput>
  }

  export type ConceptNumericUpdateWithWhereUniqueWithoutConceptInput = {
    where: ConceptNumericWhereUniqueInput
    data: XOR<ConceptNumericUpdateWithoutConceptInput, ConceptNumericUncheckedUpdateWithoutConceptInput>
  }

  export type ConceptNumericUpdateManyWithWhereWithoutConceptInput = {
    where: ConceptNumericScalarWhereInput
    data: XOR<ConceptNumericUpdateManyMutationInput, ConceptNumericUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptNumericScalarWhereInput = {
    AND?: ConceptNumericScalarWhereInput | ConceptNumericScalarWhereInput[]
    OR?: ConceptNumericScalarWhereInput[]
    NOT?: ConceptNumericScalarWhereInput | ConceptNumericScalarWhereInput[]
    id?: StringFilter<"ConceptNumeric"> | string
    uuid?: StringFilter<"ConceptNumeric"> | string
    conceptId?: StringFilter<"ConceptNumeric"> | string
    hiAbsolute?: FloatFilter<"ConceptNumeric"> | number
    hiCritical?: FloatFilter<"ConceptNumeric"> | number
    hiNormal?: FloatFilter<"ConceptNumeric"> | number
    lowAbsolute?: FloatFilter<"ConceptNumeric"> | number
    lowCritical?: FloatFilter<"ConceptNumeric"> | number
    lowNormal?: FloatFilter<"ConceptNumeric"> | number
    units?: StringFilter<"ConceptNumeric"> | string
    creator?: StringFilter<"ConceptNumeric"> | string
    dateCreated?: DateTimeFilter<"ConceptNumeric"> | Date | string
    lastChangedBy?: StringFilter<"ConceptNumeric"> | string
    lastChangedDate?: DateTimeFilter<"ConceptNumeric"> | Date | string
  }

  export type ConceptProposalUpsertWithWhereUniqueWithoutConceptInput = {
    where: ConceptProposalWhereUniqueInput
    update: XOR<ConceptProposalUpdateWithoutConceptInput, ConceptProposalUncheckedUpdateWithoutConceptInput>
    create: XOR<ConceptProposalCreateWithoutConceptInput, ConceptProposalUncheckedCreateWithoutConceptInput>
  }

  export type ConceptProposalUpdateWithWhereUniqueWithoutConceptInput = {
    where: ConceptProposalWhereUniqueInput
    data: XOR<ConceptProposalUpdateWithoutConceptInput, ConceptProposalUncheckedUpdateWithoutConceptInput>
  }

  export type ConceptProposalUpdateManyWithWhereWithoutConceptInput = {
    where: ConceptProposalScalarWhereInput
    data: XOR<ConceptProposalUpdateManyMutationInput, ConceptProposalUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptProposalScalarWhereInput = {
    AND?: ConceptProposalScalarWhereInput | ConceptProposalScalarWhereInput[]
    OR?: ConceptProposalScalarWhereInput[]
    NOT?: ConceptProposalScalarWhereInput | ConceptProposalScalarWhereInput[]
    id?: StringFilter<"ConceptProposal"> | string
    uuid?: StringFilter<"ConceptProposal"> | string
    conceptId?: StringFilter<"ConceptProposal"> | string
    name?: StringFilter<"ConceptProposal"> | string
    description?: StringFilter<"ConceptProposal"> | string
    creator?: StringFilter<"ConceptProposal"> | string
    dateCreated?: DateTimeFilter<"ConceptProposal"> | Date | string
    lastChangedBy?: StringFilter<"ConceptProposal"> | string
    lastChangedDate?: DateTimeFilter<"ConceptProposal"> | Date | string
  }

  export type ConceptSetUpsertWithoutConceptListInput = {
    update: XOR<ConceptSetUpdateWithoutConceptListInput, ConceptSetUncheckedUpdateWithoutConceptListInput>
    create: XOR<ConceptSetCreateWithoutConceptListInput, ConceptSetUncheckedCreateWithoutConceptListInput>
    where?: ConceptSetWhereInput
  }

  export type ConceptSetUpdateToOneWithWhereWithoutConceptListInput = {
    where?: ConceptSetWhereInput
    data: XOR<ConceptSetUpdateWithoutConceptListInput, ConceptSetUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptSetUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSetUncheckedUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSourceUpsertWithoutConceptListInput = {
    update: XOR<ConceptSourceUpdateWithoutConceptListInput, ConceptSourceUncheckedUpdateWithoutConceptListInput>
    create: XOR<ConceptSourceCreateWithoutConceptListInput, ConceptSourceUncheckedCreateWithoutConceptListInput>
    where?: ConceptSourceWhereInput
  }

  export type ConceptSourceUpdateToOneWithWhereWithoutConceptListInput = {
    where?: ConceptSourceWhereInput
    data: XOR<ConceptSourceUpdateWithoutConceptListInput, ConceptSourceUncheckedUpdateWithoutConceptListInput>
  }

  export type ConceptSourceUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptSourceUncheckedUpdateWithoutConceptListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordUpsertWithWhereUniqueWithoutConceptInput = {
    where: ConceptWordWhereUniqueInput
    update: XOR<ConceptWordUpdateWithoutConceptInput, ConceptWordUncheckedUpdateWithoutConceptInput>
    create: XOR<ConceptWordCreateWithoutConceptInput, ConceptWordUncheckedCreateWithoutConceptInput>
  }

  export type ConceptWordUpdateWithWhereUniqueWithoutConceptInput = {
    where: ConceptWordWhereUniqueInput
    data: XOR<ConceptWordUpdateWithoutConceptInput, ConceptWordUncheckedUpdateWithoutConceptInput>
  }

  export type ConceptWordUpdateManyWithWhereWithoutConceptInput = {
    where: ConceptWordScalarWhereInput
    data: XOR<ConceptWordUpdateManyMutationInput, ConceptWordUncheckedUpdateManyWithoutConceptInput>
  }

  export type ConceptWordScalarWhereInput = {
    AND?: ConceptWordScalarWhereInput | ConceptWordScalarWhereInput[]
    OR?: ConceptWordScalarWhereInput[]
    NOT?: ConceptWordScalarWhereInput | ConceptWordScalarWhereInput[]
    id?: StringFilter<"ConceptWord"> | string
    uuid?: StringFilter<"ConceptWord"> | string
    conceptId?: StringFilter<"ConceptWord"> | string
    word?: StringFilter<"ConceptWord"> | string
    locale?: StringFilter<"ConceptWord"> | string
    creator?: StringFilter<"ConceptWord"> | string
    dateCreated?: DateTimeFilter<"ConceptWord"> | Date | string
    lastChangedBy?: StringFilter<"ConceptWord"> | string
    lastChangedDate?: DateTimeFilter<"ConceptWord"> | Date | string
  }

  export type ConceptCreateWithoutMetaListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutMetaListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutMetaListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutMetaListInput, ConceptUncheckedCreateWithoutMetaListInput>
  }

  export type ConceptCreateWithoutAnswerListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutAnswerListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutAnswerListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutAnswerListInput, ConceptUncheckedCreateWithoutAnswerListInput>
  }

  export type ConceptUpsertWithoutMetaListInput = {
    update: XOR<ConceptUpdateWithoutMetaListInput, ConceptUncheckedUpdateWithoutMetaListInput>
    create: XOR<ConceptCreateWithoutMetaListInput, ConceptUncheckedCreateWithoutMetaListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutMetaListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutMetaListInput, ConceptUncheckedUpdateWithoutMetaListInput>
  }

  export type ConceptUpdateWithoutMetaListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutMetaListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUpsertWithoutAnswerListInput = {
    update: XOR<ConceptUpdateWithoutAnswerListInput, ConceptUncheckedUpdateWithoutAnswerListInput>
    create: XOR<ConceptCreateWithoutAnswerListInput, ConceptUncheckedCreateWithoutAnswerListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutAnswerListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutAnswerListInput, ConceptUncheckedUpdateWithoutAnswerListInput>
  }

  export type ConceptUpdateWithoutAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutAnswerListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptCreateWithoutConceptClassInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptClassInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptClassInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput>
  }

  export type ConceptCreateManyConceptClassInputEnvelope = {
    data: ConceptCreateManyConceptClassInput | ConceptCreateManyConceptClassInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithWhereUniqueWithoutConceptClassInput = {
    where: ConceptWhereUniqueInput
    update: XOR<ConceptUpdateWithoutConceptClassInput, ConceptUncheckedUpdateWithoutConceptClassInput>
    create: XOR<ConceptCreateWithoutConceptClassInput, ConceptUncheckedCreateWithoutConceptClassInput>
  }

  export type ConceptUpdateWithWhereUniqueWithoutConceptClassInput = {
    where: ConceptWhereUniqueInput
    data: XOR<ConceptUpdateWithoutConceptClassInput, ConceptUncheckedUpdateWithoutConceptClassInput>
  }

  export type ConceptUpdateManyWithWhereWithoutConceptClassInput = {
    where: ConceptScalarWhereInput
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyWithoutConceptClassInput>
  }

  export type ConceptScalarWhereInput = {
    AND?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
    OR?: ConceptScalarWhereInput[]
    NOT?: ConceptScalarWhereInput | ConceptScalarWhereInput[]
    id?: StringFilter<"Concept"> | string
    uuid?: StringFilter<"Concept"> | string
    name?: StringFilter<"Concept"> | string
    description?: StringFilter<"Concept"> | string
    dataType?: StringFilter<"Concept"> | string
    class?: StringFilter<"Concept"> | string
    isRetired?: BoolFilter<"Concept"> | boolean
    retiredBy?: StringFilter<"Concept"> | string
    dateRetired?: DateTimeFilter<"Concept"> | Date | string
    retiredReason?: StringFilter<"Concept"> | string
    creator?: StringFilter<"Concept"> | string
    dateCreated?: DateTimeFilter<"Concept"> | Date | string
    lastChangedBy?: StringFilter<"Concept"> | string
    lastChangedDate?: DateTimeFilter<"Concept"> | Date | string
    conceptClassId?: StringNullableFilter<"Concept"> | string | null
    conceptDatatypeId?: StringNullableFilter<"Concept"> | string | null
    conceptMapId?: StringNullableFilter<"Concept"> | string | null
    conceptSetId?: StringNullableFilter<"Concept"> | string | null
    conceptSourceId?: StringNullableFilter<"Concept"> | string | null
  }

  export type ConceptCreateWithoutConceptDatatypeInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptDatatypeInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptDatatypeInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput>
  }

  export type ConceptCreateManyConceptDatatypeInputEnvelope = {
    data: ConceptCreateManyConceptDatatypeInput | ConceptCreateManyConceptDatatypeInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithWhereUniqueWithoutConceptDatatypeInput = {
    where: ConceptWhereUniqueInput
    update: XOR<ConceptUpdateWithoutConceptDatatypeInput, ConceptUncheckedUpdateWithoutConceptDatatypeInput>
    create: XOR<ConceptCreateWithoutConceptDatatypeInput, ConceptUncheckedCreateWithoutConceptDatatypeInput>
  }

  export type ConceptUpdateWithWhereUniqueWithoutConceptDatatypeInput = {
    where: ConceptWhereUniqueInput
    data: XOR<ConceptUpdateWithoutConceptDatatypeInput, ConceptUncheckedUpdateWithoutConceptDatatypeInput>
  }

  export type ConceptUpdateManyWithWhereWithoutConceptDatatypeInput = {
    where: ConceptScalarWhereInput
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyWithoutConceptDatatypeInput>
  }

  export type ConceptCreateWithoutConceptMapInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptMapInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptMapInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput>
  }

  export type ConceptCreateManyConceptMapInputEnvelope = {
    data: ConceptCreateManyConceptMapInput | ConceptCreateManyConceptMapInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithWhereUniqueWithoutConceptMapInput = {
    where: ConceptWhereUniqueInput
    update: XOR<ConceptUpdateWithoutConceptMapInput, ConceptUncheckedUpdateWithoutConceptMapInput>
    create: XOR<ConceptCreateWithoutConceptMapInput, ConceptUncheckedCreateWithoutConceptMapInput>
  }

  export type ConceptUpdateWithWhereUniqueWithoutConceptMapInput = {
    where: ConceptWhereUniqueInput
    data: XOR<ConceptUpdateWithoutConceptMapInput, ConceptUncheckedUpdateWithoutConceptMapInput>
  }

  export type ConceptUpdateManyWithWhereWithoutConceptMapInput = {
    where: ConceptScalarWhereInput
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyWithoutConceptMapInput>
  }

  export type ConceptCreateWithoutConceptNameListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptNameListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptNameListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptNameListInput, ConceptUncheckedCreateWithoutConceptNameListInput>
  }

  export type ConceptUpsertWithoutConceptNameListInput = {
    update: XOR<ConceptUpdateWithoutConceptNameListInput, ConceptUncheckedUpdateWithoutConceptNameListInput>
    create: XOR<ConceptCreateWithoutConceptNameListInput, ConceptUncheckedCreateWithoutConceptNameListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutConceptNameListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutConceptNameListInput, ConceptUncheckedUpdateWithoutConceptNameListInput>
  }

  export type ConceptUpdateWithoutConceptNameListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptNameListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptCreateWithoutConceptNumericListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptNumericListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptNumericListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptNumericListInput, ConceptUncheckedCreateWithoutConceptNumericListInput>
  }

  export type ConceptUpsertWithoutConceptNumericListInput = {
    update: XOR<ConceptUpdateWithoutConceptNumericListInput, ConceptUncheckedUpdateWithoutConceptNumericListInput>
    create: XOR<ConceptCreateWithoutConceptNumericListInput, ConceptUncheckedCreateWithoutConceptNumericListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutConceptNumericListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutConceptNumericListInput, ConceptUncheckedUpdateWithoutConceptNumericListInput>
  }

  export type ConceptUpdateWithoutConceptNumericListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptNumericListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptCreateWithoutConceptProposalListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptProposalListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptProposalListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptProposalListInput, ConceptUncheckedCreateWithoutConceptProposalListInput>
  }

  export type ConceptUpsertWithoutConceptProposalListInput = {
    update: XOR<ConceptUpdateWithoutConceptProposalListInput, ConceptUncheckedUpdateWithoutConceptProposalListInput>
    create: XOR<ConceptCreateWithoutConceptProposalListInput, ConceptUncheckedCreateWithoutConceptProposalListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutConceptProposalListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutConceptProposalListInput, ConceptUncheckedUpdateWithoutConceptProposalListInput>
  }

  export type ConceptUpdateWithoutConceptProposalListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptProposalListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptCreateWithoutConceptSetInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptSetInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptSetInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput>
  }

  export type ConceptCreateManyConceptSetInputEnvelope = {
    data: ConceptCreateManyConceptSetInput | ConceptCreateManyConceptSetInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithWhereUniqueWithoutConceptSetInput = {
    where: ConceptWhereUniqueInput
    update: XOR<ConceptUpdateWithoutConceptSetInput, ConceptUncheckedUpdateWithoutConceptSetInput>
    create: XOR<ConceptCreateWithoutConceptSetInput, ConceptUncheckedCreateWithoutConceptSetInput>
  }

  export type ConceptUpdateWithWhereUniqueWithoutConceptSetInput = {
    where: ConceptWhereUniqueInput
    data: XOR<ConceptUpdateWithoutConceptSetInput, ConceptUncheckedUpdateWithoutConceptSetInput>
  }

  export type ConceptUpdateManyWithWhereWithoutConceptSetInput = {
    where: ConceptScalarWhereInput
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyWithoutConceptSetInput>
  }

  export type ConceptCreateWithoutConceptSourceInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptWordList?: ConceptWordCreateNestedManyWithoutConceptInput
  }

  export type ConceptUncheckedCreateWithoutConceptSourceInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
    conceptWordList?: ConceptWordUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptSourceInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput>
  }

  export type ConceptCreateManyConceptSourceInputEnvelope = {
    data: ConceptCreateManyConceptSourceInput | ConceptCreateManyConceptSourceInput[]
    skipDuplicates?: boolean
  }

  export type ConceptUpsertWithWhereUniqueWithoutConceptSourceInput = {
    where: ConceptWhereUniqueInput
    update: XOR<ConceptUpdateWithoutConceptSourceInput, ConceptUncheckedUpdateWithoutConceptSourceInput>
    create: XOR<ConceptCreateWithoutConceptSourceInput, ConceptUncheckedCreateWithoutConceptSourceInput>
  }

  export type ConceptUpdateWithWhereUniqueWithoutConceptSourceInput = {
    where: ConceptWhereUniqueInput
    data: XOR<ConceptUpdateWithoutConceptSourceInput, ConceptUncheckedUpdateWithoutConceptSourceInput>
  }

  export type ConceptUpdateManyWithWhereWithoutConceptSourceInput = {
    where: ConceptScalarWhereInput
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyWithoutConceptSourceInput>
  }

  export type ConceptCreateWithoutConceptWordListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    metaList?: ConceptAnswerCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldCreateNestedManyWithoutConceptInput
    obsList?: ObsCreateNestedManyWithoutConceptInput
    orderList?: OrderCreateNestedManyWithoutConceptInput
    ConceptClass?: ConceptClassCreateNestedOneWithoutConceptListInput
    ConceptDatatype?: ConceptDatatypeCreateNestedOneWithoutConceptListInput
    conceptMap?: ConceptMapCreateNestedOneWithoutConceptListInput
    conceptNameList?: ConceptNameCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalCreateNestedManyWithoutConceptInput
    conceptSet?: ConceptSetCreateNestedOneWithoutConceptListInput
    conceptSource?: ConceptSourceCreateNestedOneWithoutConceptListInput
  }

  export type ConceptUncheckedCreateWithoutConceptWordListInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
    metaList?: ConceptAnswerUncheckedCreateNestedManyWithoutConceptInput
    answerList?: ConceptAnswerUncheckedCreateNestedManyWithoutAnswerConceptInput
    fieldList?: FieldUncheckedCreateNestedManyWithoutConceptInput
    obsList?: ObsUncheckedCreateNestedManyWithoutConceptInput
    orderList?: OrderUncheckedCreateNestedManyWithoutConceptInput
    conceptNameList?: ConceptNameUncheckedCreateNestedManyWithoutConceptInput
    conceptNumericList?: ConceptNumericUncheckedCreateNestedManyWithoutConceptInput
    conceptProposalList?: ConceptProposalUncheckedCreateNestedManyWithoutConceptInput
  }

  export type ConceptCreateOrConnectWithoutConceptWordListInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutConceptWordListInput, ConceptUncheckedCreateWithoutConceptWordListInput>
  }

  export type ConceptUpsertWithoutConceptWordListInput = {
    update: XOR<ConceptUpdateWithoutConceptWordListInput, ConceptUncheckedUpdateWithoutConceptWordListInput>
    create: XOR<ConceptCreateWithoutConceptWordListInput, ConceptUncheckedCreateWithoutConceptWordListInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutConceptWordListInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutConceptWordListInput, ConceptUncheckedUpdateWithoutConceptWordListInput>
  }

  export type ConceptUpdateWithoutConceptWordListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptWordListInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type FormResourceCreateWithoutResourceInput = {
    id?: string
    uuid: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    form: FormCreateNestedOneWithoutFormResourceListInput
  }

  export type FormResourceUncheckedCreateWithoutResourceInput = {
    id?: string
    uuid: string
    formId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceCreateOrConnectWithoutResourceInput = {
    where: FormResourceWhereUniqueInput
    create: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput>
  }

  export type FormResourceCreateManyResourceInputEnvelope = {
    data: FormResourceCreateManyResourceInput | FormResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type FormResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: FormResourceWhereUniqueInput
    update: XOR<FormResourceUpdateWithoutResourceInput, FormResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<FormResourceCreateWithoutResourceInput, FormResourceUncheckedCreateWithoutResourceInput>
  }

  export type FormResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: FormResourceWhereUniqueInput
    data: XOR<FormResourceUpdateWithoutResourceInput, FormResourceUncheckedUpdateWithoutResourceInput>
  }

  export type FormResourceUpdateManyWithWhereWithoutResourceInput = {
    where: FormResourceScalarWhereInput
    data: XOR<FormResourceUpdateManyMutationInput, FormResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type BlogPostAuthorCreateWithoutBlogPostListInput = {
    id?: string
    name: string
  }

  export type BlogPostAuthorUncheckedCreateWithoutBlogPostListInput = {
    id?: string
    name: string
  }

  export type BlogPostAuthorCreateOrConnectWithoutBlogPostListInput = {
    where: BlogPostAuthorWhereUniqueInput
    create: XOR<BlogPostAuthorCreateWithoutBlogPostListInput, BlogPostAuthorUncheckedCreateWithoutBlogPostListInput>
  }

  export type SpaceTimeCoordinatesCreateWithoutBlogPostInput = {
    id?: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime?: number | null
    stopTime: number
    timezone: string
    blogPostId: string
  }

  export type SpaceTimeCoordinatesUncheckedCreateWithoutBlogPostInput = {
    id?: string
    latitude: number
    longitude: number
    startTime: number
    pauseTime?: number | null
    stopTime: number
    timezone: string
    blogPostId: string
  }

  export type SpaceTimeCoordinatesCreateOrConnectWithoutBlogPostInput = {
    where: SpaceTimeCoordinatesWhereUniqueInput
    create: XOR<SpaceTimeCoordinatesCreateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogPostTagArrowCreateWithoutPostInput = {
    id?: string
    tag: BlogPostTagCreateNestedOneWithoutPostArrowListInput
  }

  export type BlogPostTagArrowUncheckedCreateWithoutPostInput = {
    id?: string
    tagId: string
  }

  export type BlogPostTagArrowCreateOrConnectWithoutPostInput = {
    where: BlogPostTagArrowWhereUniqueInput
    create: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput>
  }

  export type BlogPostTagArrowCreateManyPostInputEnvelope = {
    data: BlogPostTagArrowCreateManyPostInput | BlogPostTagArrowCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostAuthorUpsertWithoutBlogPostListInput = {
    update: XOR<BlogPostAuthorUpdateWithoutBlogPostListInput, BlogPostAuthorUncheckedUpdateWithoutBlogPostListInput>
    create: XOR<BlogPostAuthorCreateWithoutBlogPostListInput, BlogPostAuthorUncheckedCreateWithoutBlogPostListInput>
    where?: BlogPostAuthorWhereInput
  }

  export type BlogPostAuthorUpdateToOneWithWhereWithoutBlogPostListInput = {
    where?: BlogPostAuthorWhereInput
    data: XOR<BlogPostAuthorUpdateWithoutBlogPostListInput, BlogPostAuthorUncheckedUpdateWithoutBlogPostListInput>
  }

  export type BlogPostAuthorUpdateWithoutBlogPostListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostAuthorUncheckedUpdateWithoutBlogPostListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceTimeCoordinatesUpsertWithoutBlogPostInput = {
    update: XOR<SpaceTimeCoordinatesUpdateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedUpdateWithoutBlogPostInput>
    create: XOR<SpaceTimeCoordinatesCreateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedCreateWithoutBlogPostInput>
    where?: SpaceTimeCoordinatesWhereInput
  }

  export type SpaceTimeCoordinatesUpdateToOneWithWhereWithoutBlogPostInput = {
    where?: SpaceTimeCoordinatesWhereInput
    data: XOR<SpaceTimeCoordinatesUpdateWithoutBlogPostInput, SpaceTimeCoordinatesUncheckedUpdateWithoutBlogPostInput>
  }

  export type SpaceTimeCoordinatesUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
  }

  export type SpaceTimeCoordinatesUncheckedUpdateWithoutBlogPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    pauseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    stopTime?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    blogPostId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowUpsertWithWhereUniqueWithoutPostInput = {
    where: BlogPostTagArrowWhereUniqueInput
    update: XOR<BlogPostTagArrowUpdateWithoutPostInput, BlogPostTagArrowUncheckedUpdateWithoutPostInput>
    create: XOR<BlogPostTagArrowCreateWithoutPostInput, BlogPostTagArrowUncheckedCreateWithoutPostInput>
  }

  export type BlogPostTagArrowUpdateWithWhereUniqueWithoutPostInput = {
    where: BlogPostTagArrowWhereUniqueInput
    data: XOR<BlogPostTagArrowUpdateWithoutPostInput, BlogPostTagArrowUncheckedUpdateWithoutPostInput>
  }

  export type BlogPostTagArrowUpdateManyWithWhereWithoutPostInput = {
    where: BlogPostTagArrowScalarWhereInput
    data: XOR<BlogPostTagArrowUpdateManyMutationInput, BlogPostTagArrowUncheckedUpdateManyWithoutPostInput>
  }

  export type BlogPostTagArrowScalarWhereInput = {
    AND?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
    OR?: BlogPostTagArrowScalarWhereInput[]
    NOT?: BlogPostTagArrowScalarWhereInput | BlogPostTagArrowScalarWhereInput[]
    id?: StringFilter<"BlogPostTagArrow"> | string
    postId?: StringFilter<"BlogPostTagArrow"> | string
    tagId?: StringFilter<"BlogPostTagArrow"> | string
  }

  export type BlogPostTagArrowCreateWithoutTagInput = {
    id?: string
    post: BlogPostCreateNestedOneWithoutTagArrowListInput
  }

  export type BlogPostTagArrowUncheckedCreateWithoutTagInput = {
    id?: string
    postId: string
  }

  export type BlogPostTagArrowCreateOrConnectWithoutTagInput = {
    where: BlogPostTagArrowWhereUniqueInput
    create: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput>
  }

  export type BlogPostTagArrowCreateManyTagInputEnvelope = {
    data: BlogPostTagArrowCreateManyTagInput | BlogPostTagArrowCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostTagArrowUpsertWithWhereUniqueWithoutTagInput = {
    where: BlogPostTagArrowWhereUniqueInput
    update: XOR<BlogPostTagArrowUpdateWithoutTagInput, BlogPostTagArrowUncheckedUpdateWithoutTagInput>
    create: XOR<BlogPostTagArrowCreateWithoutTagInput, BlogPostTagArrowUncheckedCreateWithoutTagInput>
  }

  export type BlogPostTagArrowUpdateWithWhereUniqueWithoutTagInput = {
    where: BlogPostTagArrowWhereUniqueInput
    data: XOR<BlogPostTagArrowUpdateWithoutTagInput, BlogPostTagArrowUncheckedUpdateWithoutTagInput>
  }

  export type BlogPostTagArrowUpdateManyWithWhereWithoutTagInput = {
    where: BlogPostTagArrowScalarWhereInput
    data: XOR<BlogPostTagArrowUpdateManyMutationInput, BlogPostTagArrowUncheckedUpdateManyWithoutTagInput>
  }

  export type BlogPostCreateWithoutTagArrowListInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    author: BlogPostAuthorCreateNestedOneWithoutBlogPostListInput
    spaceTimeCoordinates: SpaceTimeCoordinatesCreateNestedOneWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutTagArrowListInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    authorId: string
    spaceTimeCoordinatesId: string
  }

  export type BlogPostCreateOrConnectWithoutTagArrowListInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutTagArrowListInput, BlogPostUncheckedCreateWithoutTagArrowListInput>
  }

  export type BlogPostTagCreateWithoutPostArrowListInput = {
    id?: string
    name: string
    descriptor?: string | null
  }

  export type BlogPostTagUncheckedCreateWithoutPostArrowListInput = {
    id?: string
    name: string
    descriptor?: string | null
  }

  export type BlogPostTagCreateOrConnectWithoutPostArrowListInput = {
    where: BlogPostTagWhereUniqueInput
    create: XOR<BlogPostTagCreateWithoutPostArrowListInput, BlogPostTagUncheckedCreateWithoutPostArrowListInput>
  }

  export type BlogPostUpsertWithoutTagArrowListInput = {
    update: XOR<BlogPostUpdateWithoutTagArrowListInput, BlogPostUncheckedUpdateWithoutTagArrowListInput>
    create: XOR<BlogPostCreateWithoutTagArrowListInput, BlogPostUncheckedCreateWithoutTagArrowListInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutTagArrowListInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutTagArrowListInput, BlogPostUncheckedUpdateWithoutTagArrowListInput>
  }

  export type BlogPostUpdateWithoutTagArrowListInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    author?: BlogPostAuthorUpdateOneRequiredWithoutBlogPostListNestedInput
    spaceTimeCoordinates?: SpaceTimeCoordinatesUpdateOneRequiredWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutTagArrowListInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    spaceTimeCoordinatesId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagUpsertWithoutPostArrowListInput = {
    update: XOR<BlogPostTagUpdateWithoutPostArrowListInput, BlogPostTagUncheckedUpdateWithoutPostArrowListInput>
    create: XOR<BlogPostTagCreateWithoutPostArrowListInput, BlogPostTagUncheckedCreateWithoutPostArrowListInput>
    where?: BlogPostTagWhereInput
  }

  export type BlogPostTagUpdateToOneWithWhereWithoutPostArrowListInput = {
    where?: BlogPostTagWhereInput
    data: XOR<BlogPostTagUpdateWithoutPostArrowListInput, BlogPostTagUncheckedUpdateWithoutPostArrowListInput>
  }

  export type BlogPostTagUpdateWithoutPostArrowListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostTagUncheckedUpdateWithoutPostArrowListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descriptor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinates: SpaceTimeCoordinatesCreateNestedOneWithoutBlogPostInput
    tagArrowList?: BlogPostTagArrowCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinatesId: string
    tagArrowList?: BlogPostTagArrowUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    context?: JsonFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    spaceTimeCoordinatesId?: StringFilter<"BlogPost"> | string
  }

  export type BlogPostCreateWithoutSpaceTimeCoordinatesInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    author: BlogPostAuthorCreateNestedOneWithoutBlogPostListInput
    tagArrowList?: BlogPostTagArrowCreateNestedManyWithoutPostInput
  }

  export type BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    authorId: string
    tagArrowList?: BlogPostTagArrowUncheckedCreateNestedManyWithoutPostInput
  }

  export type BlogPostCreateOrConnectWithoutSpaceTimeCoordinatesInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
  }

  export type BlogPostUpsertWithoutSpaceTimeCoordinatesInput = {
    update: XOR<BlogPostUpdateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedUpdateWithoutSpaceTimeCoordinatesInput>
    create: XOR<BlogPostCreateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedCreateWithoutSpaceTimeCoordinatesInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutSpaceTimeCoordinatesInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutSpaceTimeCoordinatesInput, BlogPostUncheckedUpdateWithoutSpaceTimeCoordinatesInput>
  }

  export type BlogPostUpdateWithoutSpaceTimeCoordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    author?: BlogPostAuthorUpdateOneRequiredWithoutBlogPostListNestedInput
    tagArrowList?: BlogPostTagArrowUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSpaceTimeCoordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    tagArrowList?: BlogPostTagArrowUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ServiceCreateWithoutEntryListInput = {
    id?: string
    description: string
    category: string
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutEntryListInput = {
    id?: string
    description: string
    category: string
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutEntryListInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutEntryListInput, ServiceUncheckedCreateWithoutEntryListInput>
  }

  export type BudgetCreateWithoutEntryListInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    report?: ReportCreateNestedOneWithoutBudgetInput
    userList?: BudgetBudUserCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutEntryListInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    report?: ReportUncheckedCreateNestedOneWithoutBudgetInput
    userList?: BudgetBudUserUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutEntryListInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutEntryListInput, BudgetUncheckedCreateWithoutEntryListInput>
  }

  export type ServiceUpsertWithoutEntryListInput = {
    update: XOR<ServiceUpdateWithoutEntryListInput, ServiceUncheckedUpdateWithoutEntryListInput>
    create: XOR<ServiceCreateWithoutEntryListInput, ServiceUncheckedCreateWithoutEntryListInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutEntryListInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutEntryListInput, ServiceUncheckedUpdateWithoutEntryListInput>
  }

  export type ServiceUpdateWithoutEntryListInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutEntryListInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpsertWithoutEntryListInput = {
    update: XOR<BudgetUpdateWithoutEntryListInput, BudgetUncheckedUpdateWithoutEntryListInput>
    create: XOR<BudgetCreateWithoutEntryListInput, BudgetUncheckedCreateWithoutEntryListInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutEntryListInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutEntryListInput, BudgetUncheckedUpdateWithoutEntryListInput>
  }

  export type BudgetUpdateWithoutEntryListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ReportUpdateOneWithoutBudgetNestedInput
    userList?: BudgetBudUserUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutEntryListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ReportUncheckedUpdateOneWithoutBudgetNestedInput
    userList?: BudgetBudUserUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetEntryCreateWithoutServiceInput = {
    id?: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutEntryListInput
  }

  export type BudgetEntryUncheckedCreateWithoutServiceInput = {
    id?: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetId: string
  }

  export type BudgetEntryCreateOrConnectWithoutServiceInput = {
    where: BudgetEntryWhereUniqueInput
    create: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput>
  }

  export type BudgetEntryCreateManyServiceInputEnvelope = {
    data: BudgetEntryCreateManyServiceInput | BudgetEntryCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BudgetEntryUpsertWithWhereUniqueWithoutServiceInput = {
    where: BudgetEntryWhereUniqueInput
    update: XOR<BudgetEntryUpdateWithoutServiceInput, BudgetEntryUncheckedUpdateWithoutServiceInput>
    create: XOR<BudgetEntryCreateWithoutServiceInput, BudgetEntryUncheckedCreateWithoutServiceInput>
  }

  export type BudgetEntryUpdateWithWhereUniqueWithoutServiceInput = {
    where: BudgetEntryWhereUniqueInput
    data: XOR<BudgetEntryUpdateWithoutServiceInput, BudgetEntryUncheckedUpdateWithoutServiceInput>
  }

  export type BudgetEntryUpdateManyWithWhereWithoutServiceInput = {
    where: BudgetEntryScalarWhereInput
    data: XOR<BudgetEntryUpdateManyMutationInput, BudgetEntryUncheckedUpdateManyWithoutServiceInput>
  }

  export type BudgetEntryScalarWhereInput = {
    AND?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
    OR?: BudgetEntryScalarWhereInput[]
    NOT?: BudgetEntryScalarWhereInput | BudgetEntryScalarWhereInput[]
    id?: StringFilter<"BudgetEntry"> | string
    serviceId?: StringFilter<"BudgetEntry"> | string
    cost?: FloatFilter<"BudgetEntry"> | number
    discount?: FloatFilter<"BudgetEntry"> | number
    promotion?: FloatFilter<"BudgetEntry"> | number
    subtotal?: FloatFilter<"BudgetEntry"> | number
    percentChange?: FloatFilter<"BudgetEntry"> | number
    createdAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetEntry"> | Date | string
    budgetId?: StringFilter<"BudgetEntry"> | string
  }

  export type BudgetEntryCreateWithoutBudgetInput = {
    id?: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutEntryListInput
  }

  export type BudgetEntryUncheckedCreateWithoutBudgetInput = {
    id?: string
    serviceId: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetEntryCreateOrConnectWithoutBudgetInput = {
    where: BudgetEntryWhereUniqueInput
    create: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetEntryCreateManyBudgetInputEnvelope = {
    data: BudgetEntryCreateManyBudgetInput | BudgetEntryCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutBudgetInput = {
    id?: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutBudgetInput = {
    id?: string
    totalCost: number
    totalDiscount: number
    totalPromotion: number
    totalSubtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutBudgetInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetBudUserCreateWithoutBudgetInput = {
    role: string
    ability: string
    category: string
    user: BudUserCreateNestedOneWithoutBudgetListInput
  }

  export type BudgetBudUserUncheckedCreateWithoutBudgetInput = {
    userId: string
    role: string
    ability: string
    category: string
  }

  export type BudgetBudUserCreateOrConnectWithoutBudgetInput = {
    where: BudgetBudUserWhereUniqueInput
    create: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetBudUserCreateManyBudgetInputEnvelope = {
    data: BudgetBudUserCreateManyBudgetInput | BudgetBudUserCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type BudgetEntryUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetEntryWhereUniqueInput
    update: XOR<BudgetEntryUpdateWithoutBudgetInput, BudgetEntryUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetEntryCreateWithoutBudgetInput, BudgetEntryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetEntryUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetEntryWhereUniqueInput
    data: XOR<BudgetEntryUpdateWithoutBudgetInput, BudgetEntryUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetEntryUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetEntryScalarWhereInput
    data: XOR<BudgetEntryUpdateManyMutationInput, BudgetEntryUncheckedUpdateManyWithoutBudgetInput>
  }

  export type ReportUpsertWithoutBudgetInput = {
    update: XOR<ReportUpdateWithoutBudgetInput, ReportUncheckedUpdateWithoutBudgetInput>
    create: XOR<ReportCreateWithoutBudgetInput, ReportUncheckedCreateWithoutBudgetInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutBudgetInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutBudgetInput, ReportUncheckedUpdateWithoutBudgetInput>
  }

  export type ReportUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalDiscount?: FloatFieldUpdateOperationsInput | number
    totalPromotion?: FloatFieldUpdateOperationsInput | number
    totalSubtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetBudUserUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetBudUserWhereUniqueInput
    update: XOR<BudgetBudUserUpdateWithoutBudgetInput, BudgetBudUserUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetBudUserCreateWithoutBudgetInput, BudgetBudUserUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetBudUserUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetBudUserWhereUniqueInput
    data: XOR<BudgetBudUserUpdateWithoutBudgetInput, BudgetBudUserUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetBudUserUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetBudUserScalarWhereInput
    data: XOR<BudgetBudUserUpdateManyMutationInput, BudgetBudUserUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetBudUserScalarWhereInput = {
    AND?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
    OR?: BudgetBudUserScalarWhereInput[]
    NOT?: BudgetBudUserScalarWhereInput | BudgetBudUserScalarWhereInput[]
    userId?: StringFilter<"BudgetBudUser"> | string
    budgetId?: StringFilter<"BudgetBudUser"> | string
    role?: StringFilter<"BudgetBudUser"> | string
    ability?: StringFilter<"BudgetBudUser"> | string
    category?: StringFilter<"BudgetBudUser"> | string
  }

  export type BudgetCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryCreateNestedManyWithoutBudgetInput
    userList?: BudgetBudUserCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryUncheckedCreateNestedManyWithoutBudgetInput
    userList?: BudgetBudUserUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutReportInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutReportInput, BudgetUncheckedCreateWithoutReportInput>
  }

  export type BudgetUpsertWithoutReportInput = {
    update: XOR<BudgetUpdateWithoutReportInput, BudgetUncheckedUpdateWithoutReportInput>
    create: XOR<BudgetCreateWithoutReportInput, BudgetUncheckedCreateWithoutReportInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutReportInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutReportInput, BudgetUncheckedUpdateWithoutReportInput>
  }

  export type BudgetUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUpdateManyWithoutBudgetNestedInput
    userList?: BudgetBudUserUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUncheckedUpdateManyWithoutBudgetNestedInput
    userList?: BudgetBudUserUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetBudUserCreateWithoutUserInput = {
    role: string
    ability: string
    category: string
    budget: BudgetCreateNestedOneWithoutUserListInput
  }

  export type BudgetBudUserUncheckedCreateWithoutUserInput = {
    budgetId: string
    role: string
    ability: string
    category: string
  }

  export type BudgetBudUserCreateOrConnectWithoutUserInput = {
    where: BudgetBudUserWhereUniqueInput
    create: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput>
  }

  export type BudgetBudUserCreateManyUserInputEnvelope = {
    data: BudgetBudUserCreateManyUserInput | BudgetBudUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BudEventCreateWithoutBudUserInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BudEventUncheckedCreateWithoutBudUserInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BudEventCreateOrConnectWithoutBudUserInput = {
    where: BudEventWhereUniqueInput
    create: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput>
  }

  export type BudEventCreateManyBudUserInputEnvelope = {
    data: BudEventCreateManyBudUserInput | BudEventCreateManyBudUserInput[]
    skipDuplicates?: boolean
  }

  export type BudgetBudUserUpsertWithWhereUniqueWithoutUserInput = {
    where: BudgetBudUserWhereUniqueInput
    update: XOR<BudgetBudUserUpdateWithoutUserInput, BudgetBudUserUncheckedUpdateWithoutUserInput>
    create: XOR<BudgetBudUserCreateWithoutUserInput, BudgetBudUserUncheckedCreateWithoutUserInput>
  }

  export type BudgetBudUserUpdateWithWhereUniqueWithoutUserInput = {
    where: BudgetBudUserWhereUniqueInput
    data: XOR<BudgetBudUserUpdateWithoutUserInput, BudgetBudUserUncheckedUpdateWithoutUserInput>
  }

  export type BudgetBudUserUpdateManyWithWhereWithoutUserInput = {
    where: BudgetBudUserScalarWhereInput
    data: XOR<BudgetBudUserUpdateManyMutationInput, BudgetBudUserUncheckedUpdateManyWithoutUserInput>
  }

  export type BudEventUpsertWithWhereUniqueWithoutBudUserInput = {
    where: BudEventWhereUniqueInput
    update: XOR<BudEventUpdateWithoutBudUserInput, BudEventUncheckedUpdateWithoutBudUserInput>
    create: XOR<BudEventCreateWithoutBudUserInput, BudEventUncheckedCreateWithoutBudUserInput>
  }

  export type BudEventUpdateWithWhereUniqueWithoutBudUserInput = {
    where: BudEventWhereUniqueInput
    data: XOR<BudEventUpdateWithoutBudUserInput, BudEventUncheckedUpdateWithoutBudUserInput>
  }

  export type BudEventUpdateManyWithWhereWithoutBudUserInput = {
    where: BudEventScalarWhereInput
    data: XOR<BudEventUpdateManyMutationInput, BudEventUncheckedUpdateManyWithoutBudUserInput>
  }

  export type BudEventScalarWhereInput = {
    AND?: BudEventScalarWhereInput | BudEventScalarWhereInput[]
    OR?: BudEventScalarWhereInput[]
    NOT?: BudEventScalarWhereInput | BudEventScalarWhereInput[]
    id?: StringFilter<"BudEvent"> | string
    type?: StringFilter<"BudEvent"> | string
    description?: StringFilter<"BudEvent"> | string
    categoryList?: StringNullableListFilter<"BudEvent">
    metadata?: JsonFilter<"BudEvent">
    budUserId?: StringFilter<"BudEvent"> | string
    createdAt?: DateTimeFilter<"BudEvent"> | Date | string
  }

  export type BudUserCreateWithoutBudgetListInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventList?: BudEventCreateNestedManyWithoutBudUserInput
  }

  export type BudUserUncheckedCreateWithoutBudgetListInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eventList?: BudEventUncheckedCreateNestedManyWithoutBudUserInput
  }

  export type BudUserCreateOrConnectWithoutBudgetListInput = {
    where: BudUserWhereUniqueInput
    create: XOR<BudUserCreateWithoutBudgetListInput, BudUserUncheckedCreateWithoutBudgetListInput>
  }

  export type BudgetCreateWithoutUserListInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryCreateNestedManyWithoutBudgetInput
    report?: ReportCreateNestedOneWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutUserListInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: number
    reportId?: string | null
    entryList?: BudgetEntryUncheckedCreateNestedManyWithoutBudgetInput
    report?: ReportUncheckedCreateNestedOneWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutUserListInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutUserListInput, BudgetUncheckedCreateWithoutUserListInput>
  }

  export type BudUserUpsertWithoutBudgetListInput = {
    update: XOR<BudUserUpdateWithoutBudgetListInput, BudUserUncheckedUpdateWithoutBudgetListInput>
    create: XOR<BudUserCreateWithoutBudgetListInput, BudUserUncheckedCreateWithoutBudgetListInput>
    where?: BudUserWhereInput
  }

  export type BudUserUpdateToOneWithWhereWithoutBudgetListInput = {
    where?: BudUserWhereInput
    data: XOR<BudUserUpdateWithoutBudgetListInput, BudUserUncheckedUpdateWithoutBudgetListInput>
  }

  export type BudUserUpdateWithoutBudgetListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventList?: BudEventUpdateManyWithoutBudUserNestedInput
  }

  export type BudUserUncheckedUpdateWithoutBudgetListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventList?: BudEventUncheckedUpdateManyWithoutBudUserNestedInput
  }

  export type BudgetUpsertWithoutUserListInput = {
    update: XOR<BudgetUpdateWithoutUserListInput, BudgetUncheckedUpdateWithoutUserListInput>
    create: XOR<BudgetCreateWithoutUserListInput, BudgetUncheckedCreateWithoutUserListInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutUserListInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutUserListInput, BudgetUncheckedUpdateWithoutUserListInput>
  }

  export type BudgetUpdateWithoutUserListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUpdateManyWithoutBudgetNestedInput
    report?: ReportUpdateOneWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutUserListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    entryList?: BudgetEntryUncheckedUpdateManyWithoutBudgetNestedInput
    report?: ReportUncheckedUpdateOneWithoutBudgetNestedInput
  }

  export type BudUserCreateWithoutEventListInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetList?: BudgetBudUserCreateNestedManyWithoutUserInput
  }

  export type BudUserUncheckedCreateWithoutEventListInput = {
    id?: string
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetList?: BudgetBudUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type BudUserCreateOrConnectWithoutEventListInput = {
    where: BudUserWhereUniqueInput
    create: XOR<BudUserCreateWithoutEventListInput, BudUserUncheckedCreateWithoutEventListInput>
  }

  export type BudUserUpsertWithoutEventListInput = {
    update: XOR<BudUserUpdateWithoutEventListInput, BudUserUncheckedUpdateWithoutEventListInput>
    create: XOR<BudUserCreateWithoutEventListInput, BudUserUncheckedCreateWithoutEventListInput>
    where?: BudUserWhereInput
  }

  export type BudUserUpdateToOneWithWhereWithoutEventListInput = {
    where?: BudUserWhereInput
    data: XOR<BudUserUpdateWithoutEventListInput, BudUserUncheckedUpdateWithoutEventListInput>
  }

  export type BudUserUpdateWithoutEventListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetList?: BudgetBudUserUpdateManyWithoutUserNestedInput
  }

  export type BudUserUncheckedUpdateWithoutEventListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetList?: BudgetBudUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentCreateManyAppointmentTypeInput = {
    id?: string
    uuid: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateWithoutAppointmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentListNestedInput
    location?: LocationUpdateOneRequiredWithoutAppointmentListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentListNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAppointmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutAppointmentTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyLocationInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterCreateManyLocationInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentType?: AppointmentTypeUpdateOneRequiredWithoutAppointmentListNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentListNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterCreateManyPatientInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentType?: AppointmentTypeUpdateOneRequiredWithoutAppointmentListNestedInput
    location?: LocationUpdateOneRequiredWithoutAppointmentListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentListNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyProviderInput = {
    id?: string
    uuid: string
    appointmentTypeId: string
    patientId: string
    locationId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterCreateManyProviderInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    formId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type AppointmentUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentType?: AppointmentTypeUpdateOneRequiredWithoutAppointmentListNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentListNestedInput
    location?: LocationUpdateOneRequiredWithoutAppointmentListNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterCreateManyFormInput = {
    id?: string
    uuid: string
    encounterId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceCreateManyFormInput = {
    id?: string
    uuid: string
    resourceId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormSubmissionCreateManyFormInput = {
    id?: string
    uuid: string
    encounterId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterCreateManyFormInput = {
    id?: string
    uuid: string
    encounterTypeId: string
    patientId: string
    locationId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormEncounterUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutFormEncounterListNestedInput
  }

  export type FormEncounterUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutFormResourceListNestedInput
  }

  export type FormResourceUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutFormSubmissionListNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterType?: EncounterTypeUpdateOneRequiredWithoutEncounterListNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterTypeId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerCreateManyFormSubmissionInput = {
    id?: string
    uuid: string
    fieldId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerUpdateWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldAnswerListNestedInput
  }

  export type FieldAnswerUncheckedUpdateWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerUncheckedUpdateManyWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateManyDieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    version: string
    retired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldAnswerCreateManyFieldInput = {
    id?: string
    uuid: string
    formSubmissionId: string
    value: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldOptionCreateManyFieldInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormUpdateWithoutDieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutDieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutFormNestedInput
    formResourceList?: FormResourceUncheckedUpdateManyWithoutFormNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutFormNestedInput
    encounterList?: EncounterUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateManyWithoutDieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    retired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formSubmission?: FormSubmissionUpdateOneRequiredWithoutFieldAnswerListNestedInput
  }

  export type FieldAnswerUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formSubmissionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldAnswerUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formSubmissionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOptionUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterCreateManyEncounterInput = {
    id?: string
    uuid: string
    formId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormSubmissionCreateManyEncounterInput = {
    id?: string
    uuid: string
    formId: string
    submissionDate: Date | string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsCreateManyEncounterInput = {
    id?: string
    uuid: string
    conceptId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderCreateManyEncounterInput = {
    id?: string
    uuid: string
    conceptId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type FormEncounterUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormEncounterListNestedInput
  }

  export type FormEncounterUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormEncounterUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormSubmissionListNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutObsListNestedInput
  }

  export type ObsUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterCreateManyEncounterTypeInput = {
    id?: string
    uuid: string
    patientId: string
    locationId: string
    formId: string
    providerId: string
    startDatetime: Date | string
    endDatetime: Date | string
    voided?: boolean
    voidedBy: string
    dateVoided: Date | string
    voidReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type EncounterUpdateWithoutEncounterTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEncounterListNestedInput
    location?: LocationUpdateOneRequiredWithoutEncounterListNestedInput
    form?: FormUpdateOneRequiredWithoutEncounterListNestedInput
    provider?: ProviderUpdateOneRequiredWithoutEncounterListNestedInput
    formEncounterList?: FormEncounterUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutEncounterTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formEncounterList?: FormEncounterUncheckedUpdateManyWithoutEncounterNestedInput
    formSubmissionList?: FormSubmissionUncheckedUpdateManyWithoutEncounterNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutEncounterNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutEncounterTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    voided?: BoolFieldUpdateOperationsInput | boolean
    voidedBy?: StringFieldUpdateOperationsInput | string
    dateVoided?: DateTimeFieldUpdateOperationsInput | Date | string
    voidReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyOrderFrequencyInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderUpdateWithoutOrderFrequencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderFrequencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutOrderFrequencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyOrderRouteInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type OrderUpdateWithoutOrderRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutOrderRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyOrderTypeInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderUnitId?: string | null
  }

  export type OrderUpdateWithoutOrderTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutOrderTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyOrderUnitInput = {
    id?: string
    uuid: string
    conceptId: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
  }

  export type OrderUpdateWithoutOrderUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutOrderListNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutOrderUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptAnswerCreateManyConceptInput = {
    id?: string
    uuid: string
    answerConceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerCreateManyAnswerConceptInput = {
    id?: string
    uuid: string
    conceptId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FieldCreateManyConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    fieldType: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ObsCreateManyConceptInput = {
    id?: string
    uuid: string
    encounterId: string
    obsDatetime: Date | string
    valueDatetime: Date | string
    valueNumeric: number
    valueText: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type OrderCreateManyConceptInput = {
    id?: string
    uuid: string
    encounterId: string
    orderDatetime: Date | string
    instructions: string
    dosage: string
    route: string
    frequency: string
    asNeeded?: boolean
    prn?: boolean
    quantity: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    orderFrequencyId?: string | null
    orderRouteId?: string | null
    orderTypeId?: string | null
    orderUnitId?: string | null
  }

  export type ConceptNameCreateManyConceptInput = {
    id?: string
    uuid: string
    name: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptNumericCreateManyConceptInput = {
    id?: string
    uuid: string
    hiAbsolute: number
    hiCritical: number
    hiNormal: number
    lowAbsolute: number
    lowCritical: number
    lowNormal: number
    units: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptProposalCreateManyConceptInput = {
    id?: string
    uuid: string
    name: string
    description: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptWordCreateManyConceptInput = {
    id?: string
    uuid: string
    word: string
    locale: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type ConceptAnswerUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    answerConcept?: ConceptUpdateOneRequiredWithoutAnswerListNestedInput
  }

  export type ConceptAnswerUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    answerConceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptAnswerUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    answerConceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptAnswerUpdateWithoutAnswerConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    concept?: ConceptUpdateOneRequiredWithoutMetaListNestedInput
  }

  export type ConceptAnswerUncheckedUpdateWithoutAnswerConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    conceptId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formList?: FormUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    formList?: FormUncheckedUpdateManyWithoutDieldNestedInput
    fieldAnswerList?: FieldAnswerUncheckedUpdateManyWithoutFieldNestedInput
    fieldOptionList?: FieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutObsListNestedInput
  }

  export type ObsUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObsUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    obsDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    valueNumeric?: FloatFieldUpdateOperationsInput | number
    valueText?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutOrderListNestedInput
    OrderFrequency?: OrderFrequencyUpdateOneWithoutOrderListNestedInput
    OrderRoute?: OrderRouteUpdateOneWithoutOrderListNestedInput
    OrderType?: OrderTypeUpdateOneWithoutOrderListNestedInput
    OrderUnit?: OrderUnitUpdateOneWithoutOrderListNestedInput
  }

  export type OrderUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    orderDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    asNeeded?: BoolFieldUpdateOperationsInput | boolean
    prn?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderFrequencyId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRouteId?: NullableStringFieldUpdateOperationsInput | string | null
    orderTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderUnitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptNameUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNameUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptNumericUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    hiAbsolute?: FloatFieldUpdateOperationsInput | number
    hiCritical?: FloatFieldUpdateOperationsInput | number
    hiNormal?: FloatFieldUpdateOperationsInput | number
    lowAbsolute?: FloatFieldUpdateOperationsInput | number
    lowCritical?: FloatFieldUpdateOperationsInput | number
    lowNormal?: FloatFieldUpdateOperationsInput | number
    units?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptProposalUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordUncheckedUpdateWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptWordUncheckedUpdateManyWithoutConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptCreateManyConceptClassInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
  }

  export type ConceptUpdateWithoutConceptClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateManyWithoutConceptClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptCreateManyConceptDatatypeInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
  }

  export type ConceptUpdateWithoutConceptDatatypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptDatatypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateManyWithoutConceptDatatypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptCreateManyConceptMapInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptSetId?: string | null
    conceptSourceId?: string | null
  }

  export type ConceptUpdateWithoutConceptMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateManyWithoutConceptMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptCreateManyConceptSetInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSourceId?: string | null
  }

  export type ConceptUpdateWithoutConceptSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSource?: ConceptSourceUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateManyWithoutConceptSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConceptCreateManyConceptSourceInput = {
    id?: string
    uuid: string
    name: string
    description: string
    dataType: string
    class: string
    isRetired?: boolean
    retiredBy: string
    dateRetired: Date | string
    retiredReason: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
    conceptClassId?: string | null
    conceptDatatypeId?: string | null
    conceptMapId?: string | null
    conceptSetId?: string | null
  }

  export type ConceptUpdateWithoutConceptSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metaList?: ConceptAnswerUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUpdateManyWithoutConceptNestedInput
    obsList?: ObsUpdateManyWithoutConceptNestedInput
    orderList?: OrderUpdateManyWithoutConceptNestedInput
    ConceptClass?: ConceptClassUpdateOneWithoutConceptListNestedInput
    ConceptDatatype?: ConceptDatatypeUpdateOneWithoutConceptListNestedInput
    conceptMap?: ConceptMapUpdateOneWithoutConceptListNestedInput
    conceptNameList?: ConceptNameUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUpdateManyWithoutConceptNestedInput
    conceptSet?: ConceptSetUpdateOneWithoutConceptListNestedInput
    conceptWordList?: ConceptWordUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutConceptSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
    metaList?: ConceptAnswerUncheckedUpdateManyWithoutConceptNestedInput
    answerList?: ConceptAnswerUncheckedUpdateManyWithoutAnswerConceptNestedInput
    fieldList?: FieldUncheckedUpdateManyWithoutConceptNestedInput
    obsList?: ObsUncheckedUpdateManyWithoutConceptNestedInput
    orderList?: OrderUncheckedUpdateManyWithoutConceptNestedInput
    conceptNameList?: ConceptNameUncheckedUpdateManyWithoutConceptNestedInput
    conceptNumericList?: ConceptNumericUncheckedUpdateManyWithoutConceptNestedInput
    conceptProposalList?: ConceptProposalUncheckedUpdateManyWithoutConceptNestedInput
    conceptWordList?: ConceptWordUncheckedUpdateManyWithoutConceptNestedInput
  }

  export type ConceptUncheckedUpdateManyWithoutConceptSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    isRetired?: BoolFieldUpdateOperationsInput | boolean
    retiredBy?: StringFieldUpdateOperationsInput | string
    dateRetired?: DateTimeFieldUpdateOperationsInput | Date | string
    retiredReason?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    conceptClassId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptDatatypeId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptMapId?: NullableStringFieldUpdateOperationsInput | string | null
    conceptSetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormResourceCreateManyResourceInput = {
    id?: string
    uuid: string
    formId: string
    creator: string
    dateCreated: Date | string
    lastChangedBy: string
    lastChangedDate: Date | string
  }

  export type FormResourceUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutFormResourceListNestedInput
  }

  export type FormResourceUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResourceUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChangedBy?: StringFieldUpdateOperationsInput | string
    lastChangedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostTagArrowCreateManyPostInput = {
    id?: string
    tagId: string
  }

  export type BlogPostTagArrowUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: BlogPostTagUpdateOneRequiredWithoutPostArrowListNestedInput
  }

  export type BlogPostTagArrowUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowCreateManyTagInput = {
    id?: string
    postId: string
  }

  export type BlogPostTagArrowUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: BlogPostUpdateOneRequiredWithoutTagArrowListNestedInput
  }

  export type BlogPostTagArrowUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostTagArrowUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    context: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinatesId: string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinates?: SpaceTimeCoordinatesUpdateOneRequiredWithoutBlogPostNestedInput
    tagArrowList?: BlogPostTagArrowUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinatesId?: StringFieldUpdateOperationsInput | string
    tagArrowList?: BlogPostTagArrowUncheckedUpdateManyWithoutPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    spaceTimeCoordinatesId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetEntryCreateManyServiceInput = {
    id?: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetId: string
  }

  export type BudgetEntryUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutEntryListNestedInput
  }

  export type BudgetEntryUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetEntryUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetEntryCreateManyBudgetInput = {
    id?: string
    serviceId: string
    cost: number
    discount: number
    promotion: number
    subtotal: number
    percentChange: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetBudUserCreateManyBudgetInput = {
    userId: string
    role: string
    ability: string
    category: string
  }

  export type BudgetEntryUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutEntryListNestedInput
  }

  export type BudgetEntryUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetEntryUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    promotion?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    percentChange?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetBudUserUpdateWithoutBudgetInput = {
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    user?: BudUserUpdateOneRequiredWithoutBudgetListNestedInput
  }

  export type BudgetBudUserUncheckedUpdateWithoutBudgetInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetBudUserUncheckedUpdateManyWithoutBudgetInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetBudUserCreateManyUserInput = {
    budgetId: string
    role: string
    ability: string
    category: string
  }

  export type BudEventCreateManyBudUserInput = {
    id?: string
    type: string
    description: string
    categoryList?: BudEventCreatecategoryListInput | string[]
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BudgetBudUserUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    budget?: BudgetUpdateOneRequiredWithoutUserListNestedInput
  }

  export type BudgetBudUserUncheckedUpdateWithoutUserInput = {
    budgetId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetBudUserUncheckedUpdateManyWithoutUserInput = {
    budgetId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    ability?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudEventUpdateWithoutBudUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudEventUncheckedUpdateWithoutBudUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudEventUncheckedUpdateManyWithoutBudUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryList?: BudEventUpdatecategoryListInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AppointmentTypeCountOutputTypeDefaultArgs instead
     */
    export type AppointmentTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderCountOutputTypeDefaultArgs instead
     */
    export type ProviderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormCountOutputTypeDefaultArgs instead
     */
    export type FormCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionCountOutputTypeDefaultArgs instead
     */
    export type FormSubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FieldCountOutputTypeDefaultArgs instead
     */
    export type FieldCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FieldCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterTypeCountOutputTypeDefaultArgs instead
     */
    export type EncounterTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderFrequencyCountOutputTypeDefaultArgs instead
     */
    export type OrderFrequencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderFrequencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderRouteCountOutputTypeDefaultArgs instead
     */
    export type OrderRouteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderRouteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderTypeCountOutputTypeDefaultArgs instead
     */
    export type OrderTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderUnitCountOutputTypeDefaultArgs instead
     */
    export type OrderUnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderUnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptCountOutputTypeDefaultArgs instead
     */
    export type ConceptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptClassCountOutputTypeDefaultArgs instead
     */
    export type ConceptClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptDatatypeCountOutputTypeDefaultArgs instead
     */
    export type ConceptDatatypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptDatatypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptMapCountOutputTypeDefaultArgs instead
     */
    export type ConceptMapCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptMapCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptSetCountOutputTypeDefaultArgs instead
     */
    export type ConceptSetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptSetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptSourceCountOutputTypeDefaultArgs instead
     */
    export type ConceptSourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptSourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceCountOutputTypeDefaultArgs instead
     */
    export type ResourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostCountOutputTypeDefaultArgs instead
     */
    export type BlogPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostTagCountOutputTypeDefaultArgs instead
     */
    export type BlogPostTagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostTagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostAuthorCountOutputTypeDefaultArgs instead
     */
    export type BlogPostAuthorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostAuthorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetCountOutputTypeDefaultArgs instead
     */
    export type BudgetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudUserCountOutputTypeDefaultArgs instead
     */
    export type BudUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentTypeDefaultArgs instead
     */
    export type AppointmentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProviderDefaultArgs instead
     */
    export type ProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormDefaultArgs instead
     */
    export type FormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormEncounterDefaultArgs instead
     */
    export type FormEncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormEncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormResourceDefaultArgs instead
     */
    export type FormResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormSubmissionDefaultArgs instead
     */
    export type FormSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FieldDefaultArgs instead
     */
    export type FieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FieldAnswerDefaultArgs instead
     */
    export type FieldAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FieldAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FieldOptionDefaultArgs instead
     */
    export type FieldOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FieldOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterTypeDefaultArgs instead
     */
    export type EncounterTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObsDefaultArgs instead
     */
    export type ObsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderFrequencyDefaultArgs instead
     */
    export type OrderFrequencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderFrequencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderRouteDefaultArgs instead
     */
    export type OrderRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderTypeDefaultArgs instead
     */
    export type OrderTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderUnitDefaultArgs instead
     */
    export type OrderUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderUnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptDefaultArgs instead
     */
    export type ConceptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptAnswerDefaultArgs instead
     */
    export type ConceptAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptClassDefaultArgs instead
     */
    export type ConceptClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptDatatypeDefaultArgs instead
     */
    export type ConceptDatatypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptDatatypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptMapDefaultArgs instead
     */
    export type ConceptMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptMapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptNameDefaultArgs instead
     */
    export type ConceptNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptNameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptNumericDefaultArgs instead
     */
    export type ConceptNumericArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptNumericDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptProposalDefaultArgs instead
     */
    export type ConceptProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptProposalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptSetDefaultArgs instead
     */
    export type ConceptSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptSourceDefaultArgs instead
     */
    export type ConceptSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptWordDefaultArgs instead
     */
    export type ConceptWordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptWordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostTagDefaultArgs instead
     */
    export type BlogPostTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostTagArrowDefaultArgs instead
     */
    export type BlogPostTagArrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostTagArrowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostAuthorDefaultArgs instead
     */
    export type BlogPostAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostAuthorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceTimeCoordinatesDefaultArgs instead
     */
    export type SpaceTimeCoordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceTimeCoordinatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetEntryDefaultArgs instead
     */
    export type BudgetEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudUserDefaultArgs instead
     */
    export type BudUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetBudUserDefaultArgs instead
     */
    export type BudgetBudUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetBudUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudEventDefaultArgs instead
     */
    export type BudEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudEventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}